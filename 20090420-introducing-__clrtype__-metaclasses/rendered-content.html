<p>Everyone knows <a href="http://channel9.msdn.com/pdc2008/TL16/">Anders announced at
PDC08</a> that <a href="http://code.msdn.microsoft.com/csharpfuture/Release/ProjectReleases.aspx?ReleaseId=1686">C#
4.0</a>
will include new features (aka the dynamic keyword + the DLR) that makes
it much easier for C# to call into dynamically typed code. What you
probably don’t know is that IronPython 2.6 includes a new feature that
makes it easier for IronPython code to be called by statically typed
code.</p>
<p>While the vast majority of .NET is available to IronPython, there are
certain APIs that just don’t work with dynamic code. In particular, any
code that uses Reflection over an object’s CLR type metadata won’t work
with IronPython. For example, while <a href="http://devhawk.net/2008/11/17/ironpython-and-wpf-part-3-data-binding/">WPF
supports</a><a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.icustomtypedescriptor.aspx">ICustomTypeDescriptor</a>,
Silverlight only supports data binding against reflectable properties.
Furthermore, any code that uses custom attributes inherently uses
Reflection. For example, Darrel Hawley recently blogged a <a href="http://www.darrellhawley.com/2009/03/writing-ironpython-wcf-host.html">WCF host he
wrote in
IronPython</a>,
but he wrote the WCF service in C#. You can’t write WCF services in
IronPython because WCF expects service classes <a href="http://msdn.microsoft.com/en-us/library/ms731835.aspx">to be
adorned</a> with
<a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.servicecontractattribute.aspx">ServiceContract</a>
and
<a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontractattribute.aspx">OperationContract</a>
attributes (among <em>many</em> others). IronPython users want access to use
these APIs. Support for custom attributes is one of the most <a href="http://lists.ironpython.com/pipermail/users-ironpython.com/2008-July/007733.html">common
requests</a>
we get – it’s currently the <a href="http://ironpython.codeplex.com/WorkItem/View.aspx?WorkItemId=20489">5th highest vote getter among open
issues</a>.</p>
<p>In IronPython 2.6, we’re adding the ability to customize the CLR type of
Python classes. This means you can add custom attributes, emit
properties, whatever you want. For those of you who’ve been dreaming of
implementing WCF services or databinding in Silverlight purely in
IronPython, then this is the feature for you.</p>
<p>In a nutshell, IronPython 2.6 extends Python’s
<a href="http://docs.python.org/reference/datamodel.html#customizing-class-creation">metaclass</a>
feature that lets you to customize the creation of classes. In the
metaclass, you can implement an IronPython-specific method
__clrtype__ which returns a custom
<a href="http://msdn.microsoft.com/library/system.type.aspx">System.Type</a> of
your own creation that IronPython will then use as the underlying CLR
type of the Python class. Implementing __clrtype__ gives you the
chance to implement whatever reflectable metadata you need:
constructors, fields, properties, methods, events, custom attributes,
nested classes, whatever.</p>
<p>Over a series of posts, I’ll be demonstrating this new feature and
implement some common scenario requests – including Silverlight
databinding and WCF services – purely in Python. Quick warning:
__clrtype__ uses low level features like Python metaclasses,
<a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.aspx">Reflection.Emit</a>
and <a href="http://dlr.codeplex.com/Project/Download/FileDownload.aspx?DownloadId=51534">DLR
Binders</a>
so these posts will be deeper technically than usual. Don’t worry – this
isn’t the API interface we expect everyone to use. Eventually, we want
to have an easy to use API that will sit on top of the low-level
__clrtype__ hook.</p>
