<p>As part of my series on <a href="http://devhawk.net/2008/11/12/ironpython-and-wpf-part-1-introduction/">using IronPython with
WPF</a>
<a id="fnref:1" href="#fn:1" class="footnote-ref"><sup>1</sup></a>, I built an extension method in C# that does <a href="http://devhawk.net/2008/11/14/ironpython-and-wpf-part-2-loading-xaml/">dynamic member
resolution on WPF
FrameworkElements</a>.
The upshot of this code is that I can write <code>win1.listbox1</code> instead of
<code>win1.FindName('listbox1')</code> when using WPF objects from Python or any
DLR language. Convenient, right?</p>
<p>The problem with this approach is that the C# extension method gets
compiled into an assembly that’s bound to a specific version of the DLR.
I recently started experimenting with a <a href="http://nightlybuilds.cloudapp.net/Project.aspx?project=ironpython">more recent
build</a>
of IronPython and I couldn’t load the extension method assembly due to a
conflict between the different versions of Microsoft.Scripting.dll. Of
course, I could have simply re-compiled the assembly against the new
bits, but that would mean every time I moved to a new version of
IronPython, I’d have to recompile. Worse, it would limit my ability to
run multiple versions of IronPython on my machine at once. I currently
have three – count ‘em, <em>three</em> – copies of IronPython installed: <a href="http://www.codeplex.com/IronPython/Release/ProjectReleases.aspx?ReleaseId=8365">2.0
RTM</a>,
<a href="http://nbs.blob.core.windows.net/ironpython/IronPython.46242.release.zip">nightly build version
46242</a>,
and an internal version <a href="http://devhawk.net/2008/09/17/dlr-namespace-change-fire-drill/">without the mangled
namespaces</a>
of our public CodePlex releases. Having to manage multiple copies of my
extension assembly would get annoying very quickly.</p>
<p>Instead of adding a reference to the compiled assembly, what if I could
add a reference to a C# file directly? Kinda like how adding references
to Python files works, but for statically compiled C#. That would let
me write code like the following, which falls back to adding a reference
to the C# file directly if adding a reference to the compiled assembly
fails.</p>
<div class="lang-python editor-colors">try:
  clr.AddReference('Microsoft.Scripting.Extension.Wpf.dll')
except:
  import codedom
  codedom.add_reference_cs_file('FrameworkElementExtension.cs',
    ['System', 'WindowsBase', 'PresentationFramework',
     'PresentationCore', 'Microsoft.Scripting'])

</div>
<p>Since this technique uses
<a href="http://msdn.microsoft.com/en-us/library/f1dfsbhc.aspx">CodeDOM</a>, I
decided to encapsulate the code in a Python module named codedom, which
is frankly pretty simple. As a shout-out to my pals on the <a href="http://blogs.msdn.com/vbteam/">VB
team</a>, I broke compiling out into it’s
own separate function so I could easily support adding VB as well as C#
files.</p>
<div class="lang-python editor-colors">def compile(prov, file, references):
  cp = CompilerParameters()
  cp.GenerateInMemory = True
  for ref in references:
    a = Assembly.LoadWithPartialName(ref)
    cp.ReferencedAssemblies.Add(a.Location)
  cr = prov.CompileAssemblyFromFile(cp, file)
  if cr.Errors.Count > 0:
    raise Exception(cr.Errors)
  return cr.CompiledAssembly

def add_reference_cs_file(file, references):
  clr.AddReference(compile(CSharpCodeProvider(), file, references))

def add_reference_vb_file(file, references):
  clr.AddReference(compile(VBCodeProvider(), file, references))

</div>
<p>The compile function uses a <a href="http://msdn.microsoft.com/en-us/library/system.codedom.compiler.codedomprovider.aspx">CodeDOM
provider</a>,
which provides a convenient function to <a href="http://msdn.microsoft.com/en-us/library/system.codedom.compiler.codedomprovider.compileassemblyfromfile.aspx">compile an assembly from a
single
file</a>.
The only tricky part was adding the references correctly. Of the five
references in this example, the only one CodeDOM can locate
automatically is System.dll. For the others, it appears that CodeDOM
needs the full path to the assembly in question.</p>
<p>Of course, hard-coding the assembly paths in my script would be too
fragile, so instead I use partial names. I load each referenced assembly
via
<a href="http://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadwithpartialname.aspx">Assembly.LoadWithPartialName</a>
then pass it’s Location to the CodeDOM provider via the
CompilerParameters object. I realize that loading an assembly just to
find its location it kind of overkill but a) I couldn’t find another
mechanism to locate an assemblies location given only a partial name and
b) I’m going to be loading the referenced assemblies when I load the
generated assembly anyway, so I figured it loading them to find their
location wasn’t a big deal. Note, that typically you’re used to passing
a string to clr.AddReference, but it also can accept an assembly object
directly.</p>
<p>Of course, this approach isn’t what you would call “fast”. Loading the
pre-compiled assembly is much, <em>much</em> faster than compiling the C# file
on the fly. But I figure slow code is better than code that doesn’t work
at all. Besides, the way the code is written, I only take the extra
compile hit if the pre-compiled assembly won’t load.</p>
<p>I stuck my
<a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/codedom.py">codedom.py</a>
file up on my SkyDrive. Feel free to leverage as you need.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn:1">
<p>I had to put that series on the back burner in part because the
<a href="http://windowslivewire.spaces.live.com/blog/cns!2F7EB29B42641D59!26304.entry">December update to Windows
Live</a>
totally broke my WPF photo viewing app. I’ve got a new WPF app I’m
working on, but I’m not quite ready to blog about it yet.<a href="#fnref:1" class="footnote-back-ref">&#8617;</a></p>
</li>
</ol>
</div>
