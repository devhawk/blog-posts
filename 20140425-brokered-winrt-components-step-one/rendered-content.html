<p>In this step, we’ll build the brokered component itself. Frankly, the
only thing that makes a brokered component different than a normal WinRT
component is some small tweaks to the project file to enable access to
the full .NET Runtime and Base Class Library. The <a href="http://msdn.microsoft.com/en-us/library/windows/apps/dn630195.aspx">brokered component
whitepaper</a>
describes the these tweaks in detail, but the new <a href="http://visualstudiogallery.msdn.microsoft.com/527286e4-b06a-4234-adde-d313c9c3c23e">brokered component
template</a> takes
care of these small tweaks for you.</p>
<div class="image-left"><p><a href="http://image.devhawk.net/blog-content/20140425-brokered-winrt-components-step-one/BRT_NewProject.png"><img src="http://image.devhawk.net/blog-content/20140425-brokered-winrt-components-step-one/BRT_NewProject-300x207.png" alt="BRT_NewProject" /></a></p>
</div>
<p>Start by selecting File -&gt; New -&gt; Project in Visual Studio. With the sheer
number of templates to choose from these days, I find it’s easier to
just search for the one I want. Type “broker” in the search box in the
upper left, you’ll end up with two choices – the brokered WinRT
component and the brokered WinRT proxy/stub. For now, choose the
brokered component. We’ll be adding a brokered proxy/stub <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">in step
two</a>.
Name the project whatever you want. I named mine “HelloWorldBRT”.</p>
<p>This is probably the easiest step of the three as there’s nothing really
special you have to do – just write managed code like you always do. In
my keynote demo, this is where I wrote the code that wrapped the
existing ADO.NET based data access library. For the purposes of this
walkthrough, let’s do something simpler. We’ll use P/Invoke to retrieve
the current
<a href="http://msdn.microsoft.com/en-us/library/windows/apps/ms683180.aspx">process</a>
and
<a href="http://msdn.microsoft.com/en-us/library/windows/apps/ms683183.aspx">thread</a>
IDs. These Win32 APIs are <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br205762.aspx">supported for developing WinRT
apps</a>
and will make it obvious that the component is running in a separate
process than the app. Here’s the simple code to retrieve those IDs (hat
tip to <a href="http://www.pinvoke.net">pinvoke.net</a> for the interop
signatures):</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">sealed</span> <span style="color:Blue;">class</span> Class
{
    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>)]
    <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">uint</span> GetCurrentThreadId();

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>)]
    <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">uint</span> GetCurrentProcessId();

    <span style="color:Blue;">public</span> <span style="color:Blue;">uint</span> CurrentThreadId
    {
        <span style="color:Blue;">get</span> { <span style="color:Blue;">return</span> GetCurrentThreadId(); }
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">uint</span> CurrentProcessId
    {
        <span style="color:Blue;">get</span> { <span style="color:Blue;">return</span> GetCurrentProcessId(); }
    }
}

</pre></div>
</div>
<p>That’s it! I didn’t even bother to change the class name for this simple
sample.</p>
<p>Now, to be clear, there’s no reason why this code needs to run in a
broker process. As I pointed out, the Win32 functions I’m wrapping here
are supported for use in Windows Store apps. For this walkthrough, I’m
trying to keep the code simple in order to focus on the specifics of
building brokered components. If you want to see an example that
actually leverages the fact that it’s running outside of the App
Container, check out the NorthwindRT sample.</p>
<p>In the <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">next
step</a>,
we’ll add the proxy/stub that enables this component to communicate
across a process boundary.</p>
