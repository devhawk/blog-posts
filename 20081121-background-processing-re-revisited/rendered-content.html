<p>OK, here’s the last word on this whole background processing /
concurrency decorators thing. I went back and re-wrote the <a href="http://devhawk.net/2008/11/19/ironpython-and-wpf-part-4-background-processing/">original
decorators</a>,
but using the approach I used with the <a href="http://devhawk.net/2008/11/20/ironpython-and-wpf-background-processing-revisited/">SyncContext
version</a>.
I don’t want to rehash it again, here are the main points:</p>
<ul>
<li>Instead of using a property to retrieve the dispatcher, I get it via
Application.Current.MainWindow.Dispatcher (checking to be sure
Current and MainWindow aren’t null…err, None). This way, I pick up
the dispatcher automatically rather than forcing a specific
interface on the class with decorated methods. In fact, this
approach should work with pure functions as well.</li>
<li>Since I don’t have a convenient function like
SetSynchronizationContext, I store the dispatcher in thread local
storage for later use in calling back to the UI thread.</li>
<li>Unlike the SyncContext version, this version propagates the return
value of @UIThread decorated functions. I don’t propagate the return
value of @BGThread functions – there’d be no point farming a task to
a background thread then blocking the UI thread waiting for a
response.</li>
</ul>
<p>As usual, the code is <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/WpfThreadDemo3.zip">on my
SkyDrive</a>.
It includes both the SyncContext and Dispatcher version of the
decorators.</p>
