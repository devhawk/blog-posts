<p>While I was <strike>banging my head against a wall</strike> experimenting with understanding how <a href="http://devhawk.net/2009/03/31/Writing+An+IronPython+Debugger+Displaying+Values.aspx">CorValue extraction worked</a>, I found myself wanting to dink around with the debugger objects in a REPL console. One of IronPython&#8217;s core strengths is support for &#8220;exploratory programming&#8221; via the REPL. It turned out bringing a REPL to ipydbg was quite simple.</p>
<p>Python includes two built-in features that making DIY REPL quite easy: compile and exec (though technically, exec is a statement, not a function). As you might assume from their names, compile converts a string into what Python calls a code object while exec executes a code object in a given scope. Technically, exec can accept a string so I could get by without using compile. However, if you&#8217;re compiling a single interactive statement compile can automatically insert a print statement if you&#8217;ve passed in a an expression. In other words, if you type in &#8220;2+2&#8221; on the console it will print &#8220;4&#8221;, which is the behavior I wanted.</p>
<p>Here&#8217;s what my REPL console code look like. I love that it&#8217;s only 20 lines of code.</p>
<pre class="brush: python">@inputcmd(_inputcmds, ConsoleKey.R)
def _input_repl_cmd(self, keyinfo):
  with CC.Gray:
    print &quot;nREPL ConsolenPress Ctl-Z to Exit&quot;
    cmd = &quot;&quot;
    _locals = {'self': self}

    while True:
      Console.Write(&quot;&gt;&gt;&gt;&quot; if not cmd else &quot;...&quot;)
      
      line = Console.ReadLine()
      if line == None:
        break
      
      if line:
        cmd = cmd + line + &quot;n&quot;
      else:
        try:
          if len(cmd) &gt; 0:
            exec compile(cmd, &quot;&lt;input&gt;&quot;, &quot;single&quot;) in globals(),_locals
        except Exception, ex:
          with CC.Red: print type(ex), ex
        cmd = &quot;&quot;
</pre>
<p>It&#8217;s pretty straightforward. I set up a dictionary to act as the local variable scope for the code that gets executed. I&#8217;m just reusing the current global scope, but I want the local scope to start with only the reference to the current IPyDebugProcess instance which is passed into _input_repl_cmd as &#8220;self&#8221;. All the other local variables like cmd and line won&#8217;t be available to the REPL code. Then I drop into a loop where I read lines from the console and execute them.</p>
<p>In order to support multi-line statements, I build up the cmd variable over multiple line inputs and I don&#8217;t execute it until the user inputs an empty line. In the standard Python console, it can recognize single line statements and execute them immediately. Dino showed me how to use the IronPython parser to do the same thing, but I haven&#8217;t implemented that in ipydbg yet. To exit the REPL loop, you type Ctl-Z, which returns None (aka null) from ReadLine instead of the empty string.</p>
<p>Since I never execute the code more than once, I have my exec and compile statements together on a single line. Compile takes the string to be compiled, the name of the file it came from (I&#8217;m using &lt;input&gt; for this) and the kind of code. Passing in &#8220;single&#8221; for the kind of code adds the auto-expression-print functionality I mentioned above. Then I exec the code object that&#8217;s returned in specified scope I&#8217;m managing for this instance of the REPL loop. If you exit out of the REPL and re-enter it, you get a fresh new copy of the local scope so any functions or variables you define in the last REPL are gone.</p>
<p>Runtime execution of code into a given scope is a hallmark of dynamic languages, but I&#8217;m still fairly green when it comes to Python so it took me a while to figure this out. Python code executes in a given scope, a combination of global and local variables. When you&#8217;re in the ipy.exe REPL, you&#8217;re at top level scope anyway, so global and local scope are the same &#8211; if you add something to global scope, it shows up in local scope and vis-versa. Inside a function, you&#8217;ll have the same global scope, but the local scope will be different and changes to one won&#8217;t be reflected in the other. The ipydbg REPL isn&#8217;t a function per-se, but it does provide an explicit local scope that gets disposed when you exit the REPL.</p>
<p>While having a debugger REPL is really convenient for prototyping new ipydbg commands, it&#8217;ll really shine once I get function evaluation working. Then I&#8217;ll be able to open a REPL console where the commands are executed in the <em>target</em> process instead of the <em>debugger</em> process as they are now. That will be very cool. Until then, the <a href="http://github.com/devhawk/ipydbg/commit/1993f263d31af5442f84d2139d3002a001a64fd8">latest code</a> is &#8211; as always &#8211; up on GitHub.</p>
