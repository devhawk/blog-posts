<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Booch on DSLs (Round 3)</title>
  <link>http://devhawk.net/2004/12/10/booch-on-dsls-round-3/</link>
  <pubDate>Fri, 10 Dec 2004 14:47:50 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://4ce7a305-e9a4-4fff-a3f4-095fcca52988</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Steve Cook <a href="http://blogs.msdn.com/stevecook/archive/2004/12/08/278507.aspx">responded</a> to Grady Booch's latest <a href="http://www-106.ibm.com/developerworks/blogs/dw_blog_comments.jspa?blog=317&amp;entry=67637">comments</a> on software factories and DSLs, which was in turn a response to an <a href="http://weblogs.asp.net/alan_cameron_wills/archive/2004/11/11/255831.aspx">entry</a> by Alan Wills. It's obvious that Booch is never going to agree with the DSL approach, but there are a couple of fascinating elements of the exchange.</p><p>First off is Microsoft's "rejection" of UML, which is just plain FUD. I'm behind on news reading (as usual) but I was clued into this conversation by a <a href="http://www.theserverside.com/news/thread.tss?thread_id=30488">post</a> on TSS.com that linked to Booch's blog and read "Grady Booch explains why he disagrees with Microsoft's rejection of the UML in favor of proprietary domain-specific languages." Not exactly priming the pump for intelligent discourse on the subject. As Alan and Steve both point out, we're not rejecting UML. UML is a tool, and like all tools it has things it's good at and things it's not good at. We're talking about using DSLs for things UML is not good at. </p><p>The next is Common Semantics. Every time he posts on DSLs, Booch mentions something about "covering the same semantic ground as the UML". I promised Dan in my <a href="http://blogs.msdn.com/devhawk/archive/2004/10/25/247644.aspx#248548">comments</a> that I would summarize this argument "in simple English" and I never got around to it. The term semantics simply means "meaning". For example, in C#, the keyword "class" always means the same thing - it has what Steve <a href="http://blogs.msdn.com/stevecook/archive/2004/12/08/278507.aspx">pointed out</a> is "objective semantics". Obviously, the word "class" has widely varying semantics in common use - when a high school senior cuts class he's not copying an object definition to the clipboard. But within the realm of C#, the word "class" has a well understood and precise meaning - it's so precise that the C# compiler can tell you if you use it incorrectly.</p><p>So when Booch writes about a "common semantic model", I take that to mean that he thinks there's a core set of well-defined concepts that all languages build on. And if that's what he means, I imagine he assumes all the interesting concepts are already defined by UML. I think that's where the primary disagreement lies - we don't think any one language can provide all the possible concepts needed for all programming domains. A language for developing a web app page flow will be built on very different semantic concepts that a language for developing telephone billing systems. Trying to build both of them on top of the same set of concepts is like putting a square peg in a round hole. </p><p>Furthermore, even if you wanted to build on a common set of concepts, it's not clear if UML provides a precisely defined set of concepts to build on. Obviously, Booch thinks it does, but there certainly isn't agreement in the industry. Steve refers to UML as having "cognitive semantics", which means there is no one objective definition for a specific element of UML. For example, in covering <a href="http://www.martinfowler.com/bliki/AggregationAndComposition.html">Aggregation and Composition</a>, Fowler refers to UML's white diamond aggregation as a "modeling placebo" and having "no standard meanings". When there's no standard objective meaning, then each person brings their own experience and reason in order to formulate their understanding - hence the term "cognitive". Of course, the chance that any two people will reach the same understanding via cognitive reasoning is slim to none - there's just too much room for personal interpretation. Because of this lack of objective precision, Steve describes the resulting discussion of UML and its semantics as "political, rather than objective" which IMO is not a good foundation to build your own language on.</p><p>In the end, the proof is in the pudding. Personally, I think Booch looks at UML with rose-colored glasses and that his beliefs don't mesh with reality. (Of course, our DSL modeling tools and software factories approach isn't far enough along yet to test against reality.) How about your experience? What success or failure have you had with UML?</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">494</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2004-12-10 14:47:50</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2004-12-10 14:47:50</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">booch-on-dsls-round-3</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="modelling"><![CDATA[Modelling]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[4ce7a305-e9a4-4fff-a3f4-095fcca52988]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Booch+On+DSLs+Round+3]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2004/12/10/Booch+On+DSLs+Round+3]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2735</wp:comment_id>
    <wp:comment_author><![CDATA[Alex Kazovic]]></wp:comment_author>
    <wp:comment_author_email>alex_kazovic@msn.com</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP></wp:comment_author_IP>
    <wp:comment_date>2004-12-10 23:01:36</wp:comment_date>
    <wp:comment_date_gmt>2004-12-11 07:01:36</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[One of my concerns with UML is when getting users involved. Their attitude seems to be “here we are again, IT trying to get us users to learn an IT language to describe a business problem. We would rather get IT to learn a business language to describe a business problem”.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2736</wp:comment_id>
    <wp:comment_author><![CDATA[JTD]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP></wp:comment_author_IP>
    <wp:comment_date>2004-12-13 06:51:27</wp:comment_date>
    <wp:comment_date_gmt>2004-12-13 14:51:27</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[So having a bunch of DSL's with no common underlying foundation is a 'good thing'?]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2737</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP></wp:comment_author_IP>
    <wp:comment_date>2004-12-16 22:35:32</wp:comment_date>
    <wp:comment_date_gmt>2004-12-17 06:35:32</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[JTD, that's not what I'm saying. Many DSL's need to relate to each other. Take Whitehorse for example: You have a app modeller and a data center modeler. These each have some unique semantics and some related semantics. If you go to deploy a web app onto a web server, some type of translation or corolation needs to take place. But within that web app, there are going to be a wide variety of semantics and abstractions - pages, controls, process flows, style sheets, postbacks, etc - that have no corolation in the data center model. Trying to make a single modeling language that supports all these semantics will be overcomplex and unusable. ]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>