{"status":"ok","post":{"id":1246,"type":"post","slug":"writing-an-ironpython-debugger-breakpoint-management","url":"http:\/\/devhawk.net\/2009\/04\/08\/writing-an-ironpython-debugger-breakpoint-management\/","status":"publish","title":"Writing an IronPython Debugger: Breakpoint Management","title_plain":"Writing an IronPython Debugger: Breakpoint Management","content":"<p><a href=\"http:\/\/devhawk.net\/2009\/03\/02\/Writing+An+IronPython+Debugger+Setting+A+Breakpoint.aspx\">Setting a breakpoint<\/a> was the second feature I implemented in ipydbg. While setting a breakpoint on the first line of the Python file being run is convenient, it was obviously necessary to provide the user a mechanism to create their own breakpoints, as well as enable and disable existing breakpoints.<\/p>\n<p>First thing I had to do was to refactor the create_breakpoint method. Originally, I was searching thru the symbol documents looking for the one that matched the filename in OnUpdateModuleSymbols. However, since I wanted to specify by new breakpoints via the same filename\/line number combination, it made more sense to move symbol document logic into create_breakpoint:<\/p>\n<pre class=\"brush: python\">\ndef create_breakpoint(module, filename, linenum):\n    reader = module.SymbolReader\n    if reader == None:\n      return None\n    \n    # currently, I'm only comparing filenames. This algorithm may need\n    # to get more sophisticated to support differntiating files with the \n    # same name in different paths\n    filename = Path.GetFileName(filename)\n    for doc in reader.GetDocuments():\n      if str.Compare(filename, Path.GetFileName(doc.URL), True) == 0:\n        linenum = doc.FindClosestLine(linenum)\n        method = reader.GetMethodFromDocumentPosition(doc, linenum, 0)\n        function = module.GetFunctionFromToken(method.Token.GetToken())\n        \n        for sp in get_sequence_points(method):\n          if sp.doc.URL == doc.URL and sp.start_line == linenum:\n            return function.ILCode.CreateBreakpoint(sp.offset)\n        \n        return function.CreateBreakpoint()\n<\/pre>\n<p>The new version isn\u2019t much different than the old. It loops thru the symbol documents looking for one that matches the filename argument. Then it creates the breakpoint the same way it did before. Eventually, I\u2019m going to need a better algorithm than \u201conly compare filenames\u201d, but it works for now. <\/p>\n<p>Once I made this change, it was trivial to implement a breakpoint add command. What was harder was deciding on the right user experience for this. I decided that breakpoint management was going to be the first multi-key command in ipydbg. so all the debug commands are prefixed with a \u201cb\u201d. I use the same <a href=\"http:\/\/devhawk.net\/2009\/04\/01\/Writing+An+IronPython+Debugger+Command+Routing.aspx\">command routing decorator<\/a> I used for input commands. As you can see, my breakpoint command looks a lot like my top level input method \u2013 read a key from the console then dispatch it via a commands dictionary that gets populated by @inputcmd decorators.<\/p>\n<pre class=\"brush: python\">\n@inputcmd(_inputcmds, ConsoleKey.B)\ndef _input_breakpoint(self, keyinfo):\n    keyinfo2 = Console.ReadKey()\n    if keyinfo2.Key in IPyDebugProcess._breakpointcmds:\n        return IPyDebugProcess._breakpointcmds[keyinfo2.Key](self, keyinfo2)\n    else:\n        print \"nInvalid breakpoint command\", str(keyinfo2.Key)\n        return False\n<\/pre>\n<p>Currently, there are four breakpoint commands: \u201ca\u201d for add, \u201cl\u201d for list, \u201ce\u201d for enable and \u201cd\u201d for disable. List is by far the simplest.<\/p>\n<pre class=\"brush: python\">\n@inputcmd(_breakpointcmds, ConsoleKey.L)\ndef _bp_list(self, keyinfo):\n  print \"nList Breakpoints\"   \n  for i, bp in enumerate(self.breakpoints): \n    sp = get_location(bp.Function, bp.Offset)\n    state = \"Active\" if bp.IsActive else \"Inactive\"\n    print \"  %d. %s:%d %s\" % (i+1, sp.doc.URL, sp.start_line, state)\n  return False\n<\/pre>\n<p>As you can see, I\u2019m keeping a list of breakpoints in my IPyDebugProcess class. Originally, I used <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/blob\/9dd12dadb79469ceac57b84b8adb1b0b531337c4\/CorDebug\/CorDebug\/AppDomain.cs#L52\">AppDomain.Breakpoints<\/a> list, but that only returns enabled breakpoints so I was forced to store my own list. Note also that I\u2019m using the <a href=\"http:\/\/docs.python.org\/library\/functions.html#enumerate\">enumerate function<\/a>, which returns a tuple of the collection count and item. I do this so I can refer to breakpoints by number when enabling or disabling them:<\/p>\n<pre class=\"brush: python\">\n@inputcmd(_breakpointcmds, ConsoleKey.E)\ndef _bp_enable(self, keyinfo):\n  self._set_bp_status(True)\n  \n@inputcmd(_breakpointcmds, ConsoleKey.D)\ndef _bp_disable(self, keyinfo):\n  self._set_bp_status(False)\n\ndef _set_bp_status(self, activate):\n  stat = \"Enable\" if activate else \"Disable\"\n  try:\n    bp_num = int(Console.ReadLine())\n    for i, bp in enumerate(self.breakpoints): \n      if i+1 == bp_num:\n        bp.Activate(activate)\n        print \"nBreakpoint %d %sd\" % (bp_num, stat)\n        return False\n    raise Exception, \"Breakpoint %d not found\" % bp_num\n    \n  except Exception, msg:\n    with CC.Red: print \"&amp;s breakpoint Failed %s\" % (stat, msg)\n<\/pre>\n<p>Since the code was identical, except for the value passed to bp.Activate, I factored the code into a separate _set_bp_status method. After the user presses \u2018b\u2019 and then either \u2018e\u2019 or \u2018d\u2019, they then type the number of the breakpoint provided by the breakpoint list command. _set_bp_status then simply iterates thru the list until it finds the matching breakpoint and calls Activate. Note that since it\u2019s possible to have 10 or more breakpoints, I\u2019m using ReadLine instead of ReadKey, meaning you have to hit return after you type in the breakpoint number.<\/p>\n<p>Finally, I need a way to create new breakpoints. With the refactoring of create_breakpoint, this is pretty straightforward<\/p>\n<pre class=\"brush: python\">\n@inputcmd(_breakpointcmds, ConsoleKey.A) \ndef _bp_add(self, keyinfo): \n  try: \n    args = Console.ReadLine().Trim().split(':') \n    if len(args) != 2: raise Exception, \"Only pass two arguments\"  \n    linenum = int(args[1]) \n     \n    for assm in self.active_appdomain.Assemblies: \n      for mod in assm.Modules: \n          bp = create_breakpoint(mod, args[0], linenum) \n          if bp != None: \n            self.breakpoints.append(bp) \n            bp.Activate(True) \n            Console.WriteLine( \"Breakpoint set\") \n            return False \n    raise Exception, \"Couldn't find %s:%d\" % (args[0], linenum)     \n\n  except Exception, msg: \n    with CC.Red: \n      print \"Add breakpoint failed\", msg\n<\/pre>\n<p>Most of _bp_add is processing the input arguments, looping through the modules and then storing the breakpoint that gets returned. When I set the initial breakpoint inside OnUpdateModuleSymbols, I have the module with updated symbols as an event argument. However, in the more general case we\u2019ve got no way of knowing which module of the current app domain contains the filename in question. So we loop thru all the modules, calling create_breakpoint on each until one returns a non-null value. Of course, \u201call the modules\u201d will include the IronPython implementation, but assuming you\u2019re running against released bits the call to create_breakpoint will return right away if debug symbols aren\u2019t available.<\/p>\n<p>As usual, the <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/tree\/b0caaf24c515f6153063cefd2bec80481c7917d5\">latest version<\/a> is up on GitHub. This will be the latest update to ipydbg for a little while. I worked on it quite a bit while I was at PyCon and have been busy with other things since I got home. Don\u2019t worry, I\u2019ll come back to it soon enough. As I <a href=\"http:\/\/devhawk.net\/2009\/04\/06\/Writing+An+IronPython+Debugger+REPL+Console.aspx\">mentioned Monday<\/a>, I want to get function evaluation working so I can have a REPL console running in the target process instead of the one I\u2019ve got currently running in the debugger process. <\/p>\n","excerpt":"<p>Setting a breakpoint was the second feature I implemented in ipydbg. While setting a breakpoint on the first line of the Python file being run is convenient, it was obviously necessary to provide the user a mechanism to create their own breakpoints, as well as enable and disable existing breakpoints. First thing I had to [&hellip;]<\/p>\n","date":"2009-04-08 14:45:44","modified":"2009-04-08 14:45:44","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["871d10b6-2dd2-4b8f-9dc8-b5aee43d8983"],"dasblog_compressedtitle":["Writing+An+IronPython+Debugger+Breakpoint+Management"],"dasblog_compressedtitleunique":["2009\/04\/08\/Writing+An+IronPython+Debugger+Breakpoint+Management"]}},"previous_url":"http:\/\/devhawk.net\/2009\/04\/06\/pygments-for-wl-writer-v1-0-1\/","next_url":"http:\/\/devhawk.net\/2009\/04\/13\/joining-the-lounge-advertising-network\/"}