<p>Last month, I <a href="http://devhawk.net/2009/07/09/Syntax+Highlighting+TextBoxes+In+WPF+Ndash+A+Sad+Story.aspx">lamented</a> the lack of extensibility of the WPF text box. While there are <a href="http://www.actiprosoftware.com/Products/DotNet/WindowsForms/SyntaxEditor/Default.aspx">several</a><a href="http://www.aqistar.com/">vendors</a> and at least one <a href="http://wiki.sharpdevelop.net/AvalonEdit.ashx">open source</a> custom syntax highlighting text box, it still really bothers me how inextensible the basic WPF text box is. I just want to do a simple colorizing REPL &#8211; why is that so hard?</p>
<p>So instead of using any of those syntax highlighting text boxes, I decided to build my own using the approach Ken Johnson <a href="http://www.codeproject.com/KB/WPF/CodeBox.aspx">wrote about</a> on Code Project. As I wrote before, it&#8217;s a hack &#8211; you set the text box&#8217;s foreground and background brushes to transparent so that you can override OnRender &#8211; but it works. </p>
<p>The big change I made from Ken&#8217;s code was to use DLR TokenCategorizer instead of regular expressions to tokenize the code. <a href="http://dlr.codeplex.com/SourceControl/changeset/view/26964#581527">TokenCategorizer</a> is a service provided by the DLR hosting API, which will tokenize a given script source for you. Here&#8217;s the code that colorizes the text in the text box.</p>
<p></p>
<pre class="brush: csharp">var source = Engine.CreateScriptSourceFromString(this.Text);
var tokenizer = Engine.GetService&lt;TokenCategorizer&gt;();
tokenizer.Initialize(null, source, SourceLocation.MinValue);

var t = tokenizer.ReadToken();
while (t.Category != TokenCategory.EndOfStream)
{
    if (SyntaxMap.ContainsKey(t.Category))
    {
        ft.SetForegroundBrush(_syntaxMap[t.Category], 
             t.SourceSpan.Start.Index, t.SourceSpan.Length);
    }

    t = tokenizer.ReadToken();
}
</pre>
<p>As you can see, I ask the engine for a TokenCategorizer, initialize it with the text box&#8217;s current contents, then iterate thru the tokens, looking for ones in my SyntaxMap. If the token category is in the syntax map, we change the foreground brush for that span of formatted text (ft is a WPF FormattedText instance I created earlier in the method. </p>
<p>Of course, this approach isn&#8217;t very efficient &#8211; it re-colorizes the entire file on every change. It turns out that some DLR TokenCategorizer are restartable so you can cache the tokenizer state at any point and then return later with a new TokenCategorizer instance and pick up tokenizing where you left off. With this approach, you could say tokenize a line at a time, allowing you to only need to retokenize the line where the change occurred rather than the entire file. But only IronPython supports tokenizer restarting today, so I decided to take the easy way and simple re-colorize on every change.</p>
<p>I named the project HawkCodeBox and I&#8217;ve <a href="http://github.com/devhawk/HawkCodeBox/tree/master">published the source</a> up on GitHub. It&#8217;s fairly simple, but of course the goal wasn&#8217;t to build the be-all-end-all text editor &#8211; other <a href="http://blogs.msdn.com/vseditor/">people in the VS team</a> already have that job. </p>
