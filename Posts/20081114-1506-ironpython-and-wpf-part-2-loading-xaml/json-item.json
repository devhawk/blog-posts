{"status":"ok","post":{"id":1189,"type":"post","slug":"ironpython-and-wpf-part-2-loading-xaml","url":"http:\/\/devhawk.net\/2008\/11\/14\/ironpython-and-wpf-part-2-loading-xaml\/","status":"publish","title":"IronPython and WPF Part 2: Loading XAML","title_plain":"IronPython and WPF Part 2: Loading XAML","content":"<p>If we\u2019re going to build a WPF app, we\u2019re going to want to be able to load some XAML. Sure, you can programmatically build up your UI, but WPF and more importantly WPF tools like <a href=\"http:\/\/www.microsoft.com\/expression\/products\/Overview.aspx?key=blend\">Expression Blend<\/a> are designed to work with XAML. Luckily, loading XAML is fairly easy:<\/p>\n<pre class=\"brush: python\">\ndef LoadXaml(filename):     \n    from System.IO import File     \n    from System.Windows.Markup import XamlReader     \n    with File.OpenRead(filename) as f:     \n        return XamlReader.Load(f)\n<\/pre>\n<\/p>\n<p>We simply open the filename provided and use XamlReader to build out the corresponding WPF object graph. Note, this is very different from the XAML approach used by C#\/VB or even by IronPythonStudio. In those scenarios, the XAML is compiled into a binary format (BAML) and embedded in the compiled assembly. For my TechieWife Photo viewer, it\u2019s all script so there\u2019s neither a XAML to BAML compile step nor a compiled assembly to embed the BAML into, so we\u2019re just loading raw XAML.<\/p>\n<p>Since we\u2019re using raw XAML, there are additional rules we need to follow. First, when using compiled XAML, we can specify the name of the event handler in the XAML directly. For XamlReader, that\u2019s no allowed since there\u2019s no C#\/VB class associated with the XAML. Speaking of class, you can\u2019t specify x:Class either. Finally, anywhere you want to use a static resource, as far as I can tell those need to be compiled in a static language. I think you could build one in C#, add a reference to that assembly via clr.AddReference, then use it from XAML and it should just work. However, since I\u2019m trying to stick to IronPython exclusively, I didn\u2019t try that scenario out.\u00a0 <\/p>\n<p>Since you can\u2019t specify the event handlers in XAML loaded by XamlReader, you have to bind the event handlers in code. There are two listboxes in my photo viewing app, and I want to capture the SelectionChanged event of both of them. Binding event handlers in IronPython code uses the same += syntax as C# uses.<\/p>\n<pre class=\"brush: python\">\nwin1 = wpf.LoadXaml('win1.xaml')     \n     \nwin1.listbox1.SelectionChanged += listbox1_OnSelectionChanged     \nwin1.listbox2.SelectionChanged += listbox2_OnSelectionChanged\n<\/pre>\n<p>My win1.xaml file has a Window type instance as the root. You don\u2019t need to be a deep WPF expert to realize that the WPF Window doesn\u2019t have listbox1 or listbox2 properties. Yet, in the code snippet above, I was able to say win1.listbox1 and get back the WPF ListBox element with that name. Cool trick, eh? Well, I can\u2019t take credit for it \u2013 I <a href=\"http:\/\/www.codeplex.com\/IronPython\/SourceControl\/FileView.aspx?itemId=649471&amp;changeSetId=43433\">copied the code<\/a> from our Silverlight integration for dynamic languages. Unfortunately, this code has to be written in C# code, but it is the only C# code in my whole solution (and it\u2019s reusable!)<\/p>\n<pre class=\"brush: csharp\">\n[assembly: ExtensionType(    \n    typeof(FrameworkElement),  \n    typeof(DevHawk.Scripting.Wpf.FrameworkElementExtension))]  \n\nnamespace DevHawk.Scripting.Wpf  \n{  \n    public static class FrameworkElementExtension  \n    {  \n        [SpecialName]  \n        public static object GetBoundMember(FrameworkElement e, string n)  \n        {  \n            object result = e.FindName(n);  \n            if (result == null)  \n            {  \n                return OperationFailed.Value;  \n            }  \n            return result;  \n        }  \n    }  \n}\n<\/pre>\n<p>GetBoundMember is kinda like Python\u2019s <a href=\"http:\/\/www.python.org\/doc\/2.5.2\/ref\/attribute-access.html\">__getattr__<\/a> or Ruby\u2019s <a href=\"http:\/\/www.thinkruby.org\/2007\/10\/48\">method_missing<\/a>. Of course, it doesn\u2019t work with C#, but it does lets us trap dynamic member resolution when calling a C# object from a DLR language. Srivatsn has a <a href=\"http:\/\/blogs.msdn.com\/srivatsn\/archive\/2008\/04\/12\/turning-your-net-object-models-dynamic-for-ironpython.aspx\">great write up<\/a> on using GetBoundMember and the four other special methods you can use to make your CLR objects act more dynamic.<\/p>\n<p>In this case, if the standard reflection-based member name resolution fails, we try calling FrameworkElement\u2019s FindName method to see if there\u2019s a corresponding control with the provided name. So win.listbox1 is the equivalent to win.FindName(\u2018listbox1\u2019), but with less code and a much more pythonic feel.<\/p>\n<p>You\u2019ll notice that we\u2019re attaching this GetBoundMember method to FrameworkElement as an extension method. It\u2019s kinda cool that we can inject a new method into an existing class to provides dynamic behavior and it all works seamlessly from Python. However, DLR uses a different mechanism to locate and bind extension methods than C# or VB. Those languages use <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.runtime.compilerservices.extensionattribute.aspx\">ExtensionAttribute<\/a> to mark extension methods and the assemblies and classes that contain them. However, that approach forces you to examine ever single class in marked assemblies and every single method in marked classes. Examining every class and method is no big deal to do at compile time, but it would be a significant perf issue at runtime. By using ExtensionType attribute, the DLR only has to look at assembly attributes in order to bind extension methods.<\/p>\n<p>Once you\u2019ve got the compiled FrameworkElementExtension assembly, you just need to load it via clr.AddReference. I called the assembly Devhawk.Scripting.Wpf and I load it automatically in my wpy.py module. So if you\u2019re building a WPF app in IronPython, you can simply \u201cimport wpy\u201d and you get the GetBoundMember extension method, the LoadXaml function, and a bunch of WPF related namespaces imported into the wpf scope. That way, you can write wpf.Button() instead of System.Windows.Control.Button() to programmatically create a new button. <\/p>\n","excerpt":"<p>If we\u2019re going to build a WPF app, we\u2019re going to want to be able to load some XAML. Sure, you can programmatically build up your UI, but WPF and more importantly WPF tools like Expression Blend are designed to work with XAML. Luckily, loading XAML is fairly easy: def LoadXaml(filename): from System.IO import File [&hellip;]<\/p>\n","date":"2008-11-14 15:06:49","modified":"2008-11-14 15:06:49","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":271,"slug":"wpf","title":"WPF","description":"","post_count":8}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["8aeb8568-e08e-4dbf-bb03-02a2cb0cb567"],"dasblog_compressedtitle":["IronPython+And+WPF+Part+2+Loading+XAML"],"dasblog_compressedtitleunique":["2008\/11\/14\/IronPython+And+WPF+Part+2+Loading+XAML"]}},"previous_url":"http:\/\/devhawk.net\/2008\/11\/12\/ironpython-and-wpf-part-1-introduction\/","next_url":"http:\/\/devhawk.net\/2008\/11\/17\/ironpython-and-wpf-part-3-data-binding\/"}