{"status":"ok","post":{"id":1269,"type":"post","slug":"microsoft-scripting-debugging","url":"http:\/\/devhawk.net\/2009\/07\/08\/microsoft-scripting-debugging\/","status":"publish","title":"Microsoft.Scripting.Debugging","title_plain":"Microsoft.Scripting.Debugging","content":"<p>If you\u2019ve compiled IronPython from source recently, you may have noticed a new DLL: <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#908451\">Microsoft.Scripting.Debugging<\/a>. This DLL contains a lightweight, non-blocking debugger for DLR based languages that is going to enable both new scenarios as well as better compatibility with CPython. Needless to say, we\u2019re very excited about it.<\/p>\n<p>When I was actively working on my <a href=\"http:\/\/devhawk.net\/CategoryView,category,Debugger.aspx\">ipydbg series<\/a>, I got several emails asking about using it in an embedded scripting scenario. Unfortunately, the ipydbg approach doesn\u2019t work very well in the embedded scripting scenario. ipydbg uses <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms230588.aspx\">ICorDebug<\/a> and friends, which completely blocks the application being debugged. This means, your debugger <em>has<\/em> to run in a separate process. So either you run your debugger in your host app process and your scripts in a separate process or you run your debugger in a separate process debugging both the scripts and the host app. Neither option is very appealing. <\/p>\n<p>Now with the DLR Debugger, you can run all three components in the same process. I think of the DLR debugger as a \u201ccooperative\u201d debugger in much the same way that Windows 3.x supported <a href=\"http:\/\/en.wikipedia.org\/wiki\/Cooperative_multitasking#Cooperative_multitasking.2Ftime-sharing\">cooperative multitasking<\/a>. It\u2019s also known as trace or traceback debugging. Code being debugged yields to the debugger at set points during its execution. The debugger then does whatever it wants, including showing UI and\/or letting the developer inspect or modify program state. When the debugger returns, execution of the original code continues until the next set point wherein the process repeats itself.<\/p>\n<p>The primary point of entry for the DLR Debugger is the <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#908446\">DebugContext class<\/a>. Notable there is the TransformLambda method, which takes a normal DLR LambdaExpression and transforms it into a cooperatively debugged LambdaExpression. LambdaExpressions can contain DebugInfoExpressions \u2013 typically we insert them at the start of every Python code line as well as one at the end of the function. When we run IronPython in debug mode (i.e. \u2013D), those get turned into sequence points <a href=\"http:\/\/devhawk.net\/2009\/03\/02\/Writing+An+IronPython+Debugger+Setting+A+Breakpoint.aspx\">as we saw<\/a> back when I was working on ipydbg. When using the DLR Debugger, those DebugInfoExpressions are transformed into calls out to <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#908429\">IDebugCallback<\/a>.OnDebugEvent. The DLR Debugger implements the IDebugCallback interface on the <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#908413\">TracePipeline<\/a> class which also implements <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#908414\">ITracePipeline<\/a>. In OnDebugEvent, TracePipeline calls out to an <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#908415\">ITraceCallback<\/a> instance you provide. The extra layer of indirection means you can change your traceback handler without having to regenerate the debuggable version of your functions. <\/p>\n<p>Of course, we hide all this DLR Debugger goo from you in IronPython. Python already has a mechanism for doing traceback debugging \u2013 <a href=\"http:\/\/docs.python.org\/library\/sys.html#sys.settrace\">sys.settrace<\/a>. Our ITraceCallback, <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#922366\">PythonTracebackListener<\/a>, wrapps the DLR Debugger API to expose the sys.settrace API. That makes this feature a twofer \u2013 new capability for IronPython + better compatibility with CPython. Instead of needing a custom tool (i.e. ipydbg) you can now use <a href=\"http:\/\/docs.python.org\/library\/pdb.html\">PDB<\/a> from the standard Python library (modulo bugs in our implementation). I haven\u2019t been working on ipydbg recently since you\u2019ll be able to use PDB soon enough.<\/p>\n<p>For those hosting IronPython, we also have a couple of static extension methods in our hosting API (look for the SetTrace functions in <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/56115#490056\">IronPythonHostingPython.cs<\/a>). These are simply wrappers around sys.settrace, so it has the same API regardless if you access it from inside IronPython or from the hosting API. But if you\u2019re hosting IronPython in a C# application, those extension methods are very convenient to use.<\/p>\n<p>This debugger will be in our regular releases of IronPython as of 2.6 beta 2 which is <a href=\"http:\/\/ironpython.codeplex.com\/Wiki\/View.aspx?title=2.6%20Release%20Plan\">scheduled<\/a> to drop at the end of this month. For those who just can\u2019t wait, it\u2019s available as source code starting with <a href=\"This code is in our daily source drops as of yesterday. \">yesterday\u2019s changeset<\/a>. Please let us know what you think!<\/p>\n","excerpt":"<p>If you\u2019ve compiled IronPython from source recently, you may have noticed a new DLL: Microsoft.Scripting.Debugging. This DLL contains a lightweight, non-blocking debugger for DLR based languages that is going to enable both new scenarios as well as better compatibility with CPython. Needless to say, we\u2019re very excited about it. When I was actively working on [&hellip;]<\/p>\n","date":"2009-07-08 14:42:36","modified":"2009-07-08 14:42:36","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2222,"name":"Kevin Hazzard","url":"http:\/\/www,gotnet.biz\/Blog","date":"2009-07-08 16:11:56","content":"<p>This is awesome, Harry. I&#8217;ve been wanting this is a long time. I do script embedding for my applications most of the time. This will be a great help. You folks on the DLR team are the best and brightest inside Microsoft. Keep it up!<\/p>\n","parent":0},{"id":2223,"name":"Lukas","url":"","date":"2009-07-09 01:29:55","content":"<p>Cool!<\/p>\n","parent":0},{"id":2224,"name":"Jeff Brown","url":"http:\/\/blog.bits-in-motion.com\/","date":"2009-07-18 22:46:43","content":"<p>Very cool!<\/p>\n<p>I was just adding support to Gallio for running RSpec tests with IronRuby and was wondering what the DLR debugging story was eventually going to look like.<\/p>\n<p>BTW, I&#8217;m quite happy integrating one or more IronPython supported testing frameworks too, if you have some to recommend.<\/p>\n","parent":0}],"attachments":[],"comment_count":3,"comment_status":"closed","custom_fields":{"dasblog_entryid":["d6791f97-1e11-4a64-959e-0fa0cb1bbb31"],"dasblog_compressedtitle":["MicrosoftScriptingDebugging"],"dasblog_compressedtitleunique":["2009\/07\/08\/MicrosoftScriptingDebugging"]}},"previous_url":"http:\/\/devhawk.net\/2009\/06\/18\/add-bcd-vhd-ps1\/","next_url":"http:\/\/devhawk.net\/2009\/07\/09\/syntax-highlighting-textboxes-in-wpf-a-sad-story\/"}