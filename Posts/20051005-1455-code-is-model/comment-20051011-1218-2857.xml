<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>2857</wp:comment_id>
  <wp:comment_author><![CDATA[John]]></wp:comment_author>
  <wp:comment_author_email></wp:comment_author_email>
  <wp:comment_author_url>http://blogs.msdn.com/jevdemon</wp:comment_author_url>
  <wp:comment_author_IP>131.107.0.102</wp:comment_author_IP>
  <wp:comment_date>2005-10-11 12:18:56</wp:comment_date>
  <wp:comment_date_gmt>2005-10-11 19:18:56</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[I have to admit I was ready to debunk this until you got into the (somewhat philosophical) discussion of code being an abstraction layer between the CPU and the developer - nice touch!  That said, I think we can agree that there are different types of models for different types of purposes.  Developers will easily buy into Code is Model but business analysts (and to a lesser extent, architects) will not.  The concept of domain-specfic models helps address this issue.   The one (minor) quibble is the section at the end dealing with views.  Just as we can have different types of models we can also have differnet types views of a single model.  We might have a code view versus a graphical view or an individual participant's view of a larger business process (e.g. a raw material supplier's view of their role and responsibilities in a larger manufacturer's supply chain).  
Nice post!]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>