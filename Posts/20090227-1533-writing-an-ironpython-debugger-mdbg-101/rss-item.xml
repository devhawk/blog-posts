<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Writing an IronPython Debugger: MDbg 101</title>
  <link>http://devhawk.net/2009/02/27/writing-an-ironpython-debugger-mdbg-101/</link>
  <pubDate>Fri, 27 Feb 2009 15:33:06 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://c122a8ee-102f-4478-a33b-cc0864b82d83</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Before I start writing any debugger code, I thought it would help to quickly review the .NET debugger infrastructure that is available as well as the design of the MDbg command line debugger. Please note, my understanding of this stuff is fairly rudimentary – <a href="http://blogs.msdn.com/jmstall/default.aspx">Mike Stall</a> is “da man” if you’re looking for a .NET debugger blogger to read.</p><p>The CLR provides a series of unmanaged APIs for things like <a href="http://msdn.microsoft.com/en-us/library/ms404385.aspx">hosting the CLR</a>, <a href="http://msdn.microsoft.com/en-us/library/ms404384.aspx">reading and writing CLR metadata</a> and – more relevant to our current discussion – <a href="http://msdn.microsoft.com/en-us/library/ms404520.aspx">debugging</a> as well as <a href="http://msdn.microsoft.com/en-us/library/ms404519.aspx">reading and writing debugger symbols</a>. These APIs are exposed as COM objects. The CLR Debugging API allows you to do those all the things you would expect to be able to do in a debugger: <a href="http://msdn.microsoft.com/en-us/library/ms230107.aspx">attach to processes</a> (actually, app domains), <a href="http://msdn.microsoft.com/en-us/library/ms233573.aspx">create breakpoints</a>, <a href="http://msdn.microsoft.com/en-us/library/ms233136.aspx">step thru code</a>, etc. Of course, being an unmanaged API, it’s pretty much unavailable to be used from IronPython. Luckily, MDbg wraps this unmanaged API for us, making it available to any managed language, including IronPython. </p><p>The basic design of MDbg looks like this:</p><p><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="image" border="0" alt="image" src="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/WritinganIronPythonDebuggerMDbg101_DAA3/image_5.png" width="517" height="237" /></p><p>At the bottom is the “raw” assembly, which contains the C# definitions of the unmanaged debugger API – basically anything that starts with <a href="http://msdn.microsoft.com/en-us/library/ms230588.aspx">ICorDebug</a> and <a href="http://msdn.microsoft.com/en-us/library/ms231592.aspx">ICorPublish</a>. Raw also defines some of the metadata API, since that’s how type information is exposed to the debugger. </p><p>The next level up is the “corapi” assembly, which I refer to as the low-level managed debugger API. This is a fairly thin layer that translates the unmanaged paradigm into something more palatable to managed code developers. For example, COM enumerators such as <a href="http://msdn.microsoft.com/en-us/library/ms233115.aspx">ICorDebugAppDomainEnum</a> are exposed as IEnumerable types. Also, the <a href="http://msdn.microsoft.com/en-us/library/ms232496.aspx">managed callback interface</a> gets exposed as .NET events. It’s not perfect – the code is written in C# 1.0 style so there are no generics or yields. </p><p>Where corapi is the low-level API, “mdbgeng” is the high-level managed debugger API. As you would expect, it wraps the low-level API and provides automatic implementations of common operations. For example, this layer maintains a list of breakpoints so you can create them before the relevant assembly has been loaded. Then when assemblies are loaded, it goes thru the list of unbound breakpoints to see if any can be bound. It’s also this layer that automatically creates the main entrypoint breakpoint. </p><p>Finally, at the top we have the MDbg application itself, as well as any MDbg extensions (represented by the … in the diagram above). The mdbgext assembly defines the types shared between MDbg.exe and the extension assemblies. MDbg has some cool extensions – including an <a href="http://blogs.msdn.com/jmstall/archive/2005/08/31/Mdbg_Python_ext.aspx">IronPython extension</a> – but for now I’m focused on building something as lightweight as possible, so I’m going to forgo an extensibility mechanism, at least for now.</p><p>My initial prototype was written against the high-level API. There were two problems with this approach. The first is that there’s no support for Just My Code in the high-level API. As I mentioned in <a href="http://devhawk.net/2009/02/27/Writing+An+IronPython+Debugger+Introduction.aspx">my last post</a>, JMC support is critical for this project. Adding JMC support isn’t hard, but I’m trying to make as few changes as possible to the MDbg source, since I’m not interested in forking and maintaining that code. Second, while the low-level API provides an event-based API (OnModuleLoad, OnBreakpoint, OnStepComplete, etc), the high-level API provides a more console-oriented looping API. I found the event-driven API to be cleaner to work with and I’m thinking it will work better if I ever build a GUI version of ipydbg. So I’ve decided to work against the low-level API (aka corapi).</p><p>I mentioned above that I didn’t want to change the MDbg source, but I did make one small change. The separation of corapi and raw into two separate assemblies is an outdated artifact of an earlier version of MDbg. So I decided to combine these two into a single assembly called CorDebug. Other than some simple cleanup to assembly level attributes to make a single assembly possible, I haven’t changed the source code at all. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1219</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-02-27 15:33:06</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-02-27 15:33:06</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">writing-an-ironpython-debugger-mdbg-101</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="debugger"><![CDATA[Debugger]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[c122a8ee-102f-4478-a33b-cc0864b82d83]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Writing+An+IronPython+Debugger+MDbg+101]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/02/27/Writing+An+IronPython+Debugger+MDbg+101]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2174</wp:comment_id>
    <wp:comment_author><![CDATA[Steve Shaw]]></wp:comment_author>
    <wp:comment_author_email>toolmakersteve98@shawstudio.com</wp:comment_author_email>
    <wp:comment_author_url>http://toolmakersteve.com</wp:comment_author_url>
    <wp:comment_author_IP>24.10.93.210</wp:comment_author_IP>
    <wp:comment_date>2009-04-11 21:27:15</wp:comment_date>
    <wp:comment_date_gmt>2009-04-12 04:27:15</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Harry,

Thank you for writing these posts. I recently started some experiments on Mdbg, and wasn't getting very far due to scarcity of documentation. Examining what you did has been my best source of information so far. Scary thought, huh  ;P

~Steve]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>