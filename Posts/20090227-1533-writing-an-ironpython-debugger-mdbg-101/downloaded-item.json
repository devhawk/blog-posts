{"status":"ok","post":{"id":1219,"type":"post","slug":"writing-an-ironpython-debugger-mdbg-101","url":"http:\/\/devhawk.net\/2009\/02\/27\/writing-an-ironpython-debugger-mdbg-101\/","status":"publish","title":"Writing an IronPython Debugger: MDbg 101","title_plain":"Writing an IronPython Debugger: MDbg 101","content":"<p>Before I start writing any debugger code, I thought it would help to quickly review the .NET debugger infrastructure that is available as well as the design of the MDbg command line debugger. Please note, my understanding of this stuff is fairly rudimentary \u2013 <a href=\"http:\/\/blogs.msdn.com\/jmstall\/default.aspx\">Mike Stall<\/a> is \u201cda man\u201d if you\u2019re looking for a .NET debugger blogger to read.<\/p>\n<p>The CLR provides a series of unmanaged APIs for things like <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms404385.aspx\">hosting the CLR<\/a>, <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms404384.aspx\">reading and writing CLR metadata<\/a> and \u2013 more relevant to our current discussion \u2013 <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms404520.aspx\">debugging<\/a> as well as <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms404519.aspx\">reading and writing debugger symbols<\/a>. These APIs are exposed as COM objects. The CLR Debugging API allows you to do those all the things you would expect to be able to do in a debugger: <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms230107.aspx\">attach to processes<\/a> (actually, app domains), <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms233573.aspx\">create breakpoints<\/a>, <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms233136.aspx\">step thru code<\/a>, etc. Of course, being an unmanaged API, it\u2019s pretty much unavailable to be used from IronPython. Luckily, MDbg wraps this unmanaged API for us, making it available to any managed language, including IronPython. <\/p>\n<p>The basic design of MDbg looks like this:<\/p>\n<p><img style=\"border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px\" title=\"image\" border=\"0\" alt=\"image\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/WritinganIronPythonDebuggerMDbg101_DAA3\/image_5.png\" width=\"517\" height=\"237\" \/><\/p>\n<p>At the bottom is the \u201craw\u201d assembly, which contains the C# definitions of the unmanaged debugger API \u2013 basically anything that starts with <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms230588.aspx\">ICorDebug<\/a> and <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms231592.aspx\">ICorPublish<\/a>. Raw also defines some of the metadata API, since that\u2019s how type information is exposed to the debugger. <\/p>\n<p>The next level up is the \u201ccorapi\u201d assembly, which I refer to as the low-level managed debugger API. This is a fairly thin layer that translates the unmanaged paradigm into something more palatable to managed code developers. For example, COM enumerators such as <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms233115.aspx\">ICorDebugAppDomainEnum<\/a> are exposed as IEnumerable types. Also, the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms232496.aspx\">managed callback interface<\/a> gets exposed as .NET events. It\u2019s not perfect \u2013 the code is written in C# 1.0 style so there are no generics or yields. <\/p>\n<p>Where corapi is the low-level API, \u201cmdbgeng\u201d is the high-level managed debugger API. As you would expect, it wraps the low-level API and provides automatic implementations of common operations. For example, this layer maintains a list of breakpoints so you can create them before the relevant assembly has been loaded. Then when assemblies are loaded, it goes thru the list of unbound breakpoints to see if any can be bound. It\u2019s also this layer that automatically creates the main entrypoint breakpoint. <\/p>\n<p>Finally, at the top we have the MDbg application itself, as well as any MDbg extensions (represented by the \u2026 in the diagram above). The mdbgext assembly defines the types shared between MDbg.exe and the extension assemblies. MDbg has some cool extensions \u2013 including an <a href=\"http:\/\/blogs.msdn.com\/jmstall\/archive\/2005\/08\/31\/Mdbg_Python_ext.aspx\">IronPython extension<\/a> \u2013 but for now I\u2019m focused on building something as lightweight as possible, so I\u2019m going to forgo an extensibility mechanism, at least for now.<\/p>\n<p>My initial prototype was written against the high-level API. There were two problems with this approach. The first is that there\u2019s no support for Just My Code in the high-level API. As I mentioned in <a href=\"http:\/\/devhawk.net\/2009\/02\/27\/Writing+An+IronPython+Debugger+Introduction.aspx\">my last post<\/a>, JMC support is critical for this project. Adding JMC support isn\u2019t hard, but I\u2019m trying to make as few changes as possible to the MDbg source, since I\u2019m not interested in forking and maintaining that code. Second, while the low-level API provides an event-based API (OnModuleLoad, OnBreakpoint, OnStepComplete, etc), the high-level API provides a more console-oriented looping API. I found the event-driven API to be cleaner to work with and I\u2019m thinking it will work better if I ever build a GUI version of ipydbg. So I\u2019ve decided to work against the low-level API (aka corapi).<\/p>\n<p>I mentioned above that I didn\u2019t want to change the MDbg source, but I did make one small change. The separation of corapi and raw into two separate assemblies is an outdated artifact of an earlier version of MDbg. So I decided to combine these two into a single assembly called CorDebug. Other than some simple cleanup to assembly level attributes to make a single assembly possible, I haven\u2019t changed the source code at all. <\/p>\n","excerpt":"<p>Before I start writing any debugger code, I thought it would help to quickly review the .NET debugger infrastructure that is available as well as the design of the MDbg command line debugger. Please note, my understanding of this stuff is fairly rudimentary \u2013 Mike Stall is \u201cda man\u201d if you\u2019re looking for a .NET [&hellip;]<\/p>\n","date":"2009-02-27 15:33:06","modified":"2009-02-27 15:33:06","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2174,"name":"Steve Shaw","url":"http:\/\/toolmakersteve.com","date":"2009-04-11 21:27:15","content":"<p>Harry,<\/p>\n<p>Thank you for writing these posts. I recently started some experiments on Mdbg, and wasn&#8217;t getting very far due to scarcity of documentation. Examining what you did has been my best source of information so far. Scary thought, huh  ;P<\/p>\n<p>~Steve<\/p>\n","parent":0}],"attachments":[],"comment_count":1,"comment_status":"closed","custom_fields":{"dasblog_entryid":["c122a8ee-102f-4478-a33b-cc0864b82d83"],"dasblog_compressedtitle":["Writing+An+IronPython+Debugger+MDbg+101"],"dasblog_compressedtitleunique":["2009\/02\/27\/Writing+An+IronPython+Debugger+MDbg+101"]}},"previous_url":"http:\/\/devhawk.net\/2009\/02\/27\/writing-an-ironpython-debugger-introduction\/","next_url":"http:\/\/devhawk.net\/2009\/02\/27\/writing-an-ironpython-debugger-hello-debugger\/"}