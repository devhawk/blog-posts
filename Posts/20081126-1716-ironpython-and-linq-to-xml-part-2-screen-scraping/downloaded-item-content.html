<p>First, I need to convert the HTML <a href="http://www.rockband.com/music/songs">list of Rock Band songs</a> into a machine readable format. That means doing a little screen scraping. Originally, I used <a href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> but I found that <a href="http://www.crummy.com/software/BeautifulSoup/documentation.html#Beautiful%20Soup%20Gives%20You%20Unicode,%20Dammit">UnicodeDammit</a> got confused on names like Blue &#214;yster Cult and M&#246;tley Cr&#252;e. I&#8217;m guessing it&#8217;s broken because IronPython doesn&#8217;t have non-unicode strings.</p>
<p>Instead, I used SgmlReader to provide an XmlReader interface over the HTML, then queried that data via Linq to XML. I used the <a href="http://wiki.developer.mindtouch.com/Community/SgmlReader">version of SgmlReader from MindTouch</a> since they include a compiled binary and it seems to be the only active maintained version. I wrapped it all up in a function called load that loads HTML from either disk or the network (based on the URI scheme) into an <a href="http://msdn.microsoft.com/en-us/library/system.xml.linq.xdocument.aspx">XDocument</a>.</p>
<pre class="brush: python">def loadStream(streamreader):
  from System.Xml.Linq import XDocument     
  from Sgml import SgmlReader     
   
  reader = SgmlReader()
  reader.DocType = &quot;HTML&quot;
  reader.InputStream = streamreader     
  return XDocument.Load(reader)
   
def load(url):
  from System import Uri     
  from System.IO import StreamReader     
   
  if isinstance(url, str):
    url = Uri(url)
   
  if url.Scheme == &quot;file&quot;:
    from System.IO import File     
    with File.OpenRead(url.LocalPath) as fs:
      with StreamReader(fs) as sr:
        return loadStream(sr)
  else:
    from System.Net import WebClient     
    wc = WebClient()
    with wc.OpenRead(url) as ns:
      with StreamReader(ns) as sr:
        return loadStream(sr)

def parse(text):
  from System.IO import StringReader     
  return loadStream(StringReader(text))
</pre>
<p>I call load, passing in the URL to the list of songs. The &#8220;official&#8221; Rock Band song page loads the actual content from <a href="url = 'http://www.rockband.com/music/getSearchResultsTable_Ajax?sort_on=songs.NAME&sort_order=asc'">a different page</a> via AJAX, so I just load the actual list directly via my load function. </p>
<p>Once the HTML is loaded as an XDocument, I need a way to find the specific HTML nodes I was looking for. As I said earlier, XDocument uses Linq to XML &#8211; there is not other API for querying the XML tree. In the HTML, there&#8217;s a div tag with the id &#8220;content&#8221; that contains all the song rows as table row elements. I built a simple function that uses the LINQ Single method to find the tag by it&#8217;s id attribute value.</p>
<pre class="brush: python">def FindById(node, id):
  def CheckId(n):
    a = n.Attribute('id')
    return a != None and a.Value == id     
   
  return linq.Single(node.Descendants(), CheckId)
</pre>
<p>(Side note &#8211; I didn&#8217;t like the verbosity of the &#8220;a != None and a<span style="color: blue">.</span>Value == id&#8221; line of code, by XAttributes are not comparable by value. That is, I can&#8217;t write &#8220;node.Attribute(&#8216;id&#8217;) == XAttribute(&#8216;id&#8217;, id)&#8221;. And writing &#8220;node.Attribute(&#8216;id&#8217;).Value == id&#8221; only works if every node has an id attribute. Not making XAttribute comparable by value seems like a strange design choice to me.)</p>
<p>LINQ to objects works just fine from IronPython, with a few caveats. First, IronPython doesn&#8217;t have extension methods, so you can&#8217;t chain calls together sequentially like you can in C#. So instead of collection.Where(&#8230;).Select(&#8230;), you have to write Select(Where(collection, &#8230;), &#8230;). Second, all the LINQ methods are generic, so you have to use the verbose list syntax (for example: Single[object] or Select[object,object]). Since Python doesn&#8217;t care about the generic types, I wrote a bunch of simple helper functions around the common LINQ methods that just use object as the generic type. Here are a few examples:</p>
<pre class="brush: python">def Single(col, fun):
  return Enumerable.Single[object](col, Func[object, bool](fun))
   
def Where(col, fun):
  return Enumerable.Where[object](col, Func[object, bool](fun))
   
def Select(col, fun):
  return Enumerable.Select[object, object](col, Func[object, object](fun))
</pre>
<p>Once I have the content node, all the songs are in tr nodes beneath it. I wrote a function called ScrapeSong that transforms a song tr node into a Song object (which I&#8217;ll talk about in the next installment of this series). I use LINQ methods Select, OrderBy and ThenBy to provide me an enumeration of Song objects, ordered by date added (descending) than artist name.</p>
<pre class="brush: python">def ScrapeSong(node):     
  tds = list(node.Elements(xhtml.ns+'td'))    
  anchor = list(tds[0].Elements(xhtml.ns+'a'))[0]    
      
  title = anchor.Value    
  url = anchor.Attribute('href').Value    
  artist = tds[1].Value    
  year = tds[2].Value    
  genre = tds[3].Value    
  difficulty = tds[4].Value    
  _type = tds[5].Value    
  added = DateTime.Parse(tds[6].Value)    
      
  return Song(title, artist, added, url, year, genre, difficulty, _type)    

songs = ThenBy(OrderByDesc(   
          Select(content.Elements(xhtml.ns +'tr'), ScrapeSong),    
          lambda s: s.added), lambda s: s.artist)
</pre>
<p>And that&#8217;s pretty much it. Next, I&#8217;ll iterate thru the list of songs and get the details I need from Zune&#8217;s catalog web services in order to write out a playlist that the Zune software will understand.</p>
