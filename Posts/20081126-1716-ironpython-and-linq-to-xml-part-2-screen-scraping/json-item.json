{"status":"ok","post":{"id":1199,"type":"post","slug":"ironpython-and-linq-to-xml-part-2-screen-scraping","url":"http:\/\/devhawk.net\/2008\/11\/26\/ironpython-and-linq-to-xml-part-2-screen-scraping\/","status":"publish","title":"IronPython and Linq to XML Part 2: Screen Scraping","title_plain":"IronPython and Linq to XML Part 2: Screen Scraping","content":"<p>First, I need to convert the HTML <a href=\"http:\/\/www.rockband.com\/music\/songs\">list of Rock Band songs<\/a> into a machine readable format. That means doing a little screen scraping. Originally, I used <a href=\"http:\/\/www.crummy.com\/software\/BeautifulSoup\/\">Beautiful Soup<\/a> but I found that <a href=\"http:\/\/www.crummy.com\/software\/BeautifulSoup\/documentation.html#Beautiful%20Soup%20Gives%20You%20Unicode,%20Dammit\">UnicodeDammit<\/a> got confused on names like Blue \u00d6yster Cult and M\u00f6tley Cr\u00fce. I\u2019m guessing it\u2019s broken because IronPython doesn\u2019t have non-unicode strings.<\/p>\n<p>Instead, I used SgmlReader to provide an XmlReader interface over the HTML, then queried that data via Linq to XML. I used the <a href=\"http:\/\/wiki.developer.mindtouch.com\/Community\/SgmlReader\">version of SgmlReader from MindTouch<\/a> since they include a compiled binary and it seems to be the only active maintained version. I wrapped it all up in a function called load that loads HTML from either disk or the network (based on the URI scheme) into an <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.xml.linq.xdocument.aspx\">XDocument<\/a>.<\/p>\n<pre class=\"brush: python\">\ndef loadStream(streamreader):\n  from System.Xml.Linq import XDocument     \n  from Sgml import SgmlReader     \n   \n  reader = SgmlReader()\n  reader.DocType = \"HTML\"\n  reader.InputStream = streamreader     \n  return XDocument.Load(reader)\n   \ndef load(url):\n  from System import Uri     \n  from System.IO import StreamReader     \n   \n  if isinstance(url, str):\n    url = Uri(url)\n   \n  if url.Scheme == \"file\":\n    from System.IO import File     \n    with File.OpenRead(url.LocalPath) as fs:\n      with StreamReader(fs) as sr:\n        return loadStream(sr)\n  else:\n    from System.Net import WebClient     \n    wc = WebClient()\n    with wc.OpenRead(url) as ns:\n      with StreamReader(ns) as sr:\n        return loadStream(sr)\n\ndef parse(text):\n  from System.IO import StringReader     \n  return loadStream(StringReader(text))\n<\/pre>\n<p>I call load, passing in the URL to the list of songs. The \u201cofficial\u201d Rock Band song page loads the actual content from <a href=\"url = 'http:\/\/www.rockband.com\/music\/getSearchResultsTable_Ajax?sort_on=songs.NAME&amp;sort_order=asc'\">a different page<\/a> via AJAX, so I just load the actual list directly via my load function. <\/p>\n<p>Once the HTML is loaded as an XDocument, I need a way to find the specific HTML nodes I was looking for. As I said earlier, XDocument uses Linq to XML \u2013 there is not other API for querying the XML tree. In the HTML, there\u2019s a div tag with the id \u201ccontent\u201d that contains all the song rows as table row elements. I built a simple function that uses the LINQ Single method to find the tag by it\u2019s id attribute value.<\/p>\n<pre class=\"brush: python\">\ndef FindById(node, id):\n  def CheckId(n):\n    a = n.Attribute('id')\n    return a != None and a.Value == id     \n   \n  return linq.Single(node.Descendants(), CheckId)\n<\/pre>\n<p>(Side note \u2013 I didn\u2019t like the verbosity of the \u201ca != None and a<span style=\"color: blue\">.<\/span>Value == id\u201d line of code, by XAttributes are not comparable by value. That is, I can\u2019t write \u201cnode.Attribute(\u2018id\u2019) == XAttribute(\u2018id\u2019, id)\u201d. And writing \u201cnode.Attribute(\u2018id\u2019).Value == id\u201d only works if every node has an id attribute. Not making XAttribute comparable by value seems like a strange design choice to me.)<\/p>\n<p>LINQ to objects works just fine from IronPython, with a few caveats. First, IronPython doesn\u2019t have extension methods, so you can\u2019t chain calls together sequentially like you can in C#. So instead of collection.Where(\u2026).Select(\u2026), you have to write Select(Where(collection, \u2026), \u2026). Second, all the LINQ methods are generic, so you have to use the verbose list syntax (for example: Single[object] or Select[object,object]). Since Python doesn\u2019t care about the generic types, I wrote a bunch of simple helper functions around the common LINQ methods that just use object as the generic type. Here are a few examples:<\/p>\n<pre class=\"brush: python\">\ndef Single(col, fun):\n  return Enumerable.Single[object](col, Func[object, bool](fun))\n   \ndef Where(col, fun):\n  return Enumerable.Where[object](col, Func[object, bool](fun))\n   \ndef Select(col, fun):\n  return Enumerable.Select[object, object](col, Func[object, object](fun))\n<\/pre>\n<p>Once I have the content node, all the songs are in tr nodes beneath it. I wrote a function called ScrapeSong that transforms a song tr node into a Song object (which I\u2019ll talk about in the next installment of this series). I use LINQ methods Select, OrderBy and ThenBy to provide me an enumeration of Song objects, ordered by date added (descending) than artist name.<\/p>\n<pre class=\"brush: python\">\ndef ScrapeSong(node):     \n  tds = list(node.Elements(xhtml.ns+'td'))    \n  anchor = list(tds[0].Elements(xhtml.ns+'a'))[0]    \n      \n  title = anchor.Value    \n  url = anchor.Attribute('href').Value    \n  artist = tds[1].Value    \n  year = tds[2].Value    \n  genre = tds[3].Value    \n  difficulty = tds[4].Value    \n  _type = tds[5].Value    \n  added = DateTime.Parse(tds[6].Value)    \n      \n  return Song(title, artist, added, url, year, genre, difficulty, _type)    \n\nsongs = ThenBy(OrderByDesc(   \n          Select(content.Elements(xhtml.ns +'tr'), ScrapeSong),    \n          lambda s: s.added), lambda s: s.artist)\n<\/pre>\n<p>And that\u2019s pretty much it. Next, I\u2019ll iterate thru the list of songs and get the details I need from Zune\u2019s catalog web services in order to write out a playlist that the Zune software will understand.<\/p>\n","excerpt":"<p>First, I need to convert the HTML list of Rock Band songs into a machine readable format. That means doing a little screen scraping. Originally, I used Beautiful Soup but I found that UnicodeDammit got confused on names like Blue \u00d6yster Cult and M\u00f6tley Cr\u00fce. I\u2019m guessing it\u2019s broken because IronPython doesn\u2019t have non-unicode strings. [&hellip;]<\/p>\n","date":"2008-11-26 17:16:51","modified":"2008-11-26 17:16:51","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":224,"slug":"linq","title":"LINQ","description":"","post_count":24},{"id":273,"slug":"rock-band","title":"Rock Band","description":"","post_count":4},{"id":238,"slug":"xml","title":"XML","description":"","post_count":11},{"id":274,"slug":"zune","title":"Zune","description":"","post_count":4}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2150,"name":"Ada","url":"http:\/\/AsimplewarppertoenableLinq-likestyle","date":"2008-12-04 02:48:01","content":"<p>import System, sys<br \/>\nimport linq<\/p>\n<p>linqs = {}<br \/>\nfor name in dir(linq):<br \/>\n    if not name.startswith(&#8216;__&#8217;):<br \/>\n        linqs[name] = getattr(linq, name)<\/p>\n<p>class IpyLinq:<br \/>\n    def __init__(self, col):<br \/>\n        self.col = col<\/p>\n<p>    def __iter__(self):<br \/>\n        return iter(self.col)<\/p>\n<p>    def __str__(self):<br \/>\n        return &#8216;[%s]&#8216; % &#8216;, &#8216;.join( (str(v) for v in self) )<\/p>\n<p>    def __repr__(self):<br \/>\n        return str(self)<\/p>\n<p>    def __getattr__(self, name):<br \/>\n        def decorator(*arg, **kws):<br \/>\n            self.col = linqFunc(self.col, *arg, **kws)<br \/>\n            return self<\/p>\n<p>        linqFunc = linqs[name]<br \/>\n        return decorator<\/p>\n<p>if __name__ == &#8216;__main__&#8217;:<br \/>\n    for x in IpyLinq([1, 2, 3, 4, 5]).Where(lambda x: x > 1).Where(lambda x: x < 5):<br \/>\n        print x<\/p>\n","parent":0},{"id":2151,"name":"Ada","url":"","date":"2008-12-04 03:29:41","content":"<p>My original implementation has a bug.<\/p>\n<p>class IpyLinq:<br \/>\n    def __init__(self, col):<br \/>\n        self.col = col<\/p>\n<p>    def __iter__(self):<br \/>\n        return iter(self.col)<\/p>\n<p>    def __str__(self):<br \/>\n        return &#8216;[%s]&#8216; % &#8216;, &#8216;.join( (str(v) for v in self) )<\/p>\n<p>    def __repr__(self):<br \/>\n        return str(self)<\/p>\n<p>    def __getattr__(self, name):<br \/>\n        def decorator(*arg, **kws):<br \/>\n            result = linqs[name](self.col, *arg, **kws)<br \/>\n            if hasattr(result, &#8216;__iter__&#8217;):<br \/>\n                return IpyLinq(result)<br \/>\n            else:<br \/>\n                return result<br \/>\n        return decorator<\/p>\n","parent":0}],"attachments":[],"comment_count":2,"comment_status":"closed","custom_fields":{"dasblog_entryid":["bcc253be-4491-4c1a-bc67-d9df809ce716"],"dasblog_compressedtitle":["IronPython+And+Linq+To+XML+Part+2+Screen+Scraping"],"dasblog_compressedtitleunique":["2008\/11\/27\/IronPython+And+Linq+To+XML+Part+2+Screen+Scraping"]}},"previous_url":"http:\/\/devhawk.net\/2008\/11\/26\/ironpython-and-linq-to-xml-part-1-introduction\/","next_url":"http:\/\/devhawk.net\/2008\/11\/26\/early-christmas-from-iron-languages-and-dlr\/"}