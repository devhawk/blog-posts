{"status":"ok","post":{"id":1241,"type":"post","slug":"writing-an-ironpython-debugger-command-routing","url":"http:\/\/devhawk.net\/2009\/04\/01\/writing-an-ironpython-debugger-command-routing\/","status":"publish","title":"Writing an IronPython Debugger: Command Routing","title_plain":"Writing an IronPython Debugger: Command Routing","content":"<p>At this point, ipydbg support seven commands: Continue, Quit, Show Stack Trace, Show Locals, Step Over, Step In, and Step Out. All these commands are invoked by a single keystroke. I\u2019m using <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.console.readkey.aspx\">Console.ReadKey<\/a> in an attempt to cut down on the number of keystrokes needed for interacting with the debugger. If I only type \u2018s\u2019 instead of \u2018s &lt;enter&gt;\u2019 to step, I figure I\u2019ll be twice as productive! <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" class=\"grouped_elements\" rel=\"tc-fancybox-group1241\" alt=\":)\" class=\"wp-smiley\" \/> <\/p>\n<p>If I was writing ipydbg in C#, I could use switch statement to dispatch commands in the _input method based on user keystrokes. However, Python doesn\u2019t have a switch statement so I\u2019ve been using a cascading set of if\/elif\/else statements instead. When you get up to seven if\/elif clauses plus an else clause, the code smell is pretty overwhelming.<\/p>\n<pre class=\"brush: python\">\n# Only has three if\/elif clauses,but it's already a little smelly\nval = Console.ReadKey()    \nif val.Key == 'a':  \n  result = 'a'  \nelif val.Key == 'b'  \n  result = 'b'  \nelif val.Key == 'c'  \n  result = 'c'  \nelse:  \n  print \"unknown key\"\n<\/pre>\n<p>Python might not have a switch statement, but it does have first-order functions so you can get the effects of a switch by using a dictionary.<\/p>\n<pre class=\"brush: python\">\ndef do_a():     \n  return 'a'    \ndef do_b():     \n  return 'b'    \ndef do_c():     \n  return 'c'    \n_switch = {'a':do_a, 'b':do_b, 'c':do_c}     \n\nval = Console.ReadKey()     \nif val in _switch:     \n  result = _switch[val.Key]()     \nelse:     \n  print \"unknown key\"\n<\/pre>\n<p>I like this approach much better. Individual if\/elif blocks are now broken out into separate functions, which smells better than embedding them in one big function. Also, I like that my pseduo-switch statement is completely separate from the how the _switch dictionary is initialized. However, this approach also separates the pseudo-case statement functions from the _switch dictionary as well. That\u2019s not a good thing. You can easily imagine screwing up by adding a new function but forgetting to manually update the _switch dictionary. <\/p>\n<p>What I need is a way to declaratively associate the switch function with the dictionary lookup key that\u2019s associated with it. Luckily, Python Decorators provides a very clean way to do this.<\/p>\n<pre class=\"brush: python\">\n_switch = {}        \n\n@inputcmd(_switch, 'a')     \ndef do_a():      \n  return 'a'     \n@inputcmd(_switch, 'b')     \ndef do_b():      \n  return 'b'     \n@inputcmd(_switch, 'c')     \ndef do_c():      \n  return 'c'     \n\nval = Console.ReadKey()      \nif val in _switch:  \n  result = _switch[val.Key]()  \nelse:  \n  print \"unknown key\"\n<\/pre>\n<p>I\u2019ve <a href=\"http:\/\/devhawk.net\/2008\/11\/19\/IronPython+And+WPF+Part+4+Background+Processing.aspx\">blogged about decorators before<\/a> when I wanted to automatically invoke operations on the right thread in my WPF photo viewing app. The @inputcmd decorator is a bit more complicated than the @BGThread and @UIThread decorators since @inputcmd decorator accepts arguments. Each of the @input command decorators in the code above is the equivalent to this code:<\/p>\n<pre class=\"brush: python\">\ndef do_a():       \n  return 'a'\n<\/pre>\n<pre class=\"brush: python\">\n_tmp = inputcmd(_switch, 'a')     \ndo_a = _tmp(do_a)\n<\/pre>\n<\/p>\n<p>As you can see, the inputcmd function returns the decorator that wraps do_a, rather than being the decorator itself. This function that returns a function that returns a function is kinda confusing at first. But this approach allows you to configure the decorator for a specific purpose via the arguments \u2013 in this case, specifying which dictionary and which console key this function is associated with.<\/p>\n<p>Also unlike @BGThread and @UIThread, I don\u2019t actually want to modify the behavior of the methods decorated with @inputcmd. I only want to store a reference to them in the passed in dictionary. So implementing this decorator is very easy:<\/p>\n<pre class=\"brush: python\">\ndef inputcmd(cmddict, key):     \n    def deco(f):     \n        cmddict[key] = f     \n        return f  \n    return deco\n<\/pre>\n<p>The decorator simply inserts the function into the passed-in dictionary using the passed in key. It then returns the function as is, so it\u2019s not really rebinding the symbol to a new method (technically, it\u2019s rebinding the symbol to the same function it\u2019s currently bound to). If I wanted also wrap the passed in function to provide additional functionality, I could do that with a second locally defined function inside the deco function.<\/p>\n<p>The <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/tree\/9dd12dadb79469ceac57b84b8adb1b0b531337c4\">latest version of ipydbg<\/a> as been refactored to use @inputcmd instead of set of a cascading if\/elif statement blocks. Now that that\u2019s done, I can start working on multi-key commands.<\/p>\n","excerpt":"<p>At this point, ipydbg support seven commands: Continue, Quit, Show Stack Trace, Show Locals, Step Over, Step In, and Step Out. All these commands are invoked by a single keystroke. I\u2019m using Console.ReadKey in an attempt to cut down on the number of keystrokes needed for interacting with the debugger. If I only type \u2018s\u2019 [&hellip;]<\/p>\n","date":"2009-04-01 14:55:22","modified":"2009-04-01 14:55:22","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2188,"name":"Raven","url":"","date":"2009-04-02 06:00:46","content":"<p>What would be the tradeoffs if that _switch were built with lambdas instead of named functions, like this:<\/p>\n<p>_switch = {<br \/>\n  &#8216;a&#8217;: lambda: &#8216;A&#8217;<br \/>\n  &#8216;b&#8217;: lambda: &#8216;B&#8217;<br \/>\n  &#8216;c&#8217;: lambda: &#8216;C&#8217;<br \/>\n}<\/p>\n<p># I can&#8217;t get the indents right&#8230;whitespace got snipped<\/p>\n","parent":0},{"id":2189,"name":"DevHawk","url":"","date":"2009-04-02 15:15:19","content":"<p>Lambdas would work just fine, but they are limited to be expressions only. If you can do everything you need in a single expression, using a lambda would be fine. <\/p>\n","parent":0},{"id":2190,"name":"Raven","url":"","date":"2009-04-04 06:53:45","content":"<p>Oops, I forgot about the expression limitation&#8230;was having too much fun with Y combinators in Python :p<\/p>\n<p>Thanks for the answer<\/p>\n","parent":0},{"id":2191,"name":"Steve Shaw","url":"http:\/\/toolmakersteve.com","date":"2009-04-12 00:13:41","content":"<p>Seeing this use of decorators in IPy was most interesting.<\/p>\n<p>But reading this blog, I found myself thinking &#8220;I&#8217;ll stick to F#&#8221;. I realize it isn&#8217;t aimed at the same language design space, but so far I&#8217;m willing to do more up-front work to prepare the functionality I want, in exchange for language depth.<\/p>\n<p>I can see that if I took the time to learn IPy, it would be handy for interactive scripting.<\/p>\n<p>Just sharing&#8230;<\/p>\n","parent":0}],"attachments":[],"comment_count":4,"comment_status":"closed","custom_fields":{"dasblog_entryid":["456c99c2-0438-4403-ab21-ed2f937cacfb"],"dasblog_compressedtitle":["Writing+An+IronPython+Debugger+Command+Routing"],"dasblog_compressedtitleunique":["2009\/04\/01\/Writing+An+IronPython+Debugger+Command+Routing"]}},"previous_url":"http:\/\/devhawk.net\/2009\/03\/31\/devhawk-on-codecast\/","next_url":"http:\/\/devhawk.net\/2009\/04\/05\/pygments-for-windows-live-writer\/"}