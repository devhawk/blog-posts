<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Writing an IronPython Debugger: Command Routing</title>
  <link>http://devhawk.net/2009/04/01/writing-an-ironpython-debugger-command-routing/</link>
  <pubDate>Wed, 01 Apr 2009 14:55:22 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://456c99c2-0438-4403-ab21-ed2f937cacfb</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>At this point, ipydbg support seven commands: Continue, Quit, Show Stack Trace, Show Locals, Step Over, Step In, and Step Out. All these commands are invoked by a single keystroke. I’m using <a href="http://msdn.microsoft.com/en-us/library/system.console.readkey.aspx">Console.ReadKey</a> in an attempt to cut down on the number of keystrokes needed for interacting with the debugger. If I only type ‘s’ instead of ‘s &lt;enter&gt;’ to step, I figure I’ll be twice as productive! :)</p><p>If I was writing ipydbg in C#, I could use switch statement to dispatch commands in the _input method based on user keystrokes. However, Python doesn’t have a switch statement so I’ve been using a cascading set of if/elif/else statements instead. When you get up to seven if/elif clauses plus an else clause, the code smell is pretty overwhelming.</p><pre class="brush: python">
# Only has three if/elif clauses,but it's already a little smelly
val = Console.ReadKey()    
if val.Key == 'a':  
  result = 'a'  
elif val.Key == 'b'  
  result = 'b'  
elif val.Key == 'c'  
  result = 'c'  
else:  
  print "unknown key"
</pre><p>Python might not have a switch statement, but it does have first-order functions so you can get the effects of a switch by using a dictionary.</p><pre class="brush: python">
def do_a():     
  return 'a'    
def do_b():     
  return 'b'    
def do_c():     
  return 'c'    
_switch = {'a':do_a, 'b':do_b, 'c':do_c}     

val = Console.ReadKey()     
if val in _switch:     
  result = _switch[val.Key]()     
else:     
  print "unknown key"
</pre><p>I like this approach much better. Individual if/elif blocks are now broken out into separate functions, which smells better than embedding them in one big function. Also, I like that my pseduo-switch statement is completely separate from the how the _switch dictionary is initialized. However, this approach also separates the pseudo-case statement functions from the _switch dictionary as well. That’s not a good thing. You can easily imagine screwing up by adding a new function but forgetting to manually update the _switch dictionary. </p><p>What I need is a way to declaratively associate the switch function with the dictionary lookup key that’s associated with it. Luckily, Python Decorators provides a very clean way to do this.</p><pre class="brush: python">
_switch = {}        

@inputcmd(_switch, 'a')     
def do_a():      
  return 'a'     
@inputcmd(_switch, 'b')     
def do_b():      
  return 'b'     
@inputcmd(_switch, 'c')     
def do_c():      
  return 'c'     

val = Console.ReadKey()      
if val in _switch:  
  result = _switch[val.Key]()  
else:  
  print "unknown key"
</pre><p>I’ve <a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">blogged about decorators before</a> when I wanted to automatically invoke operations on the right thread in my WPF photo viewing app. The @inputcmd decorator is a bit more complicated than the @BGThread and @UIThread decorators since @inputcmd decorator accepts arguments. Each of the @input command decorators in the code above is the equivalent to this code:</p><pre class="brush: python">
def do_a():       
  return 'a'
</pre><pre class="brush: python">
_tmp = inputcmd(_switch, 'a')     
do_a = _tmp(do_a)
</pre><p></p><p></p><p>As you can see, the inputcmd function returns the decorator that wraps do_a, rather than being the decorator itself. This function that returns a function that returns a function is kinda confusing at first. But this approach allows you to configure the decorator for a specific purpose via the arguments – in this case, specifying which dictionary and which console key this function is associated with.</p><p>Also unlike @BGThread and @UIThread, I don’t actually want to modify the behavior of the methods decorated with @inputcmd. I only want to store a reference to them in the passed in dictionary. So implementing this decorator is very easy:</p><pre class="brush: python">
def inputcmd(cmddict, key):     
    def deco(f):     
        cmddict[key] = f     
        return f  
    return deco
</pre><p>The decorator simply inserts the function into the passed-in dictionary using the passed in key. It then returns the function as is, so it’s not really rebinding the symbol to a new method (technically, it’s rebinding the symbol to the same function it’s currently bound to). If I wanted also wrap the passed in function to provide additional functionality, I could do that with a second locally defined function inside the deco function.</p><p>The <a href="http://github.com/devhawk/ipydbg/tree/9dd12dadb79469ceac57b84b8adb1b0b531337c4">latest version of ipydbg</a> as been refactored to use @inputcmd instead of set of a cascading if/elif statement blocks. Now that that’s done, I can start working on multi-key commands.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1241</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-04-01 14:55:22</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-04-01 14:55:22</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">writing-an-ironpython-debugger-command-routing</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="debugger"><![CDATA[Debugger]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[456c99c2-0438-4403-ab21-ed2f937cacfb]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Writing+An+IronPython+Debugger+Command+Routing]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/04/01/Writing+An+IronPython+Debugger+Command+Routing]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2188</wp:comment_id>
    <wp:comment_author><![CDATA[Raven]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>218.94.9.35</wp:comment_author_IP>
    <wp:comment_date>2009-04-02 06:00:46</wp:comment_date>
    <wp:comment_date_gmt>2009-04-02 13:00:46</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[What would be the tradeoffs if that _switch were built with lambdas instead of named functions, like this:

_switch = {
  'a': lambda: 'A'
  'b': lambda: 'B'
  'c': lambda: 'C'
}

# I can't get the indents right...whitespace got snipped]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2189</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>131.107.0.102</wp:comment_author_IP>
    <wp:comment_date>2009-04-02 15:15:19</wp:comment_date>
    <wp:comment_date_gmt>2009-04-02 22:15:19</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Lambdas would work just fine, but they are limited to be expressions only. If you can do everything you need in a single expression, using a lambda would be fine. ]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2190</wp:comment_id>
    <wp:comment_author><![CDATA[Raven]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>121.229.145.64</wp:comment_author_IP>
    <wp:comment_date>2009-04-04 06:53:45</wp:comment_date>
    <wp:comment_date_gmt>2009-04-04 13:53:45</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Oops, I forgot about the expression limitation...was having too much fun with Y combinators in Python :p

Thanks for the answer]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2191</wp:comment_id>
    <wp:comment_author><![CDATA[Steve Shaw]]></wp:comment_author>
    <wp:comment_author_email>toolmakersteve98@shawstudio.com</wp:comment_author_email>
    <wp:comment_author_url>http://toolmakersteve.com</wp:comment_author_url>
    <wp:comment_author_IP>24.10.93.210</wp:comment_author_IP>
    <wp:comment_date>2009-04-12 00:13:41</wp:comment_date>
    <wp:comment_date_gmt>2009-04-12 07:13:41</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Seeing this use of decorators in IPy was most interesting.

But reading this blog, I found myself thinking "I'll stick to F#". I realize it isn't aimed at the same language design space, but so far I'm willing to do more up-front work to prepare the functionality I want, in exchange for language depth.

I can see that if I took the time to learn IPy, it would be handy for interactive scripting.

Just sharing...]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>