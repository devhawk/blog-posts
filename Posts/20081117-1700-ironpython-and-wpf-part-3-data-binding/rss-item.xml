<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>IronPython and WPF Part 3: Data Binding</title>
  <link>http://devhawk.net/2008/11/17/ironpython-and-wpf-part-3-data-binding/</link>
  <pubDate>Mon, 17 Nov 2008 17:00:17 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://81c4ca71-425d-4f5b-90c2-dba60eab4333</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Here’s the short version of this post: data binding in WPF to IPy objects just works...mostly. However, I’m guessing you are much more interested in the long version.</p><p>Typically, data binding depends on reflection. For example, the following snippet of XAML defines a data bound list box where the title property of each object in the bound collection gets bound to the text property of a text block control. WPF would typically find the title property of the bound objects via reflection.</p><pre class="brush: xml">
&lt;ListBox Grid.Column="0" x:Name="listbox1" &gt;
  &lt;ListBox.ItemTemplate&gt;
    &lt;DataTemplate&gt;
      &lt;TextBlock Text="{Binding Path=title}" /&gt;
    &lt;/DataTemplate&gt;
  &lt;/ListBox.ItemTemplate&gt;
&lt;/ListBox&gt;
</pre><p>The problem is that IronPython objects don’t support reflection – or more accurately, reflection won’t give you the answer you’re expecting. Every IPy object does have a static type, but it implements Python’s dynamic type model. [1] Thus, if you reflect on the IPy object looking for the title property or field, you won’t find it. It might seem we’re in a bit of a bind (pun intended). However, WPF does <a href="http://msdn.microsoft.com/en-us/library/ms743643.aspx">provide an out</a>:</p><blockquote><p>“You can bind to public properties, sub-properties, as well as indexers of any common language runtime (CLR) object. The binding engine uses CLR reflection to get the values of the properties. Alternatively, objects that implement <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.icustomtypedescriptor.aspx">ICustomTypeDescriptor</a> or have a registered <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.typedescriptionprovider.aspx">TypeDescriptionProvider</a> also work with the binding engine.”       <br />WPF <a href="http://msdn.microsoft.com/en-us/library/ms743643.aspx">Binding Sources Overview</a>, MSDN Library</p></blockquote><p style="margin-right: 0px" dir="ltr">Luckily for us, IronPython objects implement ICustomTypeDescriptor [2]. That snippet of XAML above? It’s straight from my photo viewing app. All I had to do was define the data template in the list box XAML then set the ItemsSource property of the list box instance. </p><pre class="brush: python">
w.listbox1.ItemsSource = albumsFeed.channel.item
</pre><p style="margin-right: 0px" dir="ltr">As I said, it just works. However, I did hit one small snag – hence the “mostly” caveat above. </p><p style="margin-right: 0px" dir="ltr">If you look at the <a href="http://techiewife.spaces.live.com/photos/feed.rss">top level WL Spaces photos feed</a>, you’ll see that each item’s title starts with “Photo Album:”. Yet in the <a href="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/IronPythonandWPF_EFC4/image_4.png">screenshot of my app</a>, you’ll notice that I’ve stripped that redundant text out of the title. Typically, if you want to change the bound value during the binding process, you build an <a href="http://msdn.microsoft.com/en-us/library/ms752347.aspx#data_conversion">IValueConverter</a> class. I needed two value conversions in my app, stripping “Photo Album:” for the album list box and converting a string URL into a BitmapImage for the image list box. </p><p style="margin-right: 0px" dir="ltr">IronPython objects can inherit from a .NET interface, so there’s no problem building an IValueConverter. However, in order to use a custom IValueConverter from XAML, you need to <a href="http://msdn.microsoft.com/en-us/library/ms752091.aspx">declare it in XAML as a static resource</a>. However, as you might imagine, dynamic IPy objects don’t work as static resources. So while I can define an IValueConverter in Python, I can’t create one from XAML.</p><p style="margin-right: 0px" dir="ltr">There are a few possible solutions to this. The first is to build up the data template in code. If you do that, they you can <a href="http://msdn.microsoft.com/en-us/library/ms742863.aspx">programmatically add the converter to the binding</a>. I was hopeful that I could define the data template in XAML then manipulate the binding, but there doesn’t appear to be any way to do that. Another option would be to build some type of generic IValueConverter class in C# that loads either an IPy based IValueConverter or embedded python conversion code. That’s problematic because those IPy object would need to be created in the right ScriptRuntime, and there’s no built-in way to access that. There are also a small set of XamlReader extensions such as <a href="http://msdn.microsoft.com/en-us/library/system.windows.markup.xamltypemapper.aspx">XamlTypeMapper</a> that might be able to provide the right hook into the XAML parsing to allow IronPython based conversion.</p><p style="margin-right: 0px" dir="ltr">In the end, I took the easiest way out – I transformed the data to be bound before binding it. It’s cheating of sorts, but given the read-only nature of this app, it was the easiest thing to do. So the actual line of code to set listbox1’s ItemsSource looks like this:</p><pre class="brush: python">
class Album(object):     
  def __init__(self, item):     
    self.title = item.title.Substring(13)     
    self.itemRSS = item.itemRSS     
     
w.listbox1.ItemsSource = [Album(item) for item in albumsFeed.channel.item]
</pre><p style="margin-right: 0px" dir="ltr">I create a Python class for each RSS item in the feed, saving the stripped title and the album RSS URL as fields. It’s kinda annoying to basically be parsing the feed twice, but at least it’s not much code. Python’s list comprehension syntax makes creating a list of Albums from a list of RSS items a single line of code. I do something very similar for data binding the second list box:</p><pre class="brush: python">
class Picture(object):     
  def __init__(self, item):     
    self.title = item.title  
    self.picture = BitmapImage(Uri(item.enclosure.url + ":thumbnail"))     

w.listbox2.ItemsSource = [Picture(item) for item in albumfeed.channel.item]
</pre><p style="margin-right: 0px" dir="ltr">Here I’m not only converting the raw data (adding “:thumbnail” at the end of the URL) but also changing the data type from string to BitmapImage. I’m binding to an image object in the second list box, but to do that I need a BitmapImage instead of a string.</p><p style="margin-right: 0px" dir="ltr">This “convert the data first” approach feels like a hack to me. After I get this series of posts done, I am planning on going back and improving this sample. Hopefully, I can find a better approach to value conversions. Any gurus out there on XAML parsing, please feel free to drop me a line or leave me a comment. </p><p style="margin-right: 0px" dir="ltr"></p><hr /><p></p><p>[1] you can access the underlying CLR type for any Python type via the clr.GetClrType method. You an also check out the CreateNewType method from <a href="http://www.codeplex.com/IronPython/SourceControl/FileView.aspx?itemId=649510&amp;changeSetId=43433">NewTypeMaker.cs</a></p><p>[2] I spent the better part of an afternoon trying to make TypeDescriptionProviders work before Dino pointed out that we already support ICustomTypeDescriptor in Python objects. I didn’t realize at first because I had a case sensitivity bug in my original prototype code - it turns out that “Title” != “title”. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1190</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2008-11-17 17:00:17</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2008-11-17 17:00:17</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">ironpython-and-wpf-part-3-data-binding</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="wpf"><![CDATA[WPF]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[81c4ca71-425d-4f5b-90c2-dba60eab4333]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[IronPython+And+WPF+Part+3+Data+Binding]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2008/11/18/IronPython+And+WPF+Part+3+Data+Binding]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2144</wp:comment_id>
    <wp:comment_author><![CDATA[Apolon Ivankovic]]></wp:comment_author>
    <wp:comment_author_email>apolon@torqsoftware.com</wp:comment_author_email>
    <wp:comment_author_url>http://torqsoftware.com</wp:comment_author_url>
    <wp:comment_author_IP>203.59.254.217</wp:comment_author_IP>
    <wp:comment_date>2008-11-18 01:14:31</wp:comment_date>
    <wp:comment_date_gmt>2008-11-18 09:14:31</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[From my understanding, Silverlight uses solely Reflection based binding with no support for ICustomTypeDescriptor or anything similar. Given this, then the conclusion is that there's no decent data binding story for the DLR languages in Silverlight. Is this correct? 

It seems like a shame. Is there any way to alter the IronPython/DLR behaviour so that it does generate IL defined properties/methods for some scenarios? i.e. even at the cost of dynamism for those scenarios.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>