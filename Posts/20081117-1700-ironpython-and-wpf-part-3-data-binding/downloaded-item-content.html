<p>Here&#8217;s the short version of this post: data binding in WPF to IPy objects just works&#8230;mostly. However, I&#8217;m guessing you are much more interested in the long version.</p>
<p>Typically, data binding depends on reflection. For example, the following snippet of XAML defines a data bound list box where the title property of each object in the bound collection gets bound to the text property of a text block control. WPF would typically find the title property of the bound objects via reflection.</p>
<pre class="brush: xml">&lt;ListBox Grid.Column=&quot;0&quot; x:Name=&quot;listbox1&quot; &gt;
  &lt;ListBox.ItemTemplate&gt;
    &lt;DataTemplate&gt;
      &lt;TextBlock Text=&quot;{Binding Path=title}&quot; /&gt;
    &lt;/DataTemplate&gt;
  &lt;/ListBox.ItemTemplate&gt;
&lt;/ListBox&gt;
</pre>
<p>The problem is that IronPython objects don&#8217;t support reflection &#8211; or more accurately, reflection won&#8217;t give you the answer you&#8217;re expecting. Every IPy object does have a static type, but it implements Python&#8217;s dynamic type model. [1] Thus, if you reflect on the IPy object looking for the title property or field, you won&#8217;t find it. It might seem we&#8217;re in a bit of a bind (pun intended). However, WPF does <a href="http://msdn.microsoft.com/en-us/library/ms743643.aspx">provide an out</a>:</p>
<blockquote><p>&#8220;You can bind to public properties, sub-properties, as well as indexers of any common language runtime (CLR) object. The binding engine uses CLR reflection to get the values of the properties. Alternatively, objects that implement <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.icustomtypedescriptor.aspx">ICustomTypeDescriptor</a> or have a registered <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.typedescriptionprovider.aspx">TypeDescriptionProvider</a> also work with the binding engine.&#8221;       <br>WPF <a href="http://msdn.microsoft.com/en-us/library/ms743643.aspx">Binding Sources Overview</a>, MSDN Library</p>
</blockquote>
<p style="margin-right: 0px" dir="ltr">Luckily for us, IronPython objects implement ICustomTypeDescriptor [2]. That snippet of XAML above? It&#8217;s straight from my photo viewing app. All I had to do was define the data template in the list box XAML then set the ItemsSource property of the list box instance. </p>
<pre class="brush: python">w.listbox1.ItemsSource = albumsFeed.channel.item
</pre>
<p style="margin-right: 0px" dir="ltr">As I said, it just works. However, I did hit one small snag &#8211; hence the &#8220;mostly&#8221; caveat above. </p>
<p style="margin-right: 0px" dir="ltr">If you look at the <a href="http://techiewife.spaces.live.com/photos/feed.rss">top level WL Spaces photos feed</a>, you&#8217;ll see that each item&#8217;s title starts with &#8220;Photo Album:&#8221;. Yet in the <a class="grouped_elements" href="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/IronPythonandWPF_EFC4/image_4.png" rel="tc-fancybox-group1190">screenshot of my app</a>, you&#8217;ll notice that I&#8217;ve stripped that redundant text out of the title. Typically, if you want to change the bound value during the binding process, you build an <a href="http://msdn.microsoft.com/en-us/library/ms752347.aspx#data_conversion">IValueConverter</a> class. I needed two value conversions in my app, stripping &#8220;Photo Album:&#8221; for the album list box and converting a string URL into a BitmapImage for the image list box. </p>
<p style="margin-right: 0px" dir="ltr">IronPython objects can inherit from a .NET interface, so there&#8217;s no problem building an IValueConverter. However, in order to use a custom IValueConverter from XAML, you need to <a href="http://msdn.microsoft.com/en-us/library/ms752091.aspx">declare it in XAML as a static resource</a>. However, as you might imagine, dynamic IPy objects don&#8217;t work as static resources. So while I can define an IValueConverter in Python, I can&#8217;t create one from XAML.</p>
<p style="margin-right: 0px" dir="ltr">There are a few possible solutions to this. The first is to build up the data template in code. If you do that, they you can <a href="http://msdn.microsoft.com/en-us/library/ms742863.aspx">programmatically add the converter to the binding</a>. I was hopeful that I could define the data template in XAML then manipulate the binding, but there doesn&#8217;t appear to be any way to do that. Another option would be to build some type of generic IValueConverter class in C# that loads either an IPy based IValueConverter or embedded python conversion code. That&#8217;s problematic because those IPy object would need to be created in the right ScriptRuntime, and there&#8217;s no built-in way to access that. There are also a small set of XamlReader extensions such as <a href="http://msdn.microsoft.com/en-us/library/system.windows.markup.xamltypemapper.aspx">XamlTypeMapper</a> that might be able to provide the right hook into the XAML parsing to allow IronPython based conversion.</p>
<p style="margin-right: 0px" dir="ltr">In the end, I took the easiest way out &#8211; I transformed the data to be bound before binding it. It&#8217;s cheating of sorts, but given the read-only nature of this app, it was the easiest thing to do. So the actual line of code to set listbox1&#8217;s ItemsSource looks like this:</p>
<pre class="brush: python">class Album(object):     
  def __init__(self, item):     
    self.title = item.title.Substring(13)     
    self.itemRSS = item.itemRSS     
     
w.listbox1.ItemsSource = [Album(item) for item in albumsFeed.channel.item]
</pre>
<p style="margin-right: 0px" dir="ltr">I create a Python class for each RSS item in the feed, saving the stripped title and the album RSS URL as fields. It&#8217;s kinda annoying to basically be parsing the feed twice, but at least it&#8217;s not much code. Python&#8217;s list comprehension syntax makes creating a list of Albums from a list of RSS items a single line of code. I do something very similar for data binding the second list box:</p>
<pre class="brush: python">class Picture(object):     
  def __init__(self, item):     
    self.title = item.title  
    self.picture = BitmapImage(Uri(item.enclosure.url + &quot;:thumbnail&quot;))     

w.listbox2.ItemsSource = [Picture(item) for item in albumfeed.channel.item]
</pre>
<p style="margin-right: 0px" dir="ltr">Here I&#8217;m not only converting the raw data (adding &#8220;:thumbnail&#8221; at the end of the URL) but also changing the data type from string to BitmapImage. I&#8217;m binding to an image object in the second list box, but to do that I need a BitmapImage instead of a string.</p>
<p style="margin-right: 0px" dir="ltr">This &#8220;convert the data first&#8221; approach feels like a hack to me. After I get this series of posts done, I am planning on going back and improving this sample. Hopefully, I can find a better approach to value conversions. Any gurus out there on XAML parsing, please feel free to drop me a line or leave me a comment. </p>
<p style="margin-right: 0px" dir="ltr">
</p>
<hr>
<p>[1] you can access the underlying CLR type for any Python type via the clr.GetClrType method. You an also check out the CreateNewType method from <a href="http://www.codeplex.com/IronPython/SourceControl/FileView.aspx?itemId=649510&changeSetId=43433">NewTypeMaker.cs</a></p>
<p>[2] I spent the better part of an afternoon trying to make TypeDescriptionProviders work before Dino pointed out that we already support ICustomTypeDescriptor in Python objects. I didn&#8217;t realize at first because I had a case sensitivity bug in my original prototype code &#8211; it turns out that &#8220;Title&#8221; != &#8220;title&#8221;. </p>
