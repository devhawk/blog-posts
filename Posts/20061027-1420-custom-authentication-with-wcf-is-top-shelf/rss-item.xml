<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Custom Authentication with WCF is Top Shelf</title>
  <link>http://devhawk.net/2006/10/27/custom-authentication-with-wcf-is-top-shelf/</link>
  <pubDate>Fri, 27 Oct 2006 14:20:30 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://a0566855-4b27-46cb-b90b-99155d7a5d35</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>I've spent the last three days heads down in WCF security and color me massively impressed. I just checked in a prototype that provides customized authentication for a business service. The idea that you could bang up a custom authentication service fairly easily blows my mind.</p><p>The cornerstone to this support in WCF is the standard <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.servicemodel.wsfederationhttpbinding.aspx">WSFederationHttpBinding</a>. While the binding name implies support for <a href="http://msdn.microsoft.com/library/en-us/dnglobspec/html/ws-federation.asp">WS-Federation</a> which in turn implies the use of infrastructure like <a href="http://www.microsoft.com/WindowsServer2003/R2/Identity_Management/ADFSwhitepaper.mspx">Active Directory Federation Services</a>, the binding also scales down to support simple federation scenarios with a single Security Token Service (aka STS) as defined by <a href="http://msdn.microsoft.com/library/en-us/dnglobspec/html/WS-trust.pdf">WS-Trust</a>. WS-Trust appears similar to <a href="http://web.mit.edu/kerberos/">Kerberos</a>. If you want to access a service using the federation binding, you first obtain a security token from the associated STS. Tokens contain <a href="http://en.wikipedia.org/wiki/SAML">SAML</a> assertions, which can be standard - such as Name and Windows SID - or entirely custom, which opens up very interesting and flexible security scenarios. 
</p><p>If you want to support multiple authentication systems (windows, certificates, <a href="http://cardspace.netfx3.com/">CardSpace</a>, <strike>Passport</strike><a href="http://dev.live.com/liveid/">Windows Live ID</a>, etc), STS is perfect because you can centralize the multiple authentication schemes at the STS, which then hands out a standard token the business service understands. Adding a new auth scheme can happen centrally at the STS rather than in each and every service. Support for multiple authentication schemes was the focus of our current prototype and it worked extremely well. 
</p><p>WCF includes a <a href="http://windowssdk.msdn.microsoft.com/en-us/library/aa355045.aspx">federation sample</a> which is where you should start if you're interested in this stuff. That scenario includes a chain of two STS's. Accessing the secure bookstore service requires authenticating against the bookstore STS which in turn requires authenticating against a generic "HomeRealm" STS. Since there are two STS's, they factored the common STS code into a shared assembly. You can use that common code to build an STS of your own. 
</p><p>For our prototype, we made only minor changes to the common STS code from the sample. In fact, the only significant change we made was to support programmatic selection of the proof key encryption token. In the sample, both the issuer token and the proof key encryption token are hard coded (passed into the base class constructor). The issuer token is used to sign the custom security token so the target service knows it came from the STS. The encryption token is used to - you guessed it - encrypt the token so it can only be used by the target service. Hard-coding the encryption token means you can only use your STS with a single target service. We changed that so the encryption token can be chosen based on the incoming service token request. 
</p><p>Of course, it wasn't all puppy dogs and ice cream. While I like the config system of WCF, anyone who calls it "easy" is full of it. I've spend most of the last three days looking at config files. Funny thing about config files is that they're hard to debug. So most of my effort over the last few days has been in a cycle of run app / app throws exception / tweak config / repeat. Ugh. 
</p><p>Also, while the federation sample is comprehensive, I wonder why this functionality isn't in the based WCF platform. For example, the sample includes implementations of RequestSecurityToken and RequestSecurityTokenResponse, the input and output messages of the STS. But I realized that WCF has to have its own implementations of RST and RSTR as well, since it has to send the RST to the STS and process the RSTR it gets in response. A little <a href="http://www.aisto.com/roeder/dotnet/">spelunking</a> revealed the presence of an official WCF implementation of RST and RSTR, both marked internal. I normally fall on the pragmatic side of the <a href="http://www.hanselman.com/blog/IsThereAGoodReasonToMarkAClassPublic.aspx">internal/public debate</a>, but this one makes little sense to me. 
</p><p>Otherwise, the prototype went smooth as silk and my project teammates were very impressed at how quickly this came together. Several of the project teams we're working with have identified multiple authentication as the "killer" capability they're looking to us to provide, so it's good to know we're making progress in the right direction. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">823</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2006-10-27 14:20:30</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2006-10-27 14:20:30</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">custom-authentication-with-wcf-is-top-shelf</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="security"><![CDATA[Security]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <category domain="post_tag" nicename="wcf"><![CDATA[WCF]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[a0566855-4b27-46cb-b90b-99155d7a5d35]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2006/10/27/Custom+Authentication+With+WCF+Is+Top+Shelf]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Custom+Authentication+With+WCF+Is+Top+Shelf]]></wp:meta_value>
  </wp:postmeta>
</item>