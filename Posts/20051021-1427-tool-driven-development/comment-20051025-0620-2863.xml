<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>2863</wp:comment_id>
  <wp:comment_author><![CDATA[Jay Godse]]></wp:comment_author>
  <wp:comment_author_email>jgodse@gmail.com</wp:comment_author_email>
  <wp:comment_author_url></wp:comment_author_url>
  <wp:comment_author_IP>47.248.0.43</wp:comment_author_IP>
  <wp:comment_date>2005-10-25 06:20:13</wp:comment_date>
  <wp:comment_date_gmt>2005-10-25 13:20:13</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[Although I would like to see a DSL for my domain, I don't think that tool-driven development is a natural extension of test-driven development. 

In test-driven development, the goal is to define some functionality, define the tests, then build and test. Both the code and the unit tests are directly related to the specific release of a specific system. 

In tool-driven development, the goal is essentially to codify domain expertise in some form of DSL and/or a tool to execute the transformations from model to code. This tool delivery is only indirectly related to the delivery of a specific product and specific release, and often imposes a cost that is cannot be borne by the budget of a specific release. 

The tools are best left to a "functional" group of people who are responsible for developing, evolving, and sustaining the product or subsystem over multiple releases. They will build the domain expertise over time, and they are most likely to get extra money in their budget to develop a tool because it helps them meet their objectives of codifying domain expertise for current and future work. 

Jay Godse


]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>