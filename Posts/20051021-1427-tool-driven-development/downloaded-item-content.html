<p align="left">I&#8217;ve gotten some great feedback on my <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a> post. But before I get to those comments, I wanted to talk a little bit about the role of tools. Tools are important in every industry, but in no industry are they as important or central as they are to information technology.</p>
<p align="left">One of the fascinating differences between IT architecture and &#8220;real world&#8221; architecture is the feasibly of automated transformation. If I have a blueprint of a house, there is no tool to automatically transform it into a house &#8211; someone has to do the actual work of putting up the walls, running the plumbing, etc. But in IT architecture, I can transform blueprints &#8211; i.e. the code &#8211; into the finished application automatically. That speaks volumes about the importance of tools in information technology.</p>
<p align="left">Without the tools to automate the transformation, all IT models &#8211; code or otherwise &#8211; are nothing more than documentation. </p>
<p align="left">So if we are to include models as part of our development process, we need tools to execute the transformations between levels of abstraction. But where do those tools come from? In the case of abstractions with widespread horizontal appeal, they are likely to come from language vendors such as Microsoft. For example, abstractions like <a href="http://msdn2.microsoft.com/en-us/library/512aeb7t">generics</a> and <a href="http://msdn.microsoft.com/netframework/future/linq">query expressions</a> are useful in almost nearly every project, so it makes sense to include them in mainstream languages like C#. However, one of the key points of <a href="http://lab.msdn.microsoft.com/teamsystem/workshop/sf">Software Factories</a> is that in order to continue raising the level of abstraction, we are going to need narrow the domain to which those abstractions apply.</p>
<blockquote><p align="left">Developing language-based tools is currently quite expensive, and therefore makes economic sense only in broad horizontal domains, such as user interface construction and data access, where the necessary investments can be amortized over a large customer base. For this reason, commercial implementations of the <a href="http://st-www.cs.uiuc.edu/users/droberts/evolve.html">Language Framework pattern</a> are supplied almost exclusively by platform vendors.</p>
<p align="left">This economic model is threatened by the trade off between scope and value for abstractions. As <a href="http://www.aw-bc.com/catalog/academic/product/0,1144,020159627X,00.html">Jackson puts it</a>, the value of an abstraction increases with its specificity to the problem domain. The higher the level of an abstraction, the narrower the domain to which it applies, but the more value it provides in solving problems in that domain.</p>
<p align="left">We are now at a point in the evolution of the software industry where frameworks and tools must become more vertically focused, in order to realize further productivity gains. They must provide more value for smaller classes of problems. This breaks the current economic model because markets for vertically focused frameworks and tools are too small to support platform plays, and because the domain knowledge required to develop them is housed mainly in end user organizations that have not traditionally been software suppliers.<br>[<a href="http://msdn.microsoft.com/library/en-us/dnbda/html/softwarefactwo.asp">Problems and Innovations</a> by <a href="http://blogs.msdn.com/jackgr">Jack Greenfield</a>]</p>
</blockquote>
<p align="left">In other words, these domain focused languages, frameworks and tools are <i>not</i> going to come from traditional language vendors like Microsoft. They are going to come from organizations that have deep experience in the given domain, many of whom will not be traditional software vendors. I think SIs and ISVs will adopt this approach before many end user organizations do, but eventually any organization that invests in building reusable frameworks is going to want to invest in building languages and tools to automate the usage of those frameworks.</p>
<p align="left">I think the best way to start developing these tools is to incorporate their construction directly into the software development lifecycle. I liken this to Test Driven Development. If you use a TDD approach, at the end of your project you end up with two outputs &#8211; the project and the unit tests. Assuming the code you&#8217;re building now (with their associated unit tests) is designed to meet current requirements, you shouldn&#8217;t need to refactor it significantly until those requirements change sometime in the future. The tests you build today become a tool to help you improve your code in the future when the requirements change. From a tool development perspective, Test Driven Development is a specific instance of the more generic concept of Tool Driven Development, as tests are a specific type of tool. </p>
<p align="left">What if, instead of building code test first, you thought about building tools first?</p>
<p align="left">The problem with tests is that hey are tightly bound to the current project. They may help you improve this project&#8217;s code in the future, but they won&#8217;t help you develop other applications.&nbsp;I think we should also focus on building tools that make it easier to build the existing project. The goal would be to be able to use these tools not only on future iterations of the current project, but on other similar projects as well.&nbsp; </p>
<p align="left">Of course, we don&#8217;t really have the infrastructure to do this effectively today. We need to be able to make it easier to build tools, compose tools and evolve tools over time. Supporting evolution will be key since these tools will likely need to be refined as they are applied to different projects. Test Driven Development has xUnit style frameworks, Tool Driven Development needs the equivalent. The <a href="http://lab.msdn.microsoft.com/teamsystem/workshop/dsltools/default.aspx">DSL Tools</a> and <a href="http://lab.msdn.microsoft.com/teamsystem/workshop/gat/default.aspx">Guidance Automation Toolkit</a> are a good start, but aren&#8217;t enough to enable Tool Driven Development on their own. </p>
<p align="left">Do you believe this Tool Driven approach can work? What do you think Tool Driven Development tools would look like? Please <a href="http://devhawk.net/CommentView,guid,52d0c3b9-65e3-43dd-af6d-54aca306e61f.aspx">let me know</a>.</p>
