<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>IronPython and CodeDOM: Dynamically Compiling C# Files</title>
  <link>http://devhawk.net/2009/01/29/ironpython-and-codedom-dynamically-compiling-c-files/</link>
  <pubDate>Thu, 29 Jan 2009 16:53:30 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://34f7ae3f-7d89-46d9-832a-981283b8df2f</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[As part of my series on <a href="http://devhawk.net/2008/11/13/IronPython+And+WPF+Part+1+Introduction.aspx">using IronPython with WPF</a> [1], I built an extension method in C# that does <a href="http://devhawk.net/2008/11/14/IronPython+And+WPF+Part+2+Loading+XAML.aspx">dynamic member resolution on WPF FrameworkElements</a>. The upshot of this code is that I can write “win1.listbox1” instead of “win1.FindName(‘listbox1’)” when using WPF objects from Python or any DLR language. Convenient, right?

The problem with this approach is that the C# extension method gets compiled into an assembly that’s bound to a specific version of the DLR. I recently started experimenting with a <a href="http://nightlybuilds.cloudapp.net/Project.aspx?project=ironpython">more recent build</a> of IronPython and I couldn’t load the extension method assembly due to a conflict between the different versions of Microsoft.Scripting.dll. Of course, I could have simply re-compiled the assembly against the new bits, but that would mean every time I moved to a new version of IronPython, I’d have to recompile. Worse, it would limit my ability to run multiple versions of IronPython on my machine at once. I currently have three – count ‘em, *three* – copies of IronPython installed: <a href="http://www.codeplex.com/IronPython/Release/ProjectReleases.aspx?ReleaseId=8365">2.0 RTM</a>, <a href="http://nbs.blob.core.windows.net/ironpython/IronPython.46242.release.zip">nightly build version 46242</a>, and an internal version <a href="http://devhawk.net/2008/09/17/DLR+Namespace+Change+Fire+Drill.aspx">without the mangled namespaces</a> of our public CodePlex releases. Having to manage multiple copies of my extension assembly would get annoying very quickly.

Instead of adding a reference to the compiled assembly, what if I could add a reference to a C# file directly? Kinda like how adding references to Python files works, but for statically compiled C#. That would let me write code like the following, which falls back to adding a reference to the C# file directly if adding a reference to the compiled assembly fails.
<pre class="brush: python">try:
  clr.AddReference('Microsoft.Scripting.Extension.Wpf.dll')
except:
  import codedom
  codedom.add_reference_cs_file('FrameworkElementExtension.cs',
    ['System', 'WindowsBase', 'PresentationFramework',
     'PresentationCore', 'Microsoft.Scripting'])</pre>
Since this technique uses <a href="http://msdn.microsoft.com/en-us/library/f1dfsbhc.aspx">CodeDOM</a>, I decided to encapsulate the code in a Python module named codedom, which is frankly pretty simple. As a shout-out to my pals on the <a href="http://blogs.msdn.com/vbteam/">VB team</a>, I broke compiling out into it’s own separate function so I could easily support adding VB as well as C# files.
<pre class="brush: python">def compile(prov, file, references):
  cp = CompilerParameters()
  cp.GenerateInMemory = True
  for ref in references:
    a = Assembly.LoadWithPartialName(ref)
    cp.ReferencedAssemblies.Add(a.Location)
  cr = prov.CompileAssemblyFromFile(cp, file)
  if cr.Errors.Count &gt; 0:
    raise Exception(cr.Errors)
  return cr.CompiledAssembly

def add_reference_cs_file(file, references):
  clr.AddReference(compile(CSharpCodeProvider(), file, references))

def add_reference_vb_file(file, references):
  clr.AddReference(compile(VBCodeProvider(), file, references))</pre>
The compile function uses a <a href="http://msdn.microsoft.com/en-us/library/system.codedom.compiler.codedomprovider.aspx">CodeDOM provider</a>, which provides a convenient function to <a href="http://msdn.microsoft.com/en-us/library/system.codedom.compiler.codedomprovider.compileassemblyfromfile.aspx">compile an assembly from a single file</a>. The only tricky part was adding the references correctly. Of the five references in this example, the only one CodeDOM can locate automatically is System.dll. For the others, it appears that CodeDOM needs the full path to the assembly in question.

Of course, hard-coding the assembly paths in my script would be too fragile, so instead I use partial names. I load each referenced assembly via <a href="http://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadwithpartialname.aspx">Assembly.LoadWithPartialName</a> then pass it’s Location to the CodeDOM provider via the CompilerParameters object. I realize that loading an assembly just to find its location it kind of overkill but a) I couldn’t find another mechanism to locate an assemblies location given only a partial name and b) I’m going to be loading the referenced assemblies when I load the generated assembly anyway, so I figured it loading them to find their location wasn’t a big deal. Note, that typically you’re used to passing a string to clr.AddReference, but it also can accept an assembly object directly.

Of course, this approach isn’t what you would call “fast”. Loading the pre-compiled assembly is much, <em>much</em> faster than compiling the C# file on the fly. But I figure slow code is better than code that doesn’t work at all. Besides, the way the code is written, I only take the extra compile hit if the pre-compiled assembly won’t load.

I stuck my <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/codedom.py">codedom.py</a> file up on my SkyDrive. Feel free to leverage as you need.

<hr />

[1] I had to put that series on the back burner in part because the <a href="http://windowslivewire.spaces.live.com/blog/cns!2F7EB29B42641D59!26304.entry">December update to Windows Live</a> totally broke my WPF photo viewing app. I’ve got a new WPF app I’m working on, but I’m not quite ready to blog about it yet.]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1213</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-01-29 16:53:30</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-01-29 16:53:30</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">ironpython-and-codedom-dynamically-compiling-c-files</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="c-sharp"><![CDATA[C#]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[34f7ae3f-7d89-46d9-832a-981283b8df2f]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[IronPython+And+CodeDOM+Dynamically+Compiling+C+Files]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/01/30/IronPython+And+CodeDOM+Dynamically+Compiling+C+Files]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>