<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Compiling Python Packages into Assemblies</title>
  <link>http://devhawk.net/2009/08/10/compiling-python-packages-into-assemblies/</link>
  <pubDate>Mon, 10 Aug 2009 11:16:41 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://058b7415-e1e2-43e8-b6ed-6d9e67a32e1f</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p><a href="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/970048722e75_E4A5/image_5.png"><img style="border-right-width: 0px; margin: 0px 5px 0px 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" align="left" src="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/970048722e75_E4A5/image_thumb.png" width="144" height="260" /></a> In looking at my <a href="http://devhawk.net/2009/08/10/Building+A+Hybrid+C+IronPython+App+Without+Dynamic+Type.aspx">hybrid IronPython / C# Windows Live Writer plugin</a>, we’re going to start at the bottom with the Pygments package. Typically Python packages are a physical on-disk folder that contain a collection of Python files (aka modules). And during early development of Pygments for WLWriter, that’s exactly how I used it. However, when it can time for deployment, I figured it would be much easier if I packaged up the <a href="http://github.com/devhawk/pygments.wlwriter/tree/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e/pygments_package/pygments">Pygments package</a>, <a href="http://github.com/devhawk/pygments.wlwriter/blob/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e/pygments_package/devhawk_formatter.py">my custom HTML formatter</a> and the <a href="http://github.com/devhawk/pygments.wlwriter/tree/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e/pygments_package/pygments_dependencies">standard library modules that Pygments depends on</a> into a single assembly.</p><p>IronPython ships with a script named <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/57861#758946">pyc</a> for compiling Python files into .NET assemblies. However, pyc is pretty much just a wrapper around the clr module CompileModules function. I wrote my <a href="http://github.com/devhawk/pygments.wlwriter/blob/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e/pygments_package/build_pygments.py">own custom script</a> to build the Pygments assembly from the files in a the pygments and pygments_dependencies folders.</p><p></p><pre class="brush: python">
from System import IO
from System.IO.Path import Combine

def walk(folder):
  for file in IO.Directory.GetFiles(folder):
    yield file
  for folder in IO.Directory.GetDirectories(folder):
    for file in walk(folder): yield file
  
folder = IO.Path.GetDirectoryName(__file__)

pygments_files = list(walk(Combine(folder, 'pygments')))
pygments_dependencies = list(walk(Combine(folder,'pygments_dependencies')))

all_files = pygments_files + pygments_dependencies
all_files.append(IO.Path.Combine(folder, 'devhawk_formatter.py'))

import clr
clr.CompileModules(Combine(folder, "..externalpygments.dll"), *all_files)
</pre><p></p><p>Most of this code is a custom implementation of <a href="http://docs.python.org/library/os.html#os.walk">walk</a>. I have all the <a href="http://github.com/devhawk/pygments.wlwriter/tree/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e/External">IronPython and DLR dlls</a> including ipy.exe checked into my source tree, but I don’t have the standard library checked in. Other than that, the code is pretty straight forward – collect a bunch of files in a list and call CompileModules.</p><p>The problem with this approach is that IronPython isn’t doing any kind of dependency checking when we compile the assembly. If you pass just the contents of the Pygments package into CompileModules, it will emit an assembly but that assembly will still depend on some modules in the standard library. If those aren’t available, the Pygments assembly won’t load. I’d <em>love</em> to have an automatic tool to determine module dependencies, but since I didn’t have such a tool I used a brute-force, by-hand solution. I wrote a <a href="http://github.com/devhawk/pygments.wlwriter/blob/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e/External/test_compiled_pygments.py">small script</a> to exercise the Pygments assembly. If there were any missing dependencies, test_compiled_pygments would throw an exception indicating the missing module. For each missing dependency, I copied over the missing dependency, recompiled to project and tried again. Lather, rinse, repeat. Not fun, but Pygments only depended on seven standard library modules so it didn’t end up taking that long. </p><p>So having gone down this path of compiling Python files into an assembly, would I do it again? For an application with an installer like this one, yes no question. I added the Pygments assembly as a reference to my C# library and it got added to the installer automatically. That was much easier than managing all of the Pygments files and its dependencies in the installer project manually. Plus, I still would have had to manually figure out the dependencies unless I chose to include the entire standard library.</p><p>I will point out that the compiled Pygments assembly is the largest single file in my deployed solution. It clocks in at 2.25MB. That’s about twice the size of the Python files that I compiled it from. So clearly, I’m paying for the convenience of deploying a single file in space and maybe load time. [1] I’m also paying in space for a private copy of IronPython and the DLR – the two IronPython and five DLR assemblies clock in around 3.16MB. In comparison, the actual Writer plugin assembly itself is only about 25KB! But for an installed desktop app like a WLWriter plugin, 5MB of assorted infrastructure isn’t worth worrying about compared to the hassle of ensuring a shared copy of IronPython is installed. I mean, even if you don’t know IronPython exists, you can still install and use Pygments for WLWriter. Simplifying the install process is easily worth 5MB in storage space on the user’s computer in my opinion.</p><p>Next up, we’ll look at the Python half of the PygmentsCodeSource component, which calls into this compiled Pygments library. </p><hr /><p>[1] I haven’t done it, but it would be interesting to compare the load time for the single larger pygments assembly vs. loading and parsing the Python files individually. If I had to guess, I’m thinking the single assembly would load faster even though it’s bigger since there’s less overhead (only loading one big file vs. lots of small ones) and you skip the parsing step. But that’s pure guesswork on my part.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1279</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-08-10 11:16:41</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-08-10 11:16:41</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">compiling-python-packages-into-assemblies</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="dlr"><![CDATA[DLR]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="pygments"><![CDATA[Pygments]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[058b7415-e1e2-43e8-b6ed-6d9e67a32e1f]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Compiling+Python+Packages+Into+Assemblies]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/08/10/Compiling+Python+Packages+Into+Assemblies]]></wp:meta_value>
  </wp:postmeta>
</item>