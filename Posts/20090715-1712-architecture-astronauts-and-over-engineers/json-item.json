{"status":"ok","post":{"id":1273,"type":"post","slug":"architecture-astronauts-and-over-engineers","url":"http:\/\/devhawk.net\/2009\/07\/15\/architecture-astronauts-and-over-engineers\/","status":"publish","title":"Architecture Astronauts and Over Engineers","title_plain":"Architecture Astronauts and Over Engineers","content":"<p>Since it\u2019s apparently Architecture Week\u2122 [1] here at DevHawk, here\u2019s another of my favorite Dilbert cartoons of all time \u2013 relevant to the discussion at hand.<\/p>\n<p><a title=\"Dilbert.com\" href=\"http:\/\/dilbert.com\/strips\/comic\/2008-03-04\/\"><img style=\"display: block; float: none; margin-left: auto; margin-right: auto\" border=\"0\" alt=\"Dilbert.com\" src=\"http:\/\/dilbert.com\/dyn\/str_strip\/000000000\/00000000\/0000000\/000000\/00000\/1000\/800\/1890\/1890.strip.gif\" class=\"grouped_elements\" rel=\"tc-fancybox-group1273\" \/><\/a><\/p>\n<p>Two interesting <a href=\"http:\/\/devhawk.net\/CommentView,guid,94b98f0d-d884-4557-8df0-8f0dca3b72e7.aspx#commentstart\">comments<\/a> on yesterday\u2019s post:<\/p>\n<blockquote><p>Architectural thinking is a necessary (and very important) part of software development &#8211; but beyond the systems level (which is systems administration and not software architecture) I have a hard time seeing divorcing architectural thinking from the actual development as anything but a terrible thing. Although I see that your definition of architecture (at the functional level) does not match my caricature of the &#8216;architecture astronauts&#8217; which I do think can be endemic in languages that encourage additional layers of architecture. [<a href=\"http:\/\/www.voidspace.org.uk\/\">Michael Foord<\/a>]<\/p>\n<\/blockquote>\n<blockquote><p>So based on the definition of architecture I&#8217;m reading into your post, you wouldn&#8217;t consider the choice of object-oriented versus functional programming styles from an architectural perspective? I&#8217;m trying to understand what level of architecture you mean here. Like Michael, I usually think of architecture even down into the implementation patterns level (hence the architecture astronauts), but that seems to be included in what you might be calling an engineering concern. [<a href=\"http:\/\/wizardsofsmart.net\/\">Ryan Riley<\/a>]<\/p>\n<\/blockquote>\n<p>Let me be very clear. Using my definition, there is no such thing \u201carchitecture even down into the implementation patterns level\u201d. I\u2019d argue that the implementation patterns level is engineering, not architecture. From what I\u2019ve seen, the terms \u201carchitecture\u201d and \u201cengineering\u201d tend to be used interchangeably in the software industry, and frankly I think that\u2019s a mistake. I said as much in <a href=\"http:\/\/devhawk.net\/2005\/08\/31\/Architecture+At+The+Intersection.aspx\">yet another post<\/a> I wrote four years ago:<\/p>\n<blockquote><p>Architecture is the intersection between business and IT.<\/p>\n<p>If a decision doesn&#8217;t effect a business person, it&#8217;s not an architecture decision. I&#8217;m not saying it&#8217;s not important &#8211; I think the role of the software engineer is critical in large-scale enterprise system design and construction. And I will readily admit that often a single person is responsible for both architecture and engineering. But that doesn&#8217;t make them the same activity. As long as we continue to confuse the two disciplines, we hold them both back.<\/p>\n<\/blockquote>\n<p>Michael and Ryan (or anyone else for that matter) are welcome to disagree with my definition of architecture. I often joke that if you asked ten architects to define \u201carchitecture\u201d, you\u2019d get twelve answers. But that\u2019s my definition and I\u2019m sticking to it. <\/p>\n<p>But what of the Architecture Astronauts? Both Michael and Ryan mentioned them. Unsurprisingly, I think that term is used too broadly as well. If you go back and read Joel\u2019s <a href=\"http:\/\/www.joelonsoftware.com\/articles\/fog0000000018.html\">original post<\/a> of Architecture Astronauts, there wasn\u2019t much reference, if any, to the implementation layer at all. <\/p>\n<blockquote><p>The Architecture Astronauts will say things like: &#8220;Can you imagine a program like<i><\/i>Napster where you can download <i>anything,<\/i> not just songs?&#8221; Then they&#8217;ll build applications like Groove that they think are <i>more<\/i> general than Napster, but which seem to have neglected that wee little feature that lets you type the name of a song and then listen to it &#8212; the feature we wanted in the first place. Talk about missing the point. If Napster <i>wasn&#8217;t<\/i> peer-to-peer but it <i>did<\/i> let you type the name of a song and then listen to it, it would have been just as popular<\/p>\n<\/p>\n<p>[Joel on Software, <a href=\"http:\/\/www.joelonsoftware.com\/articles\/fog0000000018.html\">Don&#8217;t Let Architecture Astronauts Scare You<\/a>]<\/p>\n<\/blockquote>\n<p>I feel that my definition fits very well with the way Joel writes about architecture in this paragraph. The Architect Astronaut is trying to solve a real business problem &#8211; people need access to information besides music. But the mistake they make is thinking they can solve multiple problems with a single solution. So they abstract higher and higher until they\u2019ve lost sight of the original problem and can only focus on the abstractions. If you look at what Joel has to say about technologies like Hailstorm and Jini, you see the same pattern emerge. <\/p>\n<p>This isn\u2019t to say that similar problems of over-abstraction don\u2019t happen at the implementation layer \u2013 they do. But they happen for very different reasons. Astronaut Architects are trying to solve multiple problems with a single solution. But when over-abstraction happens at the implementation level, it because someone thought they could predict the future.<\/p>\n<p>We\u2019ve all seen our fair share of over-engineered systems that introduce significant unneeded complexity on the off chance that the development team can successfully predict the kind of change likely to come in the next version of the product. Invariably, the team\u2019s precognitive abilities are revealed to be as poor as everyone else&#8217;s, so they\u2019re left with a bunch of extra layers of software cruft that has to be maintained but provides zero additional value to the system. I\u2019ve blogged about that problem before as well: <a href=\"http:\/\/devhawk.net\/2008\/03\/05\/Kitchen+Sink+Variability.aspx\">Kitchen Sink Variability<\/a>.<\/p>\n<p>Since I\u2019m big on keeping the terminology of architecture and engineering separate, then I\u2019d argue that we need a different term than Architecture Astronaut for people who want to introduce additional layers of abstraction at the implementation layer on the off chance that they don\u2019t suck at precognition. Since we call such systems over-engineered, wouldn\u2019t that make the people who build them \u201cOver Engineers\u201d?<\/p>\n<\/p>\n<hr \/>\n<p>[1] It\u2019s like <a href=\"http:\/\/en.wikipedia.org\/wiki\/Shark_Week\">Shark Week<\/a>, but with white boards and even more terrifying.<\/p>\n","excerpt":"<p>Since it\u2019s apparently Architecture Week\u2122 [1] here at DevHawk, here\u2019s another of my favorite Dilbert cartoons of all time \u2013 relevant to the discussion at hand. Two interesting comments on yesterday\u2019s post: Architectural thinking is a necessary (and very important) part of software development &#8211; but beyond the systems level (which is systems administration and [&hellip;]<\/p>\n","date":"2009-07-15 17:12:32","modified":"2009-07-15 17:12:32","categories":[{"id":177,"slug":"architecture","title":"Architecture","description":"","parent":0,"post_count":296}],"tags":[],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2238,"name":"Michael Foord","url":"http:\/\/www.ironpythoninaction.com\/","date":"2009-07-17 03:28:09","content":"<p>I agree that over-engineered is definitely the correct term for software that has too many layers of abstraction (interfaces for everything &#8211; yay! internal, private, protected, public &#8211; yay! never use fields but always properties &#8211; yay! dependency injection or you can&#8217;t test &#8211; yay!).<\/p>\n<p>However, when developers work on the structure of an application it is hard not to call it &#8216;architecture&#8217;, and the analogy is appropriate. (Architects *do* specify the details, often down to specific materials, of buildings they design.) It seems inevitable that these two meanings of the word will be conflated.<\/p>\n<p>Nice discussion by the way,<\/p>\n","parent":0},{"id":2239,"name":"Eric Smith","url":"http:\/\/thelimberlambda.com\/","date":"2009-07-17 06:44:28","content":"<p>I&#8217;m a little concerned with the intimation that use of interfaces, respect for visibility of type members and use of dependency injection equates to &#8220;over-engineering&#8221;.  As with everything, it depends on what you&#8217;re trying to achieve, and generalisations in this regard, especially when junior people who may not understand what&#8217;s at stake are reading, can be damaging.<\/p>\n<p>I find it an uphill battle to engender a constructive mindset in developers who have established bad habits and whose pride lies in the way of addressing those habits.<\/p>\n<p>Anti-&#8221;process&#8221; talk by Joel Spolsky and the &#8220;pragmatism brigade&#8221; makes it harder.  A while ago I had a new developer refuse to write unit tests despite it being an established practice in our team because &#8220;&#8230; Jeff and Joel said they were bad in the StackOverflow podcast &#8230;&#8221;.  Yikes.<\/p>\n","parent":0},{"id":2240,"name":"DevHawk","url":"","date":"2009-07-17 07:24:34","content":"<p>@Michael, as I&#8217;ve said above &#8220;I will readily admit that often a single person is responsible for both architecture and engineering. But that doesn&#8217;t make them the same activity.&#8221;<\/p>\n<p>@Eric, I never intimated that &#8220;that use of interfaces, respect for visibility of type members and use of dependency injection&#8221; == over-engineering. There are good reasons to use those techniques that has exactly zero to do with thinking you can predict the future. There&#8217;s good engineering and then there&#8217;s over engineering. I guess that&#8217;s will be the subject of my next Architecture post!<\/p>\n","parent":0},{"id":2241,"name":"Eric Smith","url":"http:\/\/thelimberlambda.com\/","date":"2009-07-17 08:42:59","content":"<p>@DevHawk &#8211; I was making a reference to the first paragraph of @Michael&#8217;s response&#8211;I guess I should have indicated as much.  I do agree with the whole over-engineering argument&#8211;looking forward to your explanation of where &#8220;good&#8221; crosses over into &#8220;over&#8221;.<\/p>\n","parent":0}],"attachments":[],"comment_count":4,"comment_status":"closed","custom_fields":{"dasblog_entryid":["9dbbe690-a32a-41c8-996b-d3f1af8ed69c"],"dasblog_compressedtitle":["Architecture+Astronauts+And+Over+Engineers"],"dasblog_compressedtitleunique":["2009\/07\/16\/Architecture+Astronauts+And+Over+Engineers"]}},"previous_url":"http:\/\/devhawk.net\/2009\/07\/14\/dynamic-languages-in-architecture\/","next_url":"http:\/\/devhawk.net\/2009\/07\/17\/the-texas-dependency-injection-massacre\/"}