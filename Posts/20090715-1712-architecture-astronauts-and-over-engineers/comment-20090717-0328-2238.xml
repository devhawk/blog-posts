<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>2238</wp:comment_id>
  <wp:comment_author><![CDATA[Michael Foord]]></wp:comment_author>
  <wp:comment_author_email>michael@voidspace.org.uk</wp:comment_author_email>
  <wp:comment_author_url>http://www.ironpythoninaction.com/</wp:comment_author_url>
  <wp:comment_author_IP>88.96.188.137</wp:comment_author_IP>
  <wp:comment_date>2009-07-17 03:28:09</wp:comment_date>
  <wp:comment_date_gmt>2009-07-17 10:28:09</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[I agree that over-engineered is definitely the correct term for software that has too many layers of abstraction (interfaces for everything - yay! internal, private, protected, public - yay! never use fields but always properties - yay! dependency injection or you can't test - yay!).

However, when developers work on the structure of an application it is hard not to call it 'architecture', and the analogy is appropriate. (Architects *do* specify the details, often down to specific materials, of buildings they design.) It seems inevitable that these two meanings of the word will be conflated.

Nice discussion by the way,

]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>