{"status":"ok","post":{"id":890,"type":"post","slug":"internal-dsls-in-powershell","url":"http:\/\/devhawk.net\/2007\/02\/20\/internal-dsls-in-powershell\/","status":"publish","title":"Internal DSLs in PowerShell","title_plain":"Internal DSLs in PowerShell","content":"<p><em>(Harry is on a secret mission in uncharted space this week, so instead of the daily Morning Coffee post, you get a series of autoposted essays. This post combines both some leftover learnings about Ruby from Harry&#8217;s Web 2.0 days with his recent obsession with PowerShell.)<\/em><\/p>\n<p>My first introduction to the idea of internal DSLs was an <a href=\"http:\/\/martinfowler.com\/articles\/rake.html\">article on Ruby Rake<\/a> by Martin Fowler. Rake is Ruby&#8217;s make\/build utility. Like most build tools like <a href=\"http:\/\/ant.apache.org\/\">Ant<\/a> and <a href=\"http:\/\/msdn2.microsoft.com\/en-us\/library\/ms171452.aspx\">MSBuild<\/a>, Rake is a dependency management system. Unlike Ant and MSBuild, Rake doesn&#8217;t use an XML based language. It uses Ruby itself, which has huge benefits when you start doing custom tasks. In Ant or MSBuild, building a custom task requires you to use a external environment (batch file, script file or custom compiled task object). In Rake, since it&#8217;s just a Ruby file, you can start writing imperative Ruby code in place.<\/p>\n<p>Here&#8217;s the simple Rake sample from Fowler&#8217;s article:<\/p>\n<pre class=\"brush:ruby\">task :codeGen do  \r\n  # do the code generation \r\nend \r\n\r\ntask :compile =&gt; :codeGen do  \r\n  # do the compilation \r\nend \r\n\r\ntask :dataLoad =&gt; :codeGen do  \r\n  # load the test data \r\nend \r\n\r\ntask :test =&gt; [:compile, :dataLoad] do  \r\n  # run the tests \r\nend<\/pre>\n<p>The task keyword takes three parameters:&nbsp;the task&nbsp;name, an array containing&nbsp;the task dependencies and a script block containing the code to execute to complete the task. Ruby&#8217;s flexible syntax allows you to specify task without any dependencies (:codegen), with a single dependency (:compile =&gt; :codegen), and with multiple dependencies (:test =&gt; [:compile,:dataLoad])<\/p>\n<p>So what would this look like if you used Powershell instead of Ruby? How about this:<\/p>\n<pre class=\"brush:powershell\">task codeGen {  \r\n  # do the code generation \r\n}\r\ntask compile codeGen { \r\n  # do the compilation \r\n}\r\n\r\ntask dataLoad codeGen {  \r\n  # load the test data \r\n}\r\n\r\ntask test compile,dataLoad { \r\n  # run the tests \r\n}<\/pre>\n<p>Not much different. PS uses brackets for script blocks while Ruby uses do \/ end, but that&#8217;s just syntax. Since it lacks Ruby&#8217;s concept of symbols (strings that start with a colon), PS has to use strings instead. Otherwise, it&#8217;s almost identical. They even both use the # symbol to represent a line comment.<\/p>\n<p>There is one significant difference. For tasks with dependencies, Rake uses a hash table to package the task name and its dependencies. The =&gt; syntax in Ruby creates a hash table. Since the hash table has only a single value, you can leave of the surrounding parenthesis. The key of this single item hash table is the task name while the value is an array of task names this task depends on. Again, Ruby&#8217;s syntax is flexible, so if you have only a single dependency, you don&#8217;t need to surround it in square brackets.<\/p>\n<p>In Powershell, the hash table syntax isn&#8217;t quite so flexible, you have to surround it with @( ). So using Rake&#8217;s syntax directly would result in something that looked like &#8220;task @(test = compile,dataLoad) {&#8230;}&#8221; which is fairly ugly. You don&#8217;t need to specify the square brackets on the array, but you having to add the @( is a non-starter, especially since you wouldn&#8217;t have them on a task with no dependencies.<\/p>\n<p>So instead, I thought a better approach would be to use PS&#8217;s variable parameter support. Since all tasks have a name, the task function is defined simply as &#8220;function task ([string] $name)&#8221;. This basically says there&#8217;s a function called task with <em>at least <\/em>one parameter called $name. (All variables in PS start with a dollar sign.) Any parameters that are passed into the function that aren&#8217;t specified in the function signature are passed into the function in the $args variable.<\/p>\n<p>This approach does mean having to write logic in the function to validate the $args parameters. Originally, I specified all the parameters, so that it looked like this: &#8220;function global:task([string] $name, [string[]] $depends, [scriptblock] $taskDef)&#8221;. That didn&#8217;t work for tasks with no dependencies, since it tried to pass the script block in as the $depends parameter.<\/p>\n<p>Here&#8217;s a sample task function that implements the task function shown above. It validates the $args input and builds a custom object that represents the task. (Note, the various PS* objects are in the System.Management.Automation namespace. I omitted the namespaces to make the code readable.)<\/p>\n<pre class=\"brush:powershell\">function task([string] $name) {\r\n  if (($args.length -gt 2) -or ([string]::isnullorempty($name))) { \r\n    throw \"task syntax: task name [&lt;dependencies&gt;] [&lt;scriptblock&gt;]\"\r\n  }               \r\n  if ($args[0] -is [scriptblock]) {         \r\n    $taskDef = $args[0]       \r\n  }       \r\n  elseif ($args[1] -is [scriptblock]) {         \r\n    $depends = [object[]]$args[0]         \r\n    $taskDef = $args[1]       \r\n  }       \r\n  else {         \r\n    $depends = [object[]]$args[0]     \r\n    #if a script block isn't passed in, use an empty one        \r\n    $taskDef = {}    \r\n  }     \r\n\r\n  $task = new-object PSObject       \r\n  $nameProp = new-object PSNoteProperty Name,$name       \r\n  $task.psobject.members.add($nameProp)                \r\n  $dependsProp = new-object PSNoteProperty Dependencies,$depends       \r\n  $task.psobject.members.add($dependsProp)                \r\n  $taskMethod = new-object PSScriptMethod ExecuteTask,$taskDef       \r\n  $task.psobject.members.add($taskMethod)                \r\n  $task     \r\n}<\/pre>\n<p>Of course, you would need much more than this if you were going to build a real build system like Rake in PowerShell. For example, you&#8217;d need code to collect the tasks, order them in the correct dependency order, execute them, etc. Furthermore, Rake supports other types of operations, like file tasks and utilities that you&#8217;d need to build.<\/p>\n<p>However, the point of this post isn&#8217;t to rebuild Rake in PS, but to show how PS rivals Ruby as a language for building internal DSLs. On that front, I think PowerShell performs beautifully.<\/p>\n<p>I&#8217;m looking forward to using PowerShell&#8217;s metaprogramming capabilities often in the future.<\/p>\n","excerpt":"<p>(Harry is on a secret mission in uncharted space this week, so instead of the daily Morning Coffee post, you get a series of autoposted essays. This post combines both some leftover learnings about Ruby from Harry&#8217;s Web 2.0 days with his recent obsession with PowerShell.) My first introduction to the idea of internal DSLs [&hellip;]<\/p>\n","date":"2007-02-20 23:08:01","modified":"2011-04-17 00:19:57","categories":[],"tags":[{"id":208,"slug":"domain-specific-languages","title":"Domain Specific Languages","description":"","post_count":15},{"id":230,"slug":"powershell","title":"PowerShell","description":"","post_count":41},{"id":190,"slug":"ruby","title":"Ruby","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["79dc7b14-2c09-4cbb-8039-99c299212664"],"dasblog_compressedtitle":["Internal+DSLs+In+PowerShell"],"dasblog_compressedtitleunique":["2007\/02\/21\/Internal+DSLs+In+PowerShell"]}},"previous_url":"http:\/\/devhawk.net\/2007\/02\/20\/morning-doughnuts-3\/","next_url":"http:\/\/devhawk.net\/2007\/02\/21\/morning-doughnuts-4\/"}