<p>Last night, after the Turing Lecture, we hosted a FlashBoF on &#8220;DSL&#8217;s in Visual Studio&#8221;. <a href="http://blogs.msdn.com/stuart_kent">Stuart</a> answered a bunch of questions and gave a much more detailed demonstration of the new DSL Toolkit than we could show during the keynote. Here&#8217;s what I learned from the session: </p>
<ul>
<p style="PADDING-LEFT: 10px; FLOAT: right"><a class="grouped_elements" href=".\UIPModel.JPG" rel="tc-fancybox-group463"><img src=".\UIPModelThumb.JPG" border="0"></a></p>
<li>Models are stored in XML files. The language designer outputs an object model and will eventually also output an XSD. For example, here&#8217;s a screenshot of the language designer from the DSL Toolkit we&#8217;re releasing. Inside the designer, I&#8217;ve got a sample UIP DSL (I hacked this up on my own, this is not exactly the same one we demoed yesterday). As you can see, there&#8217;s a PageCollection concept which contains Page concepts that have Name and Kind values. Page concepts also has a collection of Transfer concepts, which in turn have Label values. Generating an object model makes it easier to write tools that manipulate models. Typically, I&#8217;m anti-XML-Serialization but in this case &#8211; where we have a relative simple XSD &#8211; it works fine. I could also manipulate the model by accessing the underlying XML if I want to.
</li>
<li>Code generation uses templates and looks a lot like <a href="http://www.ericjsmith.net/codesmith/">CodeSmith</a> or old-school ASP. You interleave the static elements of the generated code with blocks of code that access the model (via the object model described above) and generate the dynamic model-specific elements of the code. So I&#8217;m guessing that people using the codegen tools like CodeSmith will feel right at home with this toolkit.
</li>
<li>In the current builds (which is to say later than the build that we&#8217;re releasing first &#8211; the first build doesn&#8217;t include any of the code generation support) we&#8217;re generating a single code file from a model. Eventually we&#8217;ll be able to manipulate multiple files from a single model. This is similar to how the Class Diagram works &#8211; add a new class onto the diagram and a new file gets added to the project, delete the class from the diagram and the file gets removed from the solution.
</li>
<li>Not all models are used to generate code. For example, in VSTS the Logical Data Center and Virtual Deployment models don&#8217;t generate code. They are useful&nbsp; because I can use them to validate the Distributed System Model which does generate code.
</li>
<li>Someone asked about the implications of code coverage, profiling and test-driven development on a DSL-based process. Frankly, I don&#8217;t know but it certainly got me thinking. The general consensus was that we&#8217;re still in the bootstrap phase of making DSL-based development a reality and these are issues we&#8217;ll have to deal with as we move forward.</li>
</ul>
