{"status":"ok","post":{"id":1165,"type":"post","slug":"monadic-philosophy-part-3-the-parser-monad-in-c","url":"http:\/\/devhawk.net\/2008\/07\/31\/monadic-philosophy-part-3-the-parser-monad-in-c\/","status":"publish","title":"Monadic Philosophy Part 3 &#8211; The Parser Monad in C#","title_plain":"Monadic Philosophy Part 3 &#8211; The Parser Monad in C#","content":"<p>(If you disregarded <a href=\"http:\/\/devhawk.net\/2008\/07\/30\/Pushed+The+Wrong+Button.aspx\">my advice<\/a> and read the previous version of this post, please note I rewrote this post significantly so you&#8217;ll probably want to read it again.)<\/p>\n<p>In the <a href=\"http:\/\/devhawk.net\/2008\/07\/30\/Monadic+Philosophy+Part+2+The+LINQ+Monad.aspx\">last post<\/a>, we looked at how LINQ is a monad and how IEnumerable is a pseudo-functional construct. However, C#&#8217;s intrinsic collection support &#8211; aka foreach and yield return &#8211; really obscure how you might go about building your own monad. So for this post, we&#8217;re going to take a look at a parsing monad instead. Just as LINQ broke the big problem of queries into a collection of standard query operators that were composable, we want to take the same approach for parsers. <\/p>\n<p>Note, I&#8217;m going to stick with C# for now, and get into F# monads in my next post. Quick shout out to <a href=\"http:\/\/blogs.msdn.com\/lukeh\/archive\/2007\/08\/19\/monadic-parser-combinators-using-c-3-0.aspx\">Luke Hoban<\/a> and <a href=\"http:\/\/lorgonblog.spaces.live.com\/blog\/cns!701679AD17B6D310!124.entry\">Brian McNamara<\/a>, from whom I <strike>stole<\/strike> obtained some of the code below.<\/p>\n<p>Quick refresher: I&#8217;ve described a monad as a sequence of computations with a context flow. Since C# has explicit sequencing, we want to focus on the context flow. For LINQ, the context was IEnumerable. For parsers, we could define an similar IParser interface like this:<\/p>\n<pre class=\"brush: csharp\">\nclass Tuple&lt;T1, T2&gt; \n{ \n    public readonly T1 Item1; \n    public readonly T2 Item2; \n    public Tuple(T1 val1, T2 val2) { Item1 = val1; Item2 = val2; } \n} \n\nclass Result&lt;T&gt; : Tuple&lt;T, string&gt; \n{ \n    public Result(T val, string rest) : base(val, rest) { } \n} \n\ninterface IParser&lt;T&gt; \n{ \n    Result&lt;T&gt; Parse(string input); \n}\n<\/pre>\n<p>The Parse function takes a string to be parsed as input and returns the parsing result which pairs the semantic value with with the remaining string input to be parsed. I&#8217;ve built out a simple generic tuple class because I know I&#8217;ll use it again later. I&#8217;ve <a href=\"http:\/\/devhawk.net\/2006\/08\/22\/Language+Features+I+Wish+C+Had+Tuples.aspx\">long wished<\/a> C# would support intrinsic tuples like F# does. For convenience, I&#8217;ve also created a strongly typed subclass of Tuple to represent parse results where the second item is a string, to save some typing. Since Result is a class, it can be null which means the the Parser failed to parse the input. <\/p>\n<p>The problem with this approach is that unlike IEnumerable, the C# compiler has no built-in knowledge of this interface. That means there are no easy-to-use keywords like foreach and yield return that can do our heavy lifting of consuming or creating these IParser types for us. Instead, we would have to explicitly declare classes to implement the interface. As we add more and more parsers, that additional overhead of creating types would become more and more unwieldy. Instead, let&#8217;s redefine Parser as a delegate.<\/p>\n<pre class=\"brush: csharp\">\ndelegate Result&lt;T&gt; Parser&lt;T&gt;(string input);\n<\/pre>\n<p>The benefit of this approach is that you can create Parser delegates inside functions, using C#&#8217;s anonymous delegate syntax, without the overhead of creating a type. For example, here&#8217;s a function to create a simple primitive parser that strips the first character off the parse string and returns it as the parse result:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;char&gt; Item() \n{ \n    return input =&gt; \n        { \n            return string.IsNullOrEmpty(input) \n                ? null\n                : new Result&lt;char&gt;(input[0], input.Substring(1)); \n        }; \n}\n<\/pre>\n<p>That&#8217;s a lot more convenient than building a type just to implement a single method. <\/p>\n<p>Now that we have our Parser type, we need to think about how to compose Parsers so that we can flow context between them. Much as LINQ provides a collection of primitive query operators (Select, Where, OrderBy, etc), you would expect a monadic parser library to provide a collection of primitive parsers (Item, Satisfy, AnyOf, ItemEqual, etc), that you could combine into higher-order parsers along with some language specific lower-order parsers. Here&#8217;s an example from the the <a href=\"http:\/\/pdos.csail.mit.edu\/~baford\/packrat\/popl04\/peg-popl04.pdf\">PEG grammar<\/a>:<\/p>\n<p>\u00a0\u00a0\u00a0 Primary &lt;- Identifier !LEFTARROW \/ OPEN Expression CLOSE \/ Literal \/ Class \/ DOT<\/p>\n<p>The Primary parser depends on some high-order language specific parsers (Identifier, Expression, Literal and Class) as well as some language specific low-order tokenizer style parsers (LEFTARROW, OPEN, CLOSE and DOT) and finally some language-independent primitive parsers (the failure predicate ! and the prioritized choice operator \/). <\/p>\n<p>So how should we compose these various Parsers? LINQ query operators were fairly easy to compose because they all take in and return the same type (IEnumerable) so you can simply chain them together. Parsers are a little trickier because the inputs and outputs are asymmetric &#8211; i.e. they take a string, but return a Result &#8211; so simple chaining won&#8217;t work. <\/p>\n<p>We could combine the parsers sequentially, taking the parse string returned from first parser and feed it into the second. Then we could combine the two parse values in a Tuple to return them (you see why I created a generic Tuple class?) resulting in a function that looks like this:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;Tuple&lt;T1,T2&gt;&gt; Join&lt;T1,T2&gt;(this Parser&lt;T1&gt; p1, Parser&lt;T2&gt; p2)  \n{  \n    return input =&gt;  \n        {  \n            var ret1 = p1(input);  \n            if (ret1 == null)  \n                return null;  \n\n            var ret2 = p2(ret1.Item2);  \n            if (ret2 == null)  \n                return null;  \n\n            return new Result&lt;Tuple&lt;T1,T2&gt;&gt;(  \n                new Tuple&lt;T1, T2&gt;(ret1.Item1, ret2.Item1),  \n                ret2.Item2);  \n        };  \n}\n<\/pre>\n<p>Note this is an extension method so we can call Parser1.Join(Parser2) rather than the less fluent Join(Parser1, Parser2). I was going to call this function Combine, but there&#8217;s already a static Combine method on the Delegate type that caused a conflict, so I used Join instead. <\/p>\n<p>The Join approach works, but it&#8217;s a bit unwieldy to return the parsing values in a tuple. Every set of joined parsers will result in another level of tuple nesting in the Result that&#8217;s returned. That gets pretty ugly pretty fast. For example, lets say we want to create a parser that combines two instances of Item. It looks like this:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;Tuple&lt;char, char&gt;&gt; TwoItems() \n{ \n    return Item().Plus(Item()); \n}\n<\/pre>\n<p>That&#8217;s not so bad. But now look what happens if we combine the TwoItems parser with another instance of Item:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;Tuple&lt;Tuple&lt;char, char&gt;, char&gt;&gt; ThreeItems() \n{ \n    return TwoItems().Plus(Item()); \n}\n<\/pre>\n<p>The result is a nested tuple. Yuck. We need a better way. Enter the monadic bind. The code looks like this:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;U&gt; Bind&lt;T, U&gt;(this Parser&lt;T&gt; p1, Func&lt;T, Parser&lt;U&gt;&gt; fun) \n{ \n    return input =&gt; \n        { \n            var ret1 = p1(input); \n            if (ret1 == null) \n                return null; \n\n            var p2 = fun(ret1.Item1); \n            if (p2 == null) \n                return null; \n\n            return p2(ret1.Item2); \n        }; \n}\n<\/pre>\n<p>Like the Join function above, Bind starts by calling the first parser function, returning null if the parse fails. However, instead of calling to the second parser directly, it calls to the provided function that generates the second parser. This function acts as a <a href=\"http:\/\/en.wikipedia.org\/wiki\/Closure_%28computer_science%29\">closure<\/a>, packaging up the parse value from the first parser for later processing. Finally, Bind calls to the generated second parser, feeding in the remaining text from the first parser result. <\/p>\n<p>This approach allows you to inject code that combines the parsing values however we like rather than always pairing them up in a tuple. Here&#8217;s a version of TwoItems that binds a call to Item with a custom function that calls Item again and returns the two characters as a string rather than a tuple:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;string&gt; BetterTwoItems() \n{ \n    return Item().Bind&lt;char, string&gt;( \n        val =&gt;  \n        { \n            return input =&gt; \n            { \n                var result = Item()(input); \n                return new Result&lt;string&gt;( \n                    string.Format(\"{0}{1}\", val, result.Item1), \n                    result.Item2); \n            }; \n        }); \n}\n<\/pre>\n<p>It&#8217;s kinda strange to see a lambda expression that returns a lambda expression in C#, but that&#8217;s what this code does. The first lambda expression (val =&gt;) defines the custom function, the second lambda expression (input =&gt;) defines the Parser delegate. Val is the parse value from calling Item() the first time &#8211; ret1.Item1 in the Bind function above. Input is the remainder of the parse string &#8211; ret1.Item2 from the Bind function. <\/p>\n<p>Unfortunately, while this approach avoids nested tuples for parse values, we&#8217;ve had to give up quite a bit of simplicity. The original TwoItems method was a single line of code. BetterTwoItems is significantly more complex. Furthermore, the double lambda expression syntax confuses C#&#8217;s type inference, forcing you to explicitly specify the generic types on the Bind method. Luckily there&#8217;s a better way to write this. However, let&#8217;s start by rewriting the function like this:<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;string&gt; SlightlyBetterTwoItems() \n{ \n    return Item().Bind( \n        v1 =&gt; Item().Bind&lt;char, string&gt;( \n            v2 =&gt; \n            { \n                return input =&gt; \n                { \n                    return new Result&lt;string&gt;( \n                        string.Format(\"{0}{1}\", v1, v2), \n                        input); \n                }; \n            })); \n}\n<\/pre>\n<p>SlightlyBetterTwoItems pulls the second call to Item out into a second Bind operation. The point of this refactoring is to make it clear that we can view this function as a call to Item, bound to a second call to Item, bound to custom function to return a Parser that returns the two parse value chars formatted as a string. You&#8217;ll notice that by eliminating the the double lambda expression on the first call to Bind, we were able to drop out the explicit generic type specification. <\/p>\n<p>This version is a little clearer, but we can make it clearer yet. It turns out that wrapping up a parse value in a Parser that unconditionally returns the parse value and the parse text input in a Result is a very common operation. So let&#8217;s create a primitive function Result to wrap up a parse value in a Parser delegate and build our final version of TwoItems that uses it.<\/p>\n<pre class=\"brush: csharp\">\nstatic Parser&lt;T&gt; Result&lt;T&gt;(T val)  \n{  \n    return input =&gt; new Result&lt;T&gt;(val, input);  \n}  \n\nstatic Parser&lt;string&gt; BestTwoItems() \n{ \n    return Item().Bind( \n        v1 =&gt; Item().Bind( \n        v2 =&gt; Result(string.Format(\"{0}{1}\", v1, v2)))); \n}\n<\/pre>\n<p>Now it&#8217;s very clear that we have a call to Item, bound to a second call to item, which is in turn bound to a call to Result. We&#8217;ve now dropped all use of double lambdas, which means C# can infer the types to each of our Bind calls implicitly. But more importantly, do you see <em>any<\/em> reference to Parser&lt;T&gt; delegates or input strings in this code? Only in the return type specification. Just as LINQ hides the specifics of flowing IEnumerable or enumerator objects between standard query operators, the parser monad hides the specifics of flowing Parser delegates or input strings between parse operations. <\/p>\n<p>The Parser delegate plus the Bind and Result methods are all there are to our basic parser monad. Seriously, all that worry that monad &#8220;is a bit obscure and sounds a little daunting&#8221; and it&#8217;s really just two functions and a delegate type. <\/p>\n<p>While this code is fairly straight forward, the whole nested lambdas expressions is fairly atypical syntax that some developers might have a hard time understanding. Unfortunately, if we&#8217;re writing our parsers in C#, we&#8217;re kinda stuck with this syntax. However, F# has a special syntax that lets you write what looks like normal sequential code, while still flowing the Parser context between parse operations exactly like the code above does. We&#8217;ll take a look at that syntax in the next post.<\/p>\n","excerpt":"<p>(If you disregarded my advice and read the previous version of this post, please note I rewrote this post significantly so you&#8217;ll probably want to read it again.) In the last post, we looked at how LINQ is a monad and how IEnumerable is a pseudo-functional construct. However, C#&#8217;s intrinsic collection support &#8211; aka foreach [&hellip;]<\/p>\n","date":"2008-07-31 20:47:30","modified":"2011-04-16 22:15:10","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":235,"slug":"c-sharp","title":"C#","description":"","post_count":17},{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":202,"slug":"functional-programming","title":"Functional Programming","description":"","post_count":18},{"id":267,"slug":"monads","title":"Monads","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2107,"name":"Yuri K.","url":"http:\/\/elder_george.livejournal.com","date":"2008-07-31 22:53:47","content":"<p>Well, we apparently aren&#8217;t stuck with &#8216;nested lambda syntax&#8217; in C#, since it has more nice &#8216;from-select&#8217; syntax the (ab)use of which Luke Hoban has shown in the post you referenced.<br \/>\nBut of course, F# sugar for monads is much sweeter =)<\/p>\n","parent":0},{"id":2108,"name":"DevHawk","url":"","date":"2008-08-01 12:58:11","content":"<p>Yeah, there&#8217;s not a direct match between Bind and Result as I defined them and C#&#8217;s Query comprehension syntax, so I decided to skip discussing Luke&#8217;s post (for now). But as you rightly point out, F#&#8217;s monadic syntax rocks (as we&#8217;ll see in my next post!)<\/p>\n","parent":0}],"attachments":[],"comment_count":2,"comment_status":"closed","custom_fields":{"dasblog_entryid":["f0fb5461-eb30-4268-a4b3-7262276768cb"],"dasblog_compressedtitle":["Monadic+Philosophy+Part+3+The+Parser+Monad+In+C"],"dasblog_compressedtitleunique":["2008\/08\/01\/Monadic+Philosophy+Part+3+The+Parser+Monad+In+C"]}},"previous_url":"http:\/\/devhawk.net\/2008\/07\/30\/ipy-post-2-0-roadmap-clarifications\/","next_url":"http:\/\/devhawk.net\/2008\/08\/01\/mccains-dick-move-of-the-week\/"}