<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Not Your Father's C++</title>
  <link>http://devhawk.net/2005/04/11/not-your-fathers-c/</link>
  <pubDate>Mon, 11 Apr 2005 20:54:53 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://770016d2-1ca7-48ad-8d21-4405b6bbb9e5</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[Certainly not <a href="http://halpierson.blogspot.com/">my father's</a> C++. I sat thru a presenation on VC++ 2005 today. Wow, I hadn't realized all the coolness there.

First off, all the syntax is working it's way thru the standards bodies, so no more <a href="http://msdn.com/library/en-us/vcmex/html/vclrfmxkeywords.asp">underscore underscore syntax</a>. It makes the code somewhat easier to read, but more importantly it's following a similar standardization process to CLI and C#.

Secondly, you can now use all the native C++ features (templates, multiple inheritance, buffer overrun protection, etc) and all the CLI features (garbage collection, generics, language interop) together. Previously, you had very limited choices for mixing the two coding idioms. No longer - go ahead and mix and match. This gives you the best of both worlds. Use templates, and expose them to other .NET languages as generics.

Finally, it brings deterministic finalization to .NET. In VC++ 2005, you can declare both a destructor (used when a class goes out of scope or is explicitly deleted) and a finalizer (used when the class is garbage collected). This is similar to the whole IDisposable approach for classes that wrap unmanaged resources (file handles, network sockets, etc). Actually, it's <em>identical</em> to IDisposable because that's how it's implemented! And it works both ways - if you instance a managed class that implements IDisposable "on the heap" then it will automatically call dispose at the end of scope. For example:
<pre class="brush:cpp">{  //C++ Version
   FileStream fs = FileStream(path, FileMode::Create);
   fs.Read(...);
   fs.Write(...);
}  //fs.Dispose called automatically</pre>
Even though the FileStream is implemented in C#, it behaves here like a stack type and is destructed as you would expect. In C#, you'd have to use a <a href="http://msdn.com/library/en-us/csref/html/vclrfusingstatement.asp">using statement</a> to achieve the same effect. For this trival example, it's not that big a deal. But if you have multiple stack instances created at different times within a scope, this helps out immensely.

Not sure I would move to C++ for all my managed programming, but I'll certainly be giving VC++ 2005 another look.]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">587</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2005-04-11 20:54:53</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2005-04-11 20:54:53</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">not-your-fathers-c</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="development"><![CDATA[Development]]></category>
  <category domain="post_tag" nicename="lanugages"><![CDATA[Lanugages]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[770016d2-1ca7-48ad-8d21-4405b6bbb9e5]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Not+Your+Fathers+C]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2005/04/12/Not+Your+Fathers+C]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2811</wp:comment_id>
    <wp:comment_author><![CDATA[your father]]></wp:comment_author>
    <wp:comment_author_email>halpierson@hotmail.com</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP></wp:comment_author_IP>
    <wp:comment_date>2005-04-12 06:01:19</wp:comment_date>
    <wp:comment_date_gmt>2005-04-12 13:01:19</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[So what's the syntax for a "generic template"?  And is it different from a "templated generic"?  Programmers find it hard to ignore features in a language.  I'm afraid this will lead to unreadable code.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>