{"status":"ok","post":{"id":1281,"type":"post","slug":"invoking-python-functions-from-c-without-dynamic","url":"http:\/\/devhawk.net\/2009\/08\/12\/invoking-python-functions-from-c-without-dynamic\/","status":"publish","title":"Invoking Python Functions from C# (Without Dynamic)","title_plain":"Invoking Python Functions from C# (Without Dynamic)","content":"<p><a href=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/InvokingPythonFunctionsfromCWithoutDynam_13C34\/image_2.png\" class=\"grouped_elements\" rel=\"tc-fancybox-group1281\"><img style=\"border-right-width: 0px; margin: 0px 5px 0px 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px\" title=\"image\" border=\"0\" alt=\"image\" align=\"left\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/InvokingPythonFunctionsfromCWithoutDynam_13C34\/image_thumb.png\" width=\"133\" height=\"240\" \/><\/a> So I\u2019ve <a href=\"http:\/\/devhawk.net\/2009\/08\/10\/Compiling+Python+Packages+Into+Assemblies.aspx\">compiled the Pygments package into a CLR assembly<\/a> and <a href=\"http:\/\/devhawk.net\/2009\/08\/11\/Embedding+Python+Scripts+In+C+Applications.aspx\">loaded an embedded Python script<\/a>, so now all that remains is calling into the functions in that embedded Python script. Turns out, this is the easiest step so far.<\/p>\n<p>We\u2019ll start with get_all_lexers and get_all_styles, since they\u2019re nearly identical. Both functions are called once on initialization, take zero arguments and return a PythonGenerator (for you C# devs, a PythonGenerator is kind of like the IEnumerable that gets created when you yield return from a function). In fact, the only difference between them is that get_all_styles returns a generator of simple strings, while get_all_lexers returns a PythonTuple of the long name, a tuple of aliases, a tuple of filename patterns and a tuple of mime types. Here\u2019s the implementation of Languages property:<\/p>\n<pre class=\"brush: csharp\">\nPygmentLanguage[] _lanugages;     \n\npublic PygmentLanguage[] Languages      \n{\n    get\n    {\n        if (_lanugages == null)      \n        {\n            _init_thread.Join();      \n\n            var f = _scope.GetVariable&lt;PythonFunction&gt;(\"get_all_lexers\");      \n            var r = (PythonGenerator)_engine.Operations.Invoke(f);      \n            var lanugages_list = new List&lt;PygmentLanguage&gt;();      \n            foreach (PythonTuple o in r)      \n            {\n                lanugages_list.Add(new PygmentLanguage()      \n                    {\n                        LongName = (string)o[0],      \n                        LookupName = (string)((PythonTuple)o[1])[0]      \n                    });      \n            }\n\n            _lanugages = lanugages_list.ToArray();      \n        }\n\n        return _lanugages;      \n    }\n}\n<\/pre>\n<p>If you recall from my last post, I initialized the _scope on a background thread, so I first have to wait for the thread to complete. If I was using C# 4.0, I\u2019d simply be able to run _scope.get_all_lexers, but since I\u2019m not I have to manually reach into the _scope and retrieve the get_all_lexers function via the GetVariable method. I can\u2019t invoke the PythonFunction directly from C#, instead I have to use the Invoke method that hangs off _engine.Operations. I cast the return value from Invoke to a PythonGenerator and iterate over it to populate the array of languages.<\/p>\n<p>If you\u2019re working with dynamic languages from C#, the <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/57985#760280\">ObjectOperations<\/a> instance than hangs off the ScriptEngine instance is amazingly useful. Dynamic objects can participate in a powerful but somewhat complex protocol for binding a wide variety of dynamic operation types. The <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/57985#760650\">DynamicMetaObject<\/a> class supports twelve different Bind operations. But the DynamicMetaObject binder methods are designed to be used by language implementors. The ObjectOperations class lets you invoke them fairly easily from a higher level of abstraction.<\/p>\n<p>The last Python function I call from C# is generate_html. Unlike get_all_lexers, generate_html takes three parameters and can be called multiple times. The Invoke method has a params argument so it can accept any number of additional parameters, but when I tried to call it I got a NotImplemented exception. It turns out that Invoke currently throws NotImplemented if it receives more than 2 parameters. Yes, we realize that\u2019s kinda broken and we are looking to fix it. However, it turns out there\u2019s another way that\u2019s also more efficient for a function like generate_html that we are likely to call more than once. Here\u2019s my implementation of GenerateHtml in C#.<\/p>\n<pre class=\"brush: csharp\">\nFunc&lt;object, object, object, string&gt; _generatehtml_function;      \n\npublic string GenerateHtml(string code, string lexer, string style)      \n{\n    if (_generatehtml_function == null)      \n    {\n        _init_thread.Join();      \n             \n        var f = _scope.GetVariable&lt;PythonFunction&gt;(\"generate_html\");      \n        _generatehtml_function = _engine.Operations.ConvertTo      \n                           &lt;Func&lt;object, object, object, string&gt;&gt;(f);      \n    }\n\n    return _generatehtml_function(code, lexer, style);      \n}\n<\/pre>\n<p>Instead of calling Invoke, I convert the PythonFunction instance into a delegate using Operations.ConvertTo which I then cache and call like any other delegate from C#. Not only does Invoke fail for more than two parameters, it creates a new dynamic call site every time it\u2019s called. Since get_all_lexers and get_all_styles are each only called once, it\u2019s no big deal. But you typically call generate_html multiple times for a block of source code. Using ConvertTo generates a dynamic call site as part of the delegate, so that\u2019s more efficient than creating one on every call. <\/p>\n<p>The rest of the C# code is fairly pedestrian and has nothing to do with IronPython, as all access to Python code is hidden behind GenerateHtml as well as the Languages and Styles property. <\/p>\n<p>So as I\u2019ve shown in the last few posts, embedding IronPython inside a C# application \u2013 even before we get the new dynamic functionality of C# 4.0 \u2013 isn\u2019t really all that hard. Of course, we\u2019re always interested in ways to make it easier. If you\u2019ve got any questions or suggestions, please feel free to leave a comment or drop me a line.<\/p>\n","excerpt":"<p>So I\u2019ve compiled the Pygments package into a CLR assembly and loaded an embedded Python script, so now all that remains is calling into the functions in that embedded Python script. Turns out, this is the easiest step so far. We\u2019ll start with get_all_lexers and get_all_styles, since they\u2019re nearly identical. Both functions are called once [&hellip;]<\/p>\n","date":"2009-08-12 10:10:00","modified":"2009-08-12 10:10:00","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":231,"slug":"dlr","title":"DLR","description":"","post_count":25},{"id":285,"slug":"pygments","title":"Pygments","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["03f74f91-03a2-4aa2-a456-33967f739b18"],"dasblog_compressedtitle":["Invoking+Python+Functions+From+C+Without+Dynamic"],"dasblog_compressedtitleunique":["2009\/08\/12\/Invoking+Python+Functions+From+C+Without+Dynamic"]}},"previous_url":"http:\/\/devhawk.net\/2009\/08\/11\/embedding-python-scripts-in-c-applications\/","next_url":"http:\/\/devhawk.net\/2009\/08\/13\/2009-space-elevator-conference\/"}