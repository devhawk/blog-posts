<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Invoking Python Functions from C# (Without Dynamic)</title>
  <link>http://devhawk.net/2009/08/12/invoking-python-functions-from-c-without-dynamic/</link>
  <pubDate>Wed, 12 Aug 2009 10:10:00 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://03f74f91-03a2-4aa2-a456-33967f739b18</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p><a href="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/InvokingPythonFunctionsfromCWithoutDynam_13C34/image_2.png"><img style="border-right-width: 0px; margin: 0px 5px 0px 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" align="left" src="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/InvokingPythonFunctionsfromCWithoutDynam_13C34/image_thumb.png" width="133" height="240" /></a> So I’ve <a href="http://devhawk.net/2009/08/10/Compiling+Python+Packages+Into+Assemblies.aspx">compiled the Pygments package into a CLR assembly</a> and <a href="http://devhawk.net/2009/08/11/Embedding+Python+Scripts+In+C+Applications.aspx">loaded an embedded Python script</a>, so now all that remains is calling into the functions in that embedded Python script. Turns out, this is the easiest step so far.</p><p>We’ll start with get_all_lexers and get_all_styles, since they’re nearly identical. Both functions are called once on initialization, take zero arguments and return a PythonGenerator (for you C# devs, a PythonGenerator is kind of like the IEnumerable that gets created when you yield return from a function). In fact, the only difference between them is that get_all_styles returns a generator of simple strings, while get_all_lexers returns a PythonTuple of the long name, a tuple of aliases, a tuple of filename patterns and a tuple of mime types. Here’s the implementation of Languages property:</p><pre class="brush: csharp">
PygmentLanguage[] _lanugages;     

public PygmentLanguage[] Languages      
{
    get
    {
        if (_lanugages == null)      
        {
            _init_thread.Join();      

            var f = _scope.GetVariable&lt;PythonFunction&gt;("get_all_lexers");      
            var r = (PythonGenerator)_engine.Operations.Invoke(f);      
            var lanugages_list = new List&lt;PygmentLanguage&gt;();      
            foreach (PythonTuple o in r)      
            {
                lanugages_list.Add(new PygmentLanguage()      
                    {
                        LongName = (string)o[0],      
                        LookupName = (string)((PythonTuple)o[1])[0]      
                    });      
            }

            _lanugages = lanugages_list.ToArray();      
        }

        return _lanugages;      
    }
}
</pre><p>If you recall from my last post, I initialized the _scope on a background thread, so I first have to wait for the thread to complete. If I was using C# 4.0, I’d simply be able to run _scope.get_all_lexers, but since I’m not I have to manually reach into the _scope and retrieve the get_all_lexers function via the GetVariable method. I can’t invoke the PythonFunction directly from C#, instead I have to use the Invoke method that hangs off _engine.Operations. I cast the return value from Invoke to a PythonGenerator and iterate over it to populate the array of languages.</p><p>If you’re working with dynamic languages from C#, the <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/57985#760280">ObjectOperations</a> instance than hangs off the ScriptEngine instance is amazingly useful. Dynamic objects can participate in a powerful but somewhat complex protocol for binding a wide variety of dynamic operation types. The <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/57985#760650">DynamicMetaObject</a> class supports twelve different Bind operations. But the DynamicMetaObject binder methods are designed to be used by language implementors. The ObjectOperations class lets you invoke them fairly easily from a higher level of abstraction.</p><p>The last Python function I call from C# is generate_html. Unlike get_all_lexers, generate_html takes three parameters and can be called multiple times. The Invoke method has a params argument so it can accept any number of additional parameters, but when I tried to call it I got a NotImplemented exception. It turns out that Invoke currently throws NotImplemented if it receives more than 2 parameters. Yes, we realize that’s kinda broken and we are looking to fix it. However, it turns out there’s another way that’s also more efficient for a function like generate_html that we are likely to call more than once. Here’s my implementation of GenerateHtml in C#.</p><pre class="brush: csharp">
Func&lt;object, object, object, string&gt; _generatehtml_function;      

public string GenerateHtml(string code, string lexer, string style)      
{
    if (_generatehtml_function == null)      
    {
        _init_thread.Join();      
             
        var f = _scope.GetVariable&lt;PythonFunction&gt;("generate_html");      
        _generatehtml_function = _engine.Operations.ConvertTo      
                           &lt;Func&lt;object, object, object, string&gt;&gt;(f);      
    }

    return _generatehtml_function(code, lexer, style);      
}
</pre><p>Instead of calling Invoke, I convert the PythonFunction instance into a delegate using Operations.ConvertTo which I then cache and call like any other delegate from C#. Not only does Invoke fail for more than two parameters, it creates a new dynamic call site every time it’s called. Since get_all_lexers and get_all_styles are each only called once, it’s no big deal. But you typically call generate_html multiple times for a block of source code. Using ConvertTo generates a dynamic call site as part of the delegate, so that’s more efficient than creating one on every call. </p><p>The rest of the C# code is fairly pedestrian and has nothing to do with IronPython, as all access to Python code is hidden behind GenerateHtml as well as the Languages and Styles property. </p><p>So as I’ve shown in the last few posts, embedding IronPython inside a C# application – even before we get the new dynamic functionality of C# 4.0 – isn’t really all that hard. Of course, we’re always interested in ways to make it easier. If you’ve got any questions or suggestions, please feel free to leave a comment or drop me a line.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1281</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-08-12 10:10:00</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-08-12 10:10:00</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">invoking-python-functions-from-c-without-dynamic</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="dlr"><![CDATA[DLR]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="pygments"><![CDATA[Pygments]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[03f74f91-03a2-4aa2-a456-33967f739b18]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Invoking+Python+Functions+From+C+Without+Dynamic]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/08/12/Invoking+Python+Functions+From+C+Without+Dynamic]]></wp:meta_value>
  </wp:postmeta>
</item>