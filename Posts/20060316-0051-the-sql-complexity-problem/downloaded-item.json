{"status":"ok","post":{"id":724,"type":"post","slug":"the-sql-complexity-problem","url":"http:\/\/devhawk.net\/2006\/03\/16\/the-sql-complexity-problem\/","status":"publish","title":"The SQL Complexity Problem","title_plain":"The SQL Complexity Problem","content":"<p>I mentioned on the <a href=\"http:\/\/devhawk.net\/2006\/03\/14\/Compiler+Dev+Lab++LINQ.aspx\">first day of the Compiler Dev Lab<\/a> that <a href=\"http:\/\/weblogs.asp.net\/brianbec\">Brian Beckman<\/a> is a hoot. He&#8217;s also wicked smart. He <a href=\"http:\/\/weblogs.asp.net\/brianbec\/archive\/2006\/03\/15\/440293.aspx\">posted<\/a> about his demo from Monday where he demonstrates building indexes for use in LINQ queries. In his words:<\/p>\n<blockquote dir=\"ltr\" style=\"MARGIN-RIGHT: 0px\"><p>In the terminology of relational databases, a \u201cjoin\u201d is, semantically, like a nested loop over a pair of lists (or tables) of records, saving only those where some certain fields match. Unless we do something smart, this could be very expensive. Imagine searching a database of a million DNA profiles for the closest match to a sample that has 10,000 DNA features (I have no idea whether those are real numbers: I just made them up, but they sound ballpark to me). A dumb join would search all 1 million profiles for each of the 10,000 features, resulting in 10 billion match tests, almost all of which will fail \u2013 by design, of course. That\u2019s going to hurt. <\/p>\n<p>The \u201csomething smart\u201d is to build an index and search through that. Your database doesn\u2019t have to be large at all for this to pay off. In fact, even with just a few records, it\u2019s cheaper to build an index, use it, and throw it away than it is to do a nested loop. <\/p>\n<\/blockquote>\n<p dir=\"ltr\">He goes on to prove out his point about building an index. For his full dataset (joining 3053 cities with 195 countries) it is literally 65x slower not to build a one-off index. Even for smaller datasets, the time difference is less dramatic but still significant. For example, with 89 cities instead of 3053, it&#8217;s 3x slower not to build the index. <\/p>\n<p dir=\"ltr\">The reason I&#8217;m so interested in Brian&#8217;s post is because of my <a href=\"http:\/\/devhawk.net\/2006\/02\/27\/Experimenting+With+Ning.aspx\">experiments with Ning<\/a>. As you might recall, in trying to build a .NET version of <a href=\"http:\/\/partisanhacks.ning.com\/\">Partisan Hacks<\/a>, I found ASP.NET 2.0 to be significantly simpler than PHP (which Ning uses). However, building even the trivial SQL Express database for Partisan Hacks was a non-trivial exercise. Sure, I&#8217;ve done it many times before, but it seems strange that ASP.NET makes it so easy to build a site while SQL Server makes it so complex to build a database. If I was a novice user, I would never be able to build a database for my web site.<\/p>\n<p dir=\"ltr\">Why is this? I think that the simple app or amateur developer is simply not the target audience for SQL Server (even SQL Express). If you don&#8217;t know the difference between nvarchar(100) and varchar(max) you&#8217;re pretty much out in the cold when it comes to SQL Server. Their target audience appears to be enterprise databases that are cared for by enterprise database administrators. Databases with scores of tables and millions of rows. Great for them, bad for novice users who just want to persist their data somewhere quickly and easily.<\/p>\n<p dir=\"ltr\">Why can&#8217;t building my database be as simple as building my site?<\/p>\n<p dir=\"ltr\">Ning makes it easy to use their <a href=\"http:\/\/documentation.ning.com\/post.php?Post:slug=XN-XN_Content\">Content Store<\/a>. You create an instance of a content object, you set properties (dynamic ones), you hit save. No fuss, no muss, no db schema. Sure is an easier model to understand and program to. In that regard, it blows away everything, even <a href=\"http:\/\/www.rubyonrails.com\/\">Ruby on Rails<\/a>. RoR is pretty sweet, but it needs a real database schema on the back end in order to drive RoR&#8217;s guiding principle of &#8220;convention over configuration<em>&#8220;<\/em>. If there&#8217;s no DB schema to discover, I think much of the RoR model would break down. (but that may just be my lack of RoR experience talking)<\/p>\n<p dir=\"ltr\">I not sure what a simpler database system would look like, but one idea of mine is to use a schemaless database. Much of the complexity comes from having to define both an in memory as well as perseistant schema, as well as the translation between them. If you just stored managed .NET objects, you would eliminate the redundant schema specification. It&#8217;s not a fully fleshed out concept, but it is a start of an idea.<\/p>\n<p dir=\"ltr\">What other ideas would make persistant data significantly easier to work with?<\/p>\n","excerpt":"<p>I mentioned on the first day of the Compiler Dev Lab that Brian Beckman is a hoot. He&#8217;s also wicked smart. He posted about his demo from Monday where he demonstrates building indexes for use in LINQ queries. In his words: In the terminology of relational databases, a \u201cjoin\u201d is, semantically, like a nested loop [&hellip;]<\/p>\n","date":"2006-03-16 00:51:32","modified":"2006-03-16 00:51:32","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":214,"slug":"database","title":"Database","description":"","post_count":13}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2333,"name":"Jonathan Aquino","url":"http:\/\/jonathanaquino.com","date":"2006-03-16 22:56:24","content":"<p>Hi Harry &#8211; Thanks for highlighting the beauty of the Ning content store. Right on!<\/p>\n","parent":0},{"id":2334,"name":"Bob English","url":"","date":"2006-03-17 15:01:09","content":"<p>Well, it seems you&#8217;ve just discovered the language impedence mismatch (between databases and programming) C#3 is all about?<br \/>\nSolutions of diverse kinds have been around for some time, and a some interest into the Java community would help you grasp the ideas&#8230;<br \/>\nHave a look at db4objects and see for yourself!<\/p>\n<p>To me, and to the knowledge I have so far with C#3 and LINQ, these are just going back to the goo&#8217; ol&#8217; days of Visual FoxPro and embedded SQL. If its true, then it&#8217;s a backwards step. Forward step is, as you reckon, into direct object graphs persistence.<\/p>\n<p>Cheers,<br \/>\nBob<\/p>\n","parent":0},{"id":2335,"name":"Chris Sterling","url":"http:\/\/jroller.com\/page\/csterwa","date":"2006-03-26 22:58:21","content":"<p>This subject is probably what I find to be the most interesting problem we are dealing with today.  Ruby, Python, C#3, and other models for dealing with this problem don&#8217;t seem to be solutions in my opinion.  I tend to agree with your second comenter, Bob, in regards to direct object graph persistence but I also see that we must deal with the duplication and communication channels within our organizations, as well.  This will take more than a better persistence mechanism.  It will take systems which can merge data and dynamically relate data based upon context.  My current understanding of this would be done using agents and well defined heuristics.<\/p>\n<p>I posted my thoughts on this subject with a link back to this entry at <a href=\"http:\/\/jroller.com\/page\/csterwa?entry=data_our_technological_debt\" rel=\"nofollow\">http:\/\/jroller.com\/page\/csterwa?entry=data_our_technological_debt<\/a>.<\/p>\n","parent":0}],"attachments":[],"comment_count":3,"comment_status":"closed","custom_fields":{"dasblog_entryid":["dc8da217-b67e-4aa0-9cb9-fe57d0ad28c1"],"dasblog_compressedtitle":["The+SQL+Complexity+Problem"],"dasblog_compressedtitleunique":["2006\/03\/16\/The+SQL+Complexity+Problem"]}},"previous_url":"http:\/\/devhawk.net\/2006\/03\/15\/compiler-dev-lab-scripting\/","next_url":"http:\/\/devhawk.net\/2006\/03\/16\/update-on-live-toolbar\/"}