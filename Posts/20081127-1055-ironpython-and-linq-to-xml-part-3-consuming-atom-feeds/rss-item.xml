<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>IronPython and Linq to XML Part 3: Consuming Atom Feeds</title>
  <link>http://devhawk.net/2008/11/27/ironpython-and-linq-to-xml-part-3-consuming-atom-feeds/</link>
  <pubDate>Thu, 27 Nov 2008 10:55:12 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://50f114cb-c9bf-4e6d-b81d-f0fad2c654a9</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Now that I have <a href="http://devhawk.net/2008/11/27/IronPython+And+Linq+To+XML+Part+2+Screen+Scraping.aspx">my list of Rock Band songs</a>, I need to generate a Zune playlist. I wrote that Zune just uses the <a href="http://msdn.microsoft.com/en-us/library/bb249686.aspx">WMP playlist format</a>, but that’s not completely true. <a href="http://msdn.microsoft.com/en-us/library/bb262730(VS.85).aspx">Media elements</a> in a Zune playlist have several attributes that appear unique to Zune. </p><p>Because of Zune Pass, Zune supports the idea of <a href="http://www.mjefferson.net/2008/04/03/zune-streaming-playlists/">streaming playlists</a> where the songs are downloaded on demand instead of played from the local hard drive. In order to enable this, media elements in Zune playlists can have a serviceID attribute, a GUID that uniquely identifies the song on the Zune service. We also need the song’s album and duration – the Zune software summarily removes songs that don’t include the duration.</p><p>Of course, the Rock Band song list doesn’t include the Zune song service ID. It also doesn’t include the song’s album or duration. So we need a way, given the song’s title and artist (which we do have) to get its album, duration and service ID. Luckily, the Zune service provides a way to do exactly this, albeit an undocumented way. Via <a href="http://www.fiddler2.com/fiddler2/">Fiddler2</a>, I learned that Zune exposes a set of Atom feed web services on catalog.zune.net that the UI uses when you search the marketplace from the Zune software. There are feeds to search by artist and by album but the one we care about is the search by track. For example, here’s the track query for <a href="http://catalog.zune.net/v1.2/music/track?q=pinball+wizard+the+who">Pinball Wizard by The Who</a>.</p><p>Since these feeds are real XML, I can simply use <a href="http://msdn.microsoft.com/library/system.xml.linq.xdocument.load.aspx">XDocument.Load</a> to suck down the XML. Then I look for the first Atom entry element using similar LINQ to XML techniques I <a href="http://devhawk.net/2008/11/27/IronPython+And+Linq+To+XML+Part+2+Screen+Scraping.aspx">wrote about last time</a>. If there’s no Atom elements, that means that the search failed – either Zune doesn’t know about the song or it can’t find it via the Rock Band provided title and artist. Of the 461 songs on Rock Band right now, my script can find 417 of them on Zune automatically.</p><p>Of course, since the Zune data is in XML instead of HTML, finding the data I’m looking for is much easier that it was to find the Rock Band song data. Here’s the code pull the relevant information out of the Zune catalog feed that we need.</p><pre class="brush: python">
def ScrapeEntry(entry):   
  id = entry.Element(atomns+'id').Value  
  length = entry.Element(zunens+'length').Value  

  d = {}  
  d['trackTitle'] = entry.Element(atomns+'title').Value  
  d['albumArtist'] = entry.Element(zunens+'primaryArtist')
                       .Element(zunens+'name').Value  
  d['trackArtist'] = d['albumArtist']  
  d['albumTitle'] = entry.Element(zunens+'album')
                       .Element(zunens+'title').Value  
    
  if id.StartsWith('urn:uuid:'):  
    d['serviceId'] = "{" + id.Substring(9) + "}"  
  else:  
    d['serviceId'] = id  
    
  m = length_re.Match(length)  
  if m.Success:  
    min = int(m.Groups[1].Value)  
    sec = int(m.Groups[2].Value)  
    d['duration'] = str((min * 60 + sec) * 1000)  
  else:  
    d['duration'] = '60000'  
      
  return d  

trackurl = catalogurl + song.search_string     
trackfeed = XDocument.Load(trackurl)  
trackentry = First(trackfeed.Descendants(atomns+'entry'))  
track = ScrapeEntry(trackentry)
</pre><p>A few quick notes:</p><ul><li>The code above isn’t valid Python, I added a couple of carriage returns (albumArtist and albumTitle) to get it to read well on the blog without wrapping badly. </li><li>song.search_string returns the song title and artist as a plus delimited string. i.e. pinball+wizard+the+who. However, many Rock Band songs end in a parenthetical like (Cover Version) so I automatically strip that off for the search string</li><li>duration in the Atom feed is stored like PT3M23S, which means the song is 3:23 long. The playlist file expect the song length in milliseconds, so I use a .NET regular expression to pull out the minutes and seconds and do the conversion. It’s not exact – songs lengths usually aren’t exactly a factor of seconds, but as far as I can understand, Zune just uses that to display in the UI – it doesn’t affect playback at all.</li></ul><p>Now I have a list of songs with all the relevant metadata, next time I’ll write it out into a Zune playlist file.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1200</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2008-11-27 10:55:12</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2008-11-27 10:55:12</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">ironpython-and-linq-to-xml-part-3-consuming-atom-feeds</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="linq"><![CDATA[LINQ]]></category>
  <category domain="post_tag" nicename="rock-band"><![CDATA[Rock Band]]></category>
  <category domain="post_tag" nicename="xml"><![CDATA[XML]]></category>
  <category domain="post_tag" nicename="zune"><![CDATA[Zune]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[50f114cb-c9bf-4e6d-b81d-f0fad2c654a9]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[IronPython+And+Linq+To+XML+Part+3+Consuming+Atom+Feeds]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2008/11/27/IronPython+And+Linq+To+XML+Part+3+Consuming+Atom+Feeds]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2152</wp:comment_id>
    <wp:comment_author><![CDATA[Rick]]></wp:comment_author>
    <wp:comment_author_email>rickrat@gmail.com</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>70.180.200.133</wp:comment_author_IP>
    <wp:comment_date>2008-12-20 01:12:43</wp:comment_date>
    <wp:comment_date_gmt>2008-12-20 09:12:43</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Can you tell me the regular expression used for parsing the duration? e.g. <a:length> of the track?

Thanks,

Rick]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>