{"status":"ok","post":{"id":1200,"type":"post","slug":"ironpython-and-linq-to-xml-part-3-consuming-atom-feeds","url":"http:\/\/devhawk.net\/2008\/11\/27\/ironpython-and-linq-to-xml-part-3-consuming-atom-feeds\/","status":"publish","title":"IronPython and Linq to XML Part 3: Consuming Atom Feeds","title_plain":"IronPython and Linq to XML Part 3: Consuming Atom Feeds","content":"<p>Now that I have <a href=\"http:\/\/devhawk.net\/2008\/11\/27\/IronPython+And+Linq+To+XML+Part+2+Screen+Scraping.aspx\">my list of Rock Band songs<\/a>, I need to generate a Zune playlist. I wrote that Zune just uses the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/bb249686.aspx\">WMP playlist format<\/a>, but that\u2019s not completely true. <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/bb262730(VS.85).aspx\">Media elements<\/a> in a Zune playlist have several attributes that appear unique to Zune. <\/p>\n<p>Because of Zune Pass, Zune supports the idea of <a href=\"http:\/\/www.mjefferson.net\/2008\/04\/03\/zune-streaming-playlists\/\">streaming playlists<\/a> where the songs are downloaded on demand instead of played from the local hard drive. In order to enable this, media elements in Zune playlists can have a serviceID attribute, a GUID that uniquely identifies the song on the Zune service. We also need the song\u2019s album and duration \u2013 the Zune software summarily removes songs that don\u2019t include the duration.<\/p>\n<p>Of course, the Rock Band song list doesn\u2019t include the Zune song service ID. It also doesn\u2019t include the song\u2019s album or duration. So we need a way, given the song\u2019s title and artist (which we do have) to get its album, duration and service ID. Luckily, the Zune service provides a way to do exactly this, albeit an undocumented way. Via <a href=\"http:\/\/www.fiddler2.com\/fiddler2\/\">Fiddler2<\/a>, I learned that Zune exposes a set of Atom feed web services on catalog.zune.net that the UI uses when you search the marketplace from the Zune software. There are feeds to search by artist and by album but the one we care about is the search by track. For example, here\u2019s the track query for <a href=\"http:\/\/catalog.zune.net\/v1.2\/music\/track?q=pinball+wizard+the+who\">Pinball Wizard by The Who<\/a>.<\/p>\n<p>Since these feeds are real XML, I can simply use <a href=\"http:\/\/msdn.microsoft.com\/library\/system.xml.linq.xdocument.load.aspx\">XDocument.Load<\/a> to suck down the XML. Then I look for the first Atom entry element using similar LINQ to XML techniques I <a href=\"http:\/\/devhawk.net\/2008\/11\/27\/IronPython+And+Linq+To+XML+Part+2+Screen+Scraping.aspx\">wrote about last time<\/a>. If there\u2019s no Atom elements, that means that the search failed \u2013 either Zune doesn\u2019t know about the song or it can\u2019t find it via the Rock Band provided title and artist. Of the 461 songs on Rock Band right now, my script can find 417 of them on Zune automatically.<\/p>\n<p>Of course, since the Zune data is in XML instead of HTML, finding the data I\u2019m looking for is much easier that it was to find the Rock Band song data. Here\u2019s the code pull the relevant information out of the Zune catalog feed that we need.<\/p>\n<pre class=\"brush: python\">\ndef ScrapeEntry(entry):   \n  id = entry.Element(atomns+'id').Value  \n  length = entry.Element(zunens+'length').Value  \n\n  d = {}  \n  d['trackTitle'] = entry.Element(atomns+'title').Value  \n  d['albumArtist'] = entry.Element(zunens+'primaryArtist')\n                       .Element(zunens+'name').Value  \n  d['trackArtist'] = d['albumArtist']  \n  d['albumTitle'] = entry.Element(zunens+'album')\n                       .Element(zunens+'title').Value  \n    \n  if id.StartsWith('urn:uuid:'):  \n    d['serviceId'] = \"{\" + id.Substring(9) + \"}\"  \n  else:  \n    d['serviceId'] = id  \n    \n  m = length_re.Match(length)  \n  if m.Success:  \n    min = int(m.Groups[1].Value)  \n    sec = int(m.Groups[2].Value)  \n    d['duration'] = str((min * 60 + sec) * 1000)  \n  else:  \n    d['duration'] = '60000'  \n      \n  return d  \n\ntrackurl = catalogurl + song.search_string     \ntrackfeed = XDocument.Load(trackurl)  \ntrackentry = First(trackfeed.Descendants(atomns+'entry'))  \ntrack = ScrapeEntry(trackentry)\n<\/pre>\n<p>A few quick notes:<\/p>\n<ul>\n<li>The code above isn\u2019t valid Python, I added a couple of carriage returns (albumArtist and albumTitle) to get it to read well on the blog without wrapping badly. <\/li>\n<li>song.search_string returns the song title and artist as a plus delimited string. i.e. pinball+wizard+the+who. However, many Rock Band songs end in a parenthetical like (Cover Version) so I automatically strip that off for the search string<\/li>\n<li>duration in the Atom feed is stored like PT3M23S, which means the song is 3:23 long. The playlist file expect the song length in milliseconds, so I use a .NET regular expression to pull out the minutes and seconds and do the conversion. It\u2019s not exact \u2013 songs lengths usually aren\u2019t exactly a factor of seconds, but as far as I can understand, Zune just uses that to display in the UI \u2013 it doesn\u2019t affect playback at all.<\/li>\n<\/ul>\n<p>Now I have a list of songs with all the relevant metadata, next time I\u2019ll write it out into a Zune playlist file.<\/p>\n","excerpt":"<p>Now that I have my list of Rock Band songs, I need to generate a Zune playlist. I wrote that Zune just uses the WMP playlist format, but that\u2019s not completely true. Media elements in a Zune playlist have several attributes that appear unique to Zune. Because of Zune Pass, Zune supports the idea of [&hellip;]<\/p>\n","date":"2008-11-27 10:55:12","modified":"2008-11-27 10:55:12","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":224,"slug":"linq","title":"LINQ","description":"","post_count":24},{"id":273,"slug":"rock-band","title":"Rock Band","description":"","post_count":4},{"id":238,"slug":"xml","title":"XML","description":"","post_count":11},{"id":274,"slug":"zune","title":"Zune","description":"","post_count":4}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2152,"name":"Rick","url":"","date":"2008-12-20 01:12:43","content":"<p>Can you tell me the regular expression used for parsing the duration? e.g. <a:length> of the track?<\/p>\n<p>Thanks,<\/p>\n<p>Rick<\/a:length><\/p>\n","parent":0}],"attachments":[],"comment_count":1,"comment_status":"closed","custom_fields":{"dasblog_entryid":["50f114cb-c9bf-4e6d-b81d-f0fad2c654a9"],"dasblog_compressedtitle":["IronPython+And+Linq+To+XML+Part+3+Consuming+Atom+Feeds"],"dasblog_compressedtitleunique":["2008\/11\/27\/IronPython+And+Linq+To+XML+Part+3+Consuming+Atom+Feeds"]}},"previous_url":"http:\/\/devhawk.net\/2008\/11\/26\/early-christmas-from-iron-languages-and-dlr\/","next_url":"http:\/\/devhawk.net\/2008\/12\/01\/ironpython-and-linq-to-xml-part-4-generating-xml\/"}