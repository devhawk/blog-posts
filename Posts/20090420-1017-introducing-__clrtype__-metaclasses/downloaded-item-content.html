<p>Everyone knows <a href="http://channel9.msdn.com/pdc2008/TL16/">Anders announced at PDC08</a> that <a href="http://code.msdn.microsoft.com/csharpfuture/Release/ProjectReleases.aspx?ReleaseId=1686">C# 4.0</a> will include new features (aka the dynamic keyword + the DLR) that makes it much easier for C# to call into dynamically typed code. What you probably don&#8217;t know is that IronPython 2.6 includes a new feature that makes it easier for IronPython code to be called by statically typed code. </p>
<p>While the vast majority of .NET is available to IronPython, there are certain APIs that just don&#8217;t work with dynamic code. In particular, any code that uses Reflection over an object&#8217;s CLR type metadata won&#8217;t work with IronPython. For example, while <a href="http://devhawk.net/2008/11/18/IronPython+And+WPF+Part+3+Data+Binding.aspx">WPF supports</a><a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.icustomtypedescriptor.aspx">ICustomTypeDescriptor</a>, Silverlight only supports data binding against reflectable properties. Furthermore, any code that uses custom attributes inherently uses Reflection. For example, Darrel Hawley recently blogged a <a href="http://www.darrellhawley.com/2009/03/writing-ironpython-wcf-host.html">WCF host he wrote in IronPython</a>, but he wrote the WCF service in C#. You can&#8217;t write WCF services in IronPython because WCF expects service classes <a href="http://msdn.microsoft.com/en-us/library/ms731835.aspx">to be adorned</a> with <a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.servicecontractattribute.aspx">ServiceContract</a> and <a href="http://msdn.microsoft.com/en-us/library/system.servicemodel.operationcontractattribute.aspx">OperationContract</a> attributes (among <em>many</em> others). IronPython users want access to use these APIs. Support for custom attributes is one of the most <a href="http://lists.ironpython.com/pipermail/users-ironpython.com/2008-July/007733.html">common requests</a> we get &#8211; it&#8217;s currently the <a href="http://ironpython.codeplex.com/WorkItem/View.aspx?WorkItemId=20489">5th highest vote getter among open issues</a>. </p>
<p>In IronPython 2.6, we&#8217;re adding the ability to customize the CLR type of Python classes. This means you can add custom attributes, emit properties, whatever you want. For those of you who&#8217;ve been dreaming of implementing WCF services or databinding in Silverlight purely in IronPython, then this is the feature for you. </p>
<p>In a nutshell, IronPython 2.6 extends Python&#8217;s <a href="http://docs.python.org/reference/datamodel.html#customizing-class-creation">metaclass</a> feature that lets you to customize the creation of classes. In the metaclass, you can implement an IronPython-specific method __clrtype__ which returns a custom <a href="http://msdn.microsoft.com/library/system.type.aspx">System.Type</a> of your own creation that IronPython will then use as the underlying CLR type of the Python class. Implementing __clrtype__ gives you the chance to implement whatever reflectable metadata you need: constructors, fields, properties, methods, events, custom attributes, nested classes, whatever. </p>
<p>Over a series of posts, I&#8217;ll be demonstrating this new feature and implement some common scenario requests &#8211; including Silverlight databinding and WCF services &#8211; purely in Python. Quick warning: __clrtype__ uses low level features like Python metaclasses, <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.aspx">Reflection.Emit</a> and <a href="javascript:window.location.href='http://dlr.codeplex.com/Project/Download/FileDownload.aspx?DownloadId=51534';">DLR Binders</a> so these posts will be deeper technically than usual. Don&#8217;t worry &#8211; this isn&#8217;t the API interface we expect everyone to use. Eventually, we want to have an easy to use API that will sit on top of the low-level __clrtype__ hook. </p>
