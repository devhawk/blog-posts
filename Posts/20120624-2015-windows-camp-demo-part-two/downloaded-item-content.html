<p>In my <a href="http://devhawk.net/2012/06/19/windows-camp-demo-part-one/">previous post</a>, we set up a C++ WinRT component project and a C# Metro style XAML app to use the component. The code was dinky Hello, world type stuff. Now, let&#8217;s do something a little more interesting.</p>
<p>In preparing for this demo, I found a <a href="http://bitmap.codeplex.com/">C++ bitmap library</a> on CodePlex that includes a plasma texture generation function. This sounded like a good demo for both language interop and using existing code. It builds on the code from <a href="http://devhawk.net/2012/06/19/windows-camp-demo-part-one/">my previous post</a>, so either start there or <a href="https://github.com/devhawk/WindowsCampDemo">clone from GitHub</a> and checkout the part1 tag.</p>
<p>First step is to add the bitmap_image.hpp file from <a href="http://www.partow.net/index.html">Arash Partow&#8217;s</a> <a href="http://bitmap.codeplex.com/">C++ Bitmap Library</a> to the C++ component project. Download the <a href="http://bitmap.codeplex.com/SourceControl/list/changesets">latest commit</a> from CodePlex as a zip and extract the bitmap_image.hpp file into your C++ component project directory. Switch over to VS, right click on the component project node, select Add -&gt; Existing Item&#8230; and select the bitmap_image.hpp file.</p>
<p>Now that we have included the library code, we need to write the wrapper code to expose that library functionality to other languages via WinRT. We&#8217;ll start by adding the following namespace declarations to the top of the Class1.h header file:</p>
<pre class="brush:cpp">using namespace Windows::Foundation;
using namespace Windows::Storage::Streams;</pre>
<p>And then we&#8217;ll add the declaration for our GetPlasmaImageAsync method to Class1&#8217;s header file underneath the SayHello method. Note, in my original presentation I called this method GetPlasmaImage, neglecting to follow the naming convention of appending &#8220;Async&#8221; to name of all asynchronous methods.</p>
<pre class="brush:cpp">IAsyncOperation&lt;IRandomAccessStream^&gt;^ GetPlasmaImageAsync(
    unsigned int width, unsigned int height);</pre>
<p>We&#8217;re using two WinRT types in this method declaration.</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.irandomaccessstream.aspx">IRandomAccessStream</a> represents a stream of binary data that supports random access. We&#8217;re going to return our plasma image as an IRandomAccessStream and then wrap it in a XAML bitmap image for use in our UI.</li>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br206598.aspx">IAsyncOperation&lt;T&gt;</a> represents an asynchronous operation that returns a value. Generating the image takes a significant amount of time (especially given the shortcut I used as you&#8217;ll see in a bit) so we need to make it async. Async is a <em>big</em> topic and we&#8217;re just touching on it in this walkthrough. For more on async in WinRT, check out my teammate <a href="http://blogs.msdn.com/b/windowsappdev/archive/2012/03/20/keeping-apps-fast-and-fluid-with-asynchrony-in-the-windows-runtime.aspx">Jason Olson&#8217;s post</a> on the <a href="http://blogs.msdn.com/b/windowsappdev/">Win8 app developer blog</a>.</li>
</ul>
<p>Now that we have the declaration, let&#8217;s switch over to the Class1.cpp file to add the method implementation. This isn&#8217;t a one line method like SayHello, so I decided to separate declaration from implementation as is traditional C++ best practice.</p>
<p>Before we do anything else, we need to #include the bitmap_image.hpp file. However, this bitmap library uses an unchecked destination STL copy function that <a href="http://msdn.microsoft.com/en-us/library/aa985872(v=vs.110).aspx">Microsoft considers unsafe</a>. I <em>really </em>should be updating the code to used <a href="http://msdn.microsoft.com/en-us/library/aa985965(v=vs.110)">checked iterators</a>, but since this is demo code, we&#8217;re going to turn off the warning instead. We do that by #defining _SCL_SECURE_NO_WARNINGS. While we&#8217;re doing that, let&#8217;s add the additional #includes and using namespace statements we&#8217;re going to need.</p>
<pre class="brush:cpp">#include &quot;pch.h&quot;
#include &quot;Class1.h&quot;

#define _SCL_SECURE_NO_WARNINGS
#include &quot;bitmap_image.hpp&quot;
#include &lt;string&gt;
#include &lt;ppltasks.h&gt;

using namespace WindowsCampComponent;
using namespace std;
using namespace concurrency;
using namespace Windows::Storage;</pre>
<p>In addition to the bitmap image library, we&#8217;re going to need the STL string library and the Parallel Patterns Library, so I&#8217;ve gone ahead and #included those header files and used those namespaces. We&#8217;re also going to use some types from the Windows::Storage namespace, so I&#8217;ve used that namespace as well.</p>
<p>The implementation of the GetPlasmaImageAsync method is going to happen in several steps:</p>
<ol>
<li>Generate the plasma image using the C++ Bitmap library</li>
<li>Save the plasma image to a temporary file</li>
<li>Reopen the temporary file as an IRandomAcessStream with WinRT&#8217;s file system APIs</li>
</ol>
<p>Saving and reopening the file is the shortcut I alluded to earlier. The image library includes a save_image method that uses STL streams to write the image out to a file. A better solution would be to factor the save_image method to support saving a bitmap to a stream and then implementing an STL -&gt; WinRT stream adapter, but this is a simple demo so I&#8217;ll leave that as an exercise to the reader. (Please send me a pull request if you do this!)</p>
<p>First, we&#8217;re going to generate the file path we&#8217;ll be saving the image to. Turns out this somewhat difficult because WinRT uses wide character strings while the bitmap library expects ASCII STL strings.</p>
<pre class="brush:cpp">//get the temp filename
auto tempFolder = ApplicationData::Current-&gt;TemporaryFolder;

wstring tempFolderPath(tempFolder-&gt;Path-&gt;Data());
string folderPath(begin(tempFolderPath), end(tempFolderPath));

auto filePath = folderPath.append(&quot;\\plasma.bmp&quot;);</pre>
<p>I&#8217;m not proud of this code. It&#8217;s the kind of code you write when you&#8217;re rushing to get a demo for your talk done. But lets look at it anyway.</p>
<p>First, I get the path to the temporary folder via the <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.applicationdata.current.aspx">current</a> <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.applicationdata.aspx">ApplicationData</a> object. Then I converted it first to a std::wstring and then to a std::string. I probably could have created the std::string directly from the tempFolder variable, but using the begin and end iterators of the wstring is a clever hack I read somewhere online. Finally, I append the file name to the folder path to get the final file path name.</p>
<p>Next, we generate and save the plasma image. This code is lifted almost verbatim from the bitmap_test.cpp file that comes with the C++ image library. The only difference is that we&#8217;re using the width and height arguments as parameters to the bitmap_image constructor rather than hardcoded values.</p>
<pre class="brush:cpp">//create the image object
bitmap_image image(width, height);
image.clear();

double c1 = 0.9;
double c2 = 0.5;
double c3 = 0.3;
double c4 = 0.7;

::srand(0xA5AA5AA5);

//generate plasma image
plasma(image, 0, 0, image.width(), image.height(),
    c1, c2, c3, c4, 3.0, jet_colormap);

//Save the image to the file
image.save_image(filePath);</pre>
<p>Finally, we open the image file from the temporary folder using WinRT APIs. File access APIs in WinRT are exclusively async, so I&#8217;m using <a href="http://msdn.microsoft.com/en-us/library/hh750113(v=vs.110)">PPL tasks</a> to simplify the async code. Note, I&#8217;ve reworked this code from what I did in the video to make it easier to understand. I&#8217;ve also added explicit type declarations that I didn&#8217;t need to make it clear what each type is. If I replaced those all with the new auto keyword from C++11, the code would work the same.</p>
<pre class="brush:cpp">//reopen the image file using WinRT
IAsyncOperation&lt;StorageFile^&gt;^ getFileAsyncOp = 
    tempFolder-&gt;GetFileAsync(ref new String(L&quot;plasma.bmp&quot;));

task&lt;StorageFile^&gt; getFileTask(getFileAsyncOp);

task&lt;IRandomAccessStream^&gt; openFileTask = 
    getFileTask.then([](StorageFile^ storageFile) {
       return storageFile-&gt;OpenAsync(FileAccessMode::Read);
    });

return create_async(
    [openFileTask]() { return openFileTask; });</pre>
<p>First, we call GetFileAsync&nbsp;to get the file from the temp folder which returns an IAsyncOperation&lt;StorageFolder^&gt; object. We then convert the IAsyncOperation to a PPL task via the task constructor. Note, these two steps could be easily combined into a single step if you not being extra verbose for education purposes.</p>
<p>Once we have a PPL task to get the file, we specify the operation to do when the task completes by passing a lambda to the <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh750044.aspx">task&#8217;s then method</a>. In this case, we&#8217;re going to open the file after we get it. The then method is nice because we can chain together as many async operations as we want in a nearly-synchronous coding style.</p>
<p>Finally, once we have built up the PPL task that represents the entire asynchronous operation, we use the <a href="http://msdn.microsoft.com/en-us/library/hh750102(v=vs.110).aspx">create_async</a> method to convert the PPL task back to an IAsyncOperation which we return from the function.</p>
<p>Now that we have written the component side, lets update the client side. Async operations are very succinct in CLR because of the <a href="http://msdn.microsoft.com/en-us/library/hh191443(v=VS.110).aspx">new await keywords</a>. Much nicer than the .then model used by PPL (which is probably why Herb Sutter <a href="http://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/">wants to see await added to C++</a>).</p>
<pre class="brush:csharp">private async void Button_Click_1(object sender, RoutedEventArgs e)
{
    var wcc = new WindowsCampComponent.Class1();
    myText.Text = wcc.SayHello(&quot;Herb Sutter&quot;);

    var stm = await wcc.GetPlasmaImageAsync(800, 600);

    var bitmap = new BitmapImage();
    bitmap.SetSource(stm);
    myImage.Source = bitmap;
}</pre>
<p>And it works!</p>
<p><a class="grouped_elements" href=".\WCDemo2-RunningApp.png" rel="tc-fancybox-group2012"><img class="alignnone size-medium wp-image-2015" title="WCDemo2-RunningApp" src=".\WCDemo2-RunningApp-300x187.png" alt width="300" height="187"></a></p>
<p>And that&#8217;s the entire demo. About 20 lines of code to wrap a &nbsp;pre-existing library function&nbsp;and make it available to other languages via the Windows Runtime. I showed calling my WinRT component from C# here, but I could have called it from JavaScript just as easily.</p>
