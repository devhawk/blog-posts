{"status":"ok","post":{"id":2012,"type":"post","slug":"windows-camp-demo-part-two","url":"http:\/\/devhawk.net\/2012\/06\/24\/windows-camp-demo-part-two\/","status":"publish","title":"Windows Camp Demo, Part Two","title_plain":"Windows Camp Demo, Part Two","content":"<p>In my <a href=\"http:\/\/devhawk.net\/2012\/06\/19\/windows-camp-demo-part-one\/\">previous post<\/a>, we set up a C++ WinRT component project and a C# Metro style XAML app to use the component. The code was dinky Hello, world type stuff. Now, let\u2019s do something a little more interesting.<\/p>\n<p>In preparing for this demo, I found a <a href=\"http:\/\/bitmap.codeplex.com\/\">C++ bitmap library<\/a> on CodePlex that includes a plasma texture generation function. This sounded like a good demo for both language interop and using existing code. It builds on the code from <a href=\"http:\/\/devhawk.net\/2012\/06\/19\/windows-camp-demo-part-one\/\">my previous post<\/a>, so either start there or <a href=\"https:\/\/github.com\/devhawk\/WindowsCampDemo\">clone from GitHub<\/a> and checkout the part1 tag.<\/p>\n<p>First step is to add the bitmap_image.hpp file from <a href=\"http:\/\/www.partow.net\/index.html\">Arash Partow\u2019s<\/a> <a href=\"http:\/\/bitmap.codeplex.com\/\">C++ Bitmap Library<\/a> to the C++ component project. Download the <a href=\"http:\/\/bitmap.codeplex.com\/SourceControl\/list\/changesets\">latest commit<\/a> from CodePlex as a zip and extract the bitmap_image.hpp file into your C++ component project directory. Switch over to VS, right click on the component project node, select Add -&gt; Existing Item\u2026 and select the bitmap_image.hpp file.<\/p>\n<p>Now that we have included the library code, we need to write the wrapper code to expose that library functionality to other languages via WinRT. We\u2019ll start by adding the following namespace declarations to the top of the Class1.h header file:<\/p>\n<pre class=\"brush:cpp\">using namespace Windows::Foundation;\r\nusing namespace Windows::Storage::Streams;<\/pre>\n<p>And then we\u2019ll add the declaration for our GetPlasmaImageAsync method to Class1\u2019s header file underneath the SayHello method. Note, in my original presentation I called this method GetPlasmaImage, neglecting to follow the naming convention of appending \u201cAsync\u201d to name of all asynchronous methods.<\/p>\n<pre class=\"brush:cpp\">IAsyncOperation&lt;IRandomAccessStream^&gt;^ GetPlasmaImageAsync(\r\n    unsigned int width, unsigned int height);<\/pre>\n<p>We\u2019re using two WinRT types in this method declaration.<\/p>\n<ul>\n<li><a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/windows.storage.streams.irandomaccessstream.aspx\">IRandomAccessStream<\/a> represents a stream of binary data that supports random access. We\u2019re going to return our plasma image as an IRandomAccessStream and then wrap it in a XAML bitmap image for use in our UI.<\/li>\n<li><a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/br206598.aspx\">IAsyncOperation&lt;T&gt;<\/a> represents an asynchronous operation that returns a value. Generating the image takes a significant amount of time (especially given the shortcut I used as you\u2019ll see in a bit) so we need to make it async. Async is a <em>big<\/em> topic and we\u2019re just touching on it in this walkthrough. For more on async in WinRT, check out my teammate <a href=\"http:\/\/blogs.msdn.com\/b\/windowsappdev\/archive\/2012\/03\/20\/keeping-apps-fast-and-fluid-with-asynchrony-in-the-windows-runtime.aspx\">Jason Olson\u2019s post<\/a> on the <a href=\"http:\/\/blogs.msdn.com\/b\/windowsappdev\/\">Win8 app developer blog<\/a>.<\/li>\n<\/ul>\n<p>Now that we have the declaration, let\u2019s switch over to the Class1.cpp file to add the method implementation. This isn\u2019t a one line method like SayHello, so I decided to separate declaration from implementation as is traditional C++ best practice.<\/p>\n<p>Before we do anything else, we need to #include the bitmap_image.hpp file. However, this bitmap library uses an unchecked destination STL copy function that <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/aa985872(v=vs.110).aspx\">Microsoft considers unsafe<\/a>. I <em>really <\/em>should be updating the code to used <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/aa985965(v=vs.110)\">checked iterators<\/a>, but since this is demo code, we\u2019re going to turn off the warning instead. We do that by #defining _SCL_SECURE_NO_WARNINGS. While we\u2019re doing that, let\u2019s add the additional #includes and using namespace statements we\u2019re going to need.<\/p>\n<pre class=\"brush:cpp\">#include \"pch.h\"\r\n#include \"Class1.h\"\r\n\r\n#define _SCL_SECURE_NO_WARNINGS\r\n#include \"bitmap_image.hpp\"\r\n#include &lt;string&gt;\r\n#include &lt;ppltasks.h&gt;\r\n\r\nusing namespace WindowsCampComponent;\r\nusing namespace std;\r\nusing namespace concurrency;\r\nusing namespace Windows::Storage;<\/pre>\n<p>In addition to the bitmap image library, we\u2019re going to need the STL string library and the Parallel Patterns Library, so I\u2019ve gone ahead and #included those header files and used those namespaces. We\u2019re also going to use some types from the Windows::Storage namespace, so I\u2019ve used that namespace as well.<\/p>\n<p>The implementation of the GetPlasmaImageAsync method is going to happen in several steps:<\/p>\n<ol>\n<li>Generate the plasma image using the C++ Bitmap library<\/li>\n<li>Save the plasma image to a temporary file<\/li>\n<li>Reopen the temporary file as an IRandomAcessStream with WinRT\u2019s file system APIs<\/li>\n<\/ol>\n<p>Saving and reopening the file is the shortcut I alluded to earlier. The image library includes a save_image method that uses STL streams to write the image out to a file. A better solution would be to factor the save_image method to support saving a bitmap to a stream and then implementing an STL -&gt; WinRT stream adapter, but this is a simple demo so I\u2019ll leave that as an exercise to the reader. (Please send me a pull request if you do this!)<\/p>\n<p>First, we\u2019re going to generate the file path we\u2019ll be saving the image to. Turns out this somewhat difficult because WinRT uses wide character strings while the bitmap library expects ASCII STL strings.<\/p>\n<pre class=\"brush:cpp\">\/\/get the temp filename\r\nauto tempFolder = ApplicationData::Current-&gt;TemporaryFolder;\r\n\r\nwstring tempFolderPath(tempFolder-&gt;Path-&gt;Data());\r\nstring folderPath(begin(tempFolderPath), end(tempFolderPath));\r\n\r\nauto filePath = folderPath.append(\"\\\\plasma.bmp\");<\/pre>\n<p>I\u2019m not proud of this code. It\u2019s the kind of code you write when you\u2019re rushing to get a demo for your talk done. But lets look at it anyway.<\/p>\n<p>First, I get the path to the temporary folder via the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/windows.storage.applicationdata.current.aspx\">current<\/a> <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/windows.storage.applicationdata.aspx\">ApplicationData<\/a> object. Then I converted it first to a std::wstring and then to a std::string. I probably could have created the std::string directly from the tempFolder variable, but using the begin and end iterators of the wstring is a clever hack I read somewhere online. Finally, I append the file name to the folder path to get the final file path name.<\/p>\n<p>Next, we generate and save the plasma image. This code is lifted almost verbatim from the bitmap_test.cpp file that comes with the C++ image library. The only difference is that we\u2019re using the width and height arguments as parameters to the bitmap_image constructor rather than hardcoded values.<\/p>\n<pre class=\"brush:cpp\">\/\/create the image object\r\nbitmap_image image(width, height);\r\nimage.clear();\r\n\r\ndouble c1 = 0.9;\r\ndouble c2 = 0.5;\r\ndouble c3 = 0.3;\r\ndouble c4 = 0.7;\r\n\r\n::srand(0xA5AA5AA5);\r\n\r\n\/\/generate plasma image\r\nplasma(image, 0, 0, image.width(), image.height(),\r\n    c1, c2, c3, c4, 3.0, jet_colormap);\r\n\r\n\/\/Save the image to the file\r\nimage.save_image(filePath);<\/pre>\n<p>Finally, we open the image file from the temporary folder using WinRT APIs. File access APIs in WinRT are exclusively async, so I\u2019m using <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/hh750113(v=vs.110)\">PPL tasks<\/a> to simplify the async code. Note, I\u2019ve reworked this code from what I did in the video to make it easier to understand. I\u2019ve also added explicit type declarations that I didn\u2019t need to make it clear what each type is. If I replaced those all with the new auto keyword from C++11, the code would work the same.<\/p>\n<pre class=\"brush:cpp\">\/\/reopen the image file using WinRT\r\nIAsyncOperation&lt;StorageFile^&gt;^ getFileAsyncOp = \r\n    tempFolder-&gt;GetFileAsync(ref new String(L\"plasma.bmp\"));\r\n\r\ntask&lt;StorageFile^&gt; getFileTask(getFileAsyncOp);\r\n\r\ntask&lt;IRandomAccessStream^&gt; openFileTask = \r\n    getFileTask.then([](StorageFile^ storageFile) {\r\n       return storageFile-&gt;OpenAsync(FileAccessMode::Read);\r\n    });\r\n\r\nreturn create_async(\r\n    [openFileTask]() { return openFileTask; });<\/pre>\n<p>First, we call GetFileAsync\u00a0to get the file from the temp folder which returns an IAsyncOperation&lt;StorageFolder^&gt; object. We then convert the IAsyncOperation to a PPL task via the task constructor. Note, these two steps could be easily combined into a single step if you not being extra verbose for education purposes.<\/p>\n<p>Once we have a PPL task to get the file, we specify the operation to do when the task completes by passing a lambda to the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/hh750044.aspx\">task&#8217;s then method<\/a>. In this case, we\u2019re going to open the file after we get it. The then method is nice because we can chain together as many async operations as we want in a nearly-synchronous coding style.<\/p>\n<p>Finally, once we have built up the PPL task that represents the entire asynchronous operation, we use the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/hh750102(v=vs.110).aspx\">create_async<\/a> method to convert the PPL task back to an IAsyncOperation which we return from the function.<\/p>\n<p>Now that we have written the component side, lets update the client side. Async operations are very succinct in CLR because of the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/hh191443(v=VS.110).aspx\">new await keywords<\/a>. Much nicer than the .then model used by PPL (which is probably why Herb Sutter <a href=\"http:\/\/herbsutter.com\/2012\/04\/06\/we-want-await-a-c-talk-thats-applicable-to-c\/\">wants to see await added to C++<\/a>).<\/p>\n<pre class=\"brush:csharp\">private async void Button_Click_1(object sender, RoutedEventArgs e)\r\n{\r\n    var wcc = new WindowsCampComponent.Class1();\r\n    myText.Text = wcc.SayHello(\"Herb Sutter\");\r\n\r\n    var stm = await wcc.GetPlasmaImageAsync(800, 600);\r\n\r\n    var bitmap = new BitmapImage();\r\n    bitmap.SetSource(stm);\r\n    myImage.Source = bitmap;\r\n}<\/pre>\n<p>And it works!<\/p>\n<p><a href=\"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp.png\" class=\"grouped_elements\" rel=\"tc-fancybox-group2012\"><img class=\"alignnone size-medium wp-image-2015\" title=\"WCDemo2-RunningApp\" src=\"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp-300x187.png\" alt=\"\" width=\"300\" height=\"187\" \/><\/a><\/p>\n<p>And that\u2019s the entire demo. About 20 lines of code to wrap a \u00a0pre-existing library function\u00a0and make it available to other languages via the Windows Runtime. I showed calling my WinRT component from C# here, but I could have called it from JavaScript just as easily.<\/p>\n","excerpt":"<p>In my previous post, we set up a C++ WinRT component project and a C# Metro style XAML app to use the component. The code was dinky Hello, world type stuff. Now, let\u2019s do something a little more interesting. In preparing for this demo, I found a C++ bitmap library on CodePlex that includes a [&hellip;]<\/p>\n","date":"2012-06-24 20:15:24","modified":"2012-06-25 08:06:23","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165},{"id":283,"slug":"windows","title":"Windows","description":"","parent":0,"post_count":16},{"id":357,"slug":"windows-runtime","title":"Windows Runtime","description":"","parent":0,"post_count":12}],"tags":[{"id":221,"slug":"c-plus-plus","title":"C++","description":"","post_count":9},{"id":368,"slug":"c-plus-plus-cx","title":"C++\/cx","description":"","post_count":3},{"id":369,"slug":"channel-9","title":"Channel 9","description":"","post_count":3},{"id":364,"slug":"metro-style-apps","title":"Metro style apps","description":"","post_count":5},{"id":366,"slug":"windows-8","title":"Windows 8","description":"","post_count":6},{"id":367,"slug":"windows-camp","title":"Windows Camp","description":"","post_count":3},{"id":370,"slug":"winrt-components","title":"WinRT Components","description":"","post_count":3}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[{"id":2015,"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp.png","slug":"wcdemo2-runningapp","title":"WCDemo2-RunningApp","description":"","caption":"","parent":2012,"mime_type":"image\/png","images":{"full":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp.png","width":1024,"height":640},"thumbnail":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp-150x150.png","width":150,"height":150},"medium":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp-300x187.png","width":300,"height":187},"large":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2012\/06\/WCDemo2-RunningApp.png","width":1024,"height":640}}}],"comment_count":0,"comment_status":"closed","custom_fields":{}},"previous_url":"http:\/\/devhawk.net\/2012\/06\/20\/ambiguous-extensionattribute-errors\/","next_url":"http:\/\/devhawk.net\/2014\/02\/14\/putting-the-dev-back-in-devhawk\/"}