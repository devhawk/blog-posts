<p>Yesterday, I posted about <a href="http://devhawk.net/2006/09/19/A+Question+Of+Context.aspx">services and reuse</a>. More to the point, I posted why I don&#8217;t believe that business services will be reusable, any more than business objects were reusable. However, &#8220;can&#8217;t reuse business services&#8221; isn&#8217;t the whole story, because I believe in different kinds of reuse.</p>
<p>The kind of reuse I was writing about yesterday is typically referred to as&nbsp;&#8220;black box reuse&#8221;. The idea being that I can reuse&nbsp;the item (object or service) with little or no understanding of how it works. Thomas Beck <a href="http://www.beckshome.com/PermaLink,guid,7b0aa555-c37a-44e9-baf3-b69f6b1efc30.aspx">wrote about colored boxes</a> on his blog yesterday. Context impacts reuse &#8211; the environments in which you plan to reuse an item must be compatible with what the item expects. However, those contextual requirements aren&#8217;t written down anywhere &#8211; at least, they&#8217;re not encoded anywhere in the item&#8217;s interface. Those contextual requirements are buried in the code &#8211; the code you&#8217;re not supposed to look at because we&#8217;re striving for black box reuse. Opaque Requirements == No Possibility of Reuse. </p>
<p>As I wrote yesterday, David Chappell <a href="http://www.davidchappell.com/HTML_email/Opinari_No16_8_06.html">tears this type of reuse apart</a> fairly adeptly. Money quote: &#8220;Creating services that can be reused requires predicting the future&#8221;. But black box reuse this isn&#8217;t the only kind of reuse. It&#8217;s attractive, since it&#8217;s simple. At least it would be, if it actually worked.&nbsp;So what kind of reuse <em>doesn&#8217;t</em> require predicting the future? </p>
<p>Refactoring. </p>
<p>I realize most people probably don&#8217;t consider refactoring to be reuse. But let&#8217;s take a look at the official definition from <a href="http://refactoring.com/">refactoring.com</a>:</p>
<blockquote><p>Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior. Its heart is a series of small behavior preserving transformations. Each transformation (called a &#8216;refactoring&#8217;) does little, but a sequence of transformations can produce a significant restructuring. Since each refactoring is small, it&#8217;s less likely to go wrong. The system is also kept fully working after each small refactoring, reducing the chances that a system can get seriously broken during the restructuring</p>
</blockquote>
<p>Two things about this definition imply reuse. First, refactoring is &#8220;restructuring an existing body of code&#8221;. It&#8217;s not rewriting that existing body of code. You may be making changes to the code &#8211; this certainly isn&#8217;t black box reuse &#8211; but you&#8217;re not scrapping the code completely and starting over. Second, refactoring is making changes to the code &#8220;without changing its external behavior&#8221;. You care about the code&#8217;s external behavior because somewhere, some other code&nbsp;is calling the code you&#8217;re refactoring. Some other existing piece of code that you don&#8217;t&nbsp;want to change &#8211; i.e. that you want to reuse.</p>
<p>When you refactor, you still reuse a significant amount of the code, but you&#8217;re not having to predict the future to do it. Refactoring<i></i>is the kind of reuse I believe in. </p>
<p>In his article, David talks about types of reuse such as business agility, adaptability and easily changeable orchestration. These look a lot more like refactoring than black box reuse to me. Unfortunately, David waves these away, saying &nbsp;&#8220;Still, isn&#8217;t this just another form of reuse?&#8221;. Reconfiguration hardly qualifies as &#8220;predict the future&#8221; style reuse that he spends the rest of the article arguing against. It&#8217;s just one paragraph in an otherwise splendid article, so I&#8217;ll give him a pass this time. (I&#8217;m sure he&#8217;s relieved.)</p>
