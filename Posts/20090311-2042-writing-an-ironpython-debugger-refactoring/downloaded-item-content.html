<p>When we <a href="http://github.com/devhawk/ipydbg/blob/c33cf75c4e9273a21ada00abe2403c392e4ca0a0/ipydbg.py">last left</a> ipydbg, it was up to about 200 lines of code. Not bad in terms of overall length, but I started to detect some <a href="http://en.wikipedia.org/wiki/Code_smell">code smell</a>. I was relying pretty heavily on global variables and the structure of my code made it difficult to control how the debugger was run. I wanted to change ipydbg so it would automatically spin up an MTA thread if I forgot to add the &#8211;X:MTA command line parameter. But since by debugger and process objects were global, they&#8217;d get created on the main thread of ipydbg, regardless if it was STA or MTA. So for this &#8220;<a href="http://github.com/devhawk/ipydbg/tree/117cdce71a5ee8880e8bc991813534b6fba0a6d5">release</a>&#8221; (I&#8217;d say I&#8217;m almost to version 0.0.0.1), I decided on focusing on enginering and refactoring rather than new features. </p>
<p>The big new addition is the <a href="http://github.com/devhawk/ipydbg/blob/117cdce71a5ee8880e8bc991813534b6fba0a6d5/ipydbg.py#L90">IPyDebugProcess class</a>, which is clearly the workhorse of the application. All of the previously global variables are now class instance variables on IPyDebugProcess. Input and run along with all the event handlers as well as do_break_event and get_location are now class methods, as they need to access instance variables (setting the break event, accessing the symbol reader dictionary, etc.). Functions that didn&#8217;t need to access instance variables (get_sequence_points, create_breakpoint, get_dynamic_frames and get_method_info_for_frame) I left as top-level functions. If they get more complex, I may break them out into their own modules, but for now I left them in ipydbg.py.</p>
<p>The conversion process was fairly trivial. I had to add &#8220;self.&#8221; lots of places and change the indention level all over but that was pretty much it. Once I finished the conversion, I was able to add the run_debugger function to handle the thread creation, if necessary. </p>
<pre class="brush: python">def run_debugger(py_file):     
    if Thread.CurrentThread.GetApartmentState() == ApartmentState.STA:     
        t = Thread(ParameterizedThreadStart(run_debugger))     
        t.SetApartmentState(ApartmentState.MTA)     
        t.Start(py_file)     
        t.Join()    
    else:     
        p = IPyDebugProcess()     
        p.run(py_file)     

if __name__ == &quot;__main__&quot;:         
    run_debugger(sys.argv[1])
</pre>
<p>Originally, I tried to put this logic in IPyDebugProcess.run. However, since I&#8217;m <a href="http://github.com/devhawk/ipydbg/blob/117cdce71a5ee8880e8bc991813534b6fba0a6d5/ipydbg.py#L92">creating the debugger object</a> in the __init__ function, that meant it would be created on the wrong thread. I could have moved the debugger creation to the run method or move the thread management code to __init__, but I decided to factor that logic into a separate function completely. Felt cleaner that way.</p>
