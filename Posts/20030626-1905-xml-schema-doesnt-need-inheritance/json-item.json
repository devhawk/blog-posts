{"status":"ok","post":{"id":138,"type":"post","slug":"xml-schema-doesnt-need-inheritance","url":"http:\/\/devhawk.net\/2003\/06\/26\/xml-schema-doesnt-need-inheritance\/","status":"publish","title":"XML Schema Doesn&#8217;t Need Inheritance","title_plain":"XML Schema Doesn&#8217;t Need Inheritance","content":"<p>Got a chance to talk to <a href=\"http:\/\/www.kuro5hin.org\/user\/Carnage4Life\/diary\">Dare<\/a> today about the XML vs. Objects stuff we&#8217;ve been blogging on. We started by talking about the convergence of objects, databases and XML. He mentioned a chapter of <a href=\"http:\/\/www.neward.net\/ted\/weblog\"> Tim Neward&#8217;s<\/a><a href=\"http:\/\/www.neward.net\/ted\/weblog\/index.jsp?date=20030217#1045470771101\"> Effective Enterprise Java<\/a> book where Ted recommends designing the data first. Ted started Effective Enterprise Java 2 days before <a href=\"http:\/\/winisp.net\/harrypierson\">Patrick<\/a> was born so I haven&#8217;t been reading it. The issue with designing the data first is that typically, a developer is predisposed towards one of the three poles of data design (XML, objects or relational DB) that will color that design unintentionally.<\/p>\n<p>I realized I still lean towards OO when Dare pointed out the fact that XML (actually, I should say XSD) doesn&#8217;t really need derivation. Because of my OO background, it took me a while to digest that concept. But since XML is just data without behavior, it doesn&#8217;t need polymorphism the way that objects do. Consider the following schema:<\/p>\n<p><code> &lt;xs:complexType name=\"ctAddress\"&gt;<br \/> &lt;xs:sequence&gt;<br \/> &lt;xs:element name=\"Street\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"City\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"State\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"ZipCode\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:any namespace=\"##targetNamespace\" \/&gt;<br \/> &lt;\/xs:sequence&gt;<br \/> &lt;\/xs:complexType&gt;<\/code>\n<p>This is version one of the address complex type schema for some arbitrary web service. Over time, we realize that we want to be more global in our addressing schema, so we want to add a country element. Since not all of the other services we interact with will be updating to the new schema, we need to make country an option element (i.e. minOccurs=&#8221;0&#8243;). While we could use schema inheritance to do this, we could also just duplicate the existing elements and add a country element: <\/p>\n<p><code> &lt;xs:complexType name=\"ctAddress\"&gt;<br \/> &lt;xs:sequence&gt;<br \/> &lt;xs:element name=\"Street\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"City\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"State\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"ZipCode\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"1\" \/&gt;<br \/> &lt;xs:element name=\"Country\" type=\"xs:string\" maxOccurs=\"1\" minOccurs=\"0\" \/&gt;<br \/> &lt;xs:any namespace=\"##targetNamespace\" \/&gt;<br \/> &lt;\/xs:sequence&gt;<br \/> &lt;\/xs:complexType&gt;<\/code><\/p>\n<p>What&#8217;s interesting is that even though these two schema types are not related by inheritance, I can still validate XML addresses against either schemas. In fact, XML addresses with and without addresses validate against <u><b>both<\/b><\/u> schemas! That&#8217;s difficult to model in a typing system where objects have a bound to a single specific type. Other types of changes can be introduced so that break validation to one of the schema but not the other. For example, if we changed the minOccurs of ZipCode to zero, all messages that validate to the first schema would also validate to the second, but the reverse would not always be true. This is like a IsA relationship in OO, but in the wrong direction (a base message &#8220;is a&#8221; derived message, but a derived message is not always a base message).<\/p>\n<p>The upshot of all this is that I think my argument against XML Serialization as a general concept is strengthened. While it does work in many scenarios, I can easily build XML messages and XSD schemas that don&#8217;t cleanly conform to an OO typing system. Since the flexibility in XML is critical (that&#8217;s what I&#8217;m using for loosely coupled public interop interfaces), I know I don&#8217;t want my schema design to be constrained to the limited set of scenarios that are supported by XML Serialization.<\/p>\n","excerpt":"<p>Got a chance to talk to Dare today about the XML vs. Objects stuff we&#8217;ve been blogging on. We started by talking about the convergence of objects, databases and XML. He mentioned a chapter of Tim Neward&#8217;s Effective Enterprise Java book where Ted recommends designing the data first. Ted started Effective Enterprise Java 2 days [&hellip;]<\/p>\n","date":"2003-06-26 19:05:53","modified":"2003-06-26 19:05:53","categories":[],"tags":[],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["a948e2d7-2627-470d-bff6-17618bc87594"],"dasblog_compressedtitle":["XML+Schema+Doesnt+Need+Inheritance"],"dasblog_compressedtitleunique":["2003\/06\/27\/XML+Schema+Doesnt+Need+Inheritance"]}},"previous_url":"http:\/\/devhawk.net\/2003\/06\/24\/yapnpp\/","next_url":"http:\/\/devhawk.net\/2003\/06\/26\/just-when-you-thought-it-was-safe\/"}