<p>One of the things I&#8217;ve always loved about ASP.NET is how easily extensible it is. Back in 2000, I had a customer that wanted to &#8220;skin&#8221; their website using XML and XSLT &#8211; an approach Martin Fowler later called <a href="http://martinfowler.com/eaaCatalog/transformView.html">Transform View</a>. We were working with classic ASP at the time, so the solution we ended up with was kind of ugly. But I was able to implement this approach in ASP.NET in a few hundred lines of code, which I wrote up in <a href="http://msdn.microsoft.com/en-us/magazine/dvdarchive/cc164164.aspx">an MSDN article</a> published back in 2003. In the conclusion of that article, I wrote the following:</p>
<blockquote><p>Using ASP.NET is kind of like having your mind read. If you ever look at a site and think &#8220;I need something different,&#8221; you&#8217;ll most likely find that the ASP.NET architects have considered that need and provided a mechanism for you to hook in your custom functionality. In this case, I&#8217;ve bypassed the built-in Web Forms and Web Services support to build an entire engine that services Web requests in a unique way.</p>
</blockquote>
<p>Nearly ten years later, I finally ran into a situation where ASP.NET failed to read my mind and doesn&#8217;t provide a mechanism to hook in custom functionality: Global.asax.</p>
<p>I always thought of global.asax as an obsolete construct primarily intended to ease migration from classic ASP. After all, ASP.NET has first class support for customizing request handling at various points throughout the execution pipeline via <a href="http://msdn.microsoft.com/en-us/library/system.web.ihttpmodule.aspx">IHttpModule</a>. Handling those events in global.asax always felt vaguely hacky to me. </p>
<p>However, what I didn&#8217;t realize is that there are some events that can only be handled via global.asax (or its code behind). In particular, Application_Start/End and Session_Start/End can only be handled in global.asax. Worse, these aren&#8217;t true events. For reasons I&#8217;m sure made sense at the time but that I don&#8217;t understand, the HttpApplicationFactory discovers these methods via reflection rather than by an interface or other more typical mechanism. You can check it out for yourself with <a href="http://reflector.red-gate.com">Reflector</a> or the <a href="http://referencesource.microsoft.com/">Reference Source</a> &#8211; look for the method with the wonderful name ReflectOnMethodInfoIfItLooksLikeEventHandler. No, I&#8217;m not making that up.</p>
<p>The reason I suddenly care about global.asax is because Application_Start is where ASP.NET MVC apps configure their route table. But if you want to access the Application_Start method in a dynamic language like IronPython, you&#8217;re pretty much out of luck. The only way to receive the Application_Start pseudo-event is via a custom HttpApplication class. But you can&#8217;t implement your custom HttpApplication in a dynamically typed language like IronPython since it finds the Application_Start method via Reflection. Ugh.</p>
<p>If someone can explain to me why ASP.NET uses reflection to fire the Application_Start event, I&#8217;d love to understand why it works this way. Even better &#8211; I&#8217;d love to see this fixed in some future version of ASP.NET. You come the only way to configure a custom HttpApplication class is to specify it via global.asax? Wouldn&#8217;t it make sense to specify it in web.config instead?</p>
<p>In order to support Application_Start for dynamic languages you basically have two choices:</p>
<ol>
<li>Build a custom HttpApplication class in C# and reference it in global.asax. This is kind of the approach used by Jimmy&#8217;s ironrubymvc project. He&#8217;s got a <a href="http://github.com/jschementi/ironrubymvc/blob/939319febe205a43d6837e50fe3fe4740708fd58/IronRubyMvc/Core/RubyMvcApplication.cs">RubyMvcApplication</a> which he inherits his <a href="http://github.com/jschementi/ironrubymvc/blob/939319febe205a43d6837e50fe3fe4740708fd58/IronRubyMvcWeb/Global.asax.cs">GlobalApplication</a> from. Given that GlobalApplication is empty, I think he could remove his global.asax.cs file and just reference RubyMvcApplication from global.asax directly. </li>
<li>Build custom Application_Start/End-like events out of IHttpModule Init and Dispose. You can have multiple IHttpModule instances in a given web app, so you&#8217;d need to make sure you ran fired Start and End only once. This is the approach taken by the <a href="http://aspnet.codeplex.com/Wiki/View.aspx?title=Dynamic%20Language%20Support">ASP.NET Dynamic Language Support</a>. [1] </li>
</ol>
<p>So here&#8217;s the question Iron Language Fans: Which of these approaches is better? I lean towards Option #1, since it traps exactly the correct event though it does require a global.asax file to be hanging around (kind of like how the ASP.NET MVC template has a blank default.aspx file &#8220;to ensure that ASP.NET MVC is activated by IIS when a user makes a &#8220;/&#8221; request&#8221;). But I&#8217;m curious what the Iron Language Community at large thinks. Feel free to leave me a comment or <a href="mailto:harry.pierson@microsoft.com">drop me an email</a> with your thoughts.</p>
<hr>
<p>[1] FYI, I&#8217;m working on getting the code for ASP.NET Dynamic Language Support released. In the meantime, you can verify what I&#8217;m saying via Reflector.</p>
