{"status":"ok","post":{"id":837,"type":"post","slug":"transactions-in-workflow-foundation-land","url":"http:\/\/devhawk.net\/2006\/12\/11\/transactions-in-workflow-foundation-land\/","status":"publish","title":"Transactions in Workflow Foundation-land","title_plain":"Transactions in Workflow Foundation-land","content":"<p>I&#8217;ve been spending some quality time\u00a0with SSB and WF of late. On the balance, my opinion of both these technologies is very positive, though each has some warts of note. For Service Broker, they got the\u00a0transactional messaging semantics right, but\u00a0much of the lower level connection management &#8211; what SSB calls &#8220;routes&#8221; are clumsy to deal with. For Workflow Foundation, the execution model is amazingly flexible. Unfortunately, WF&#8217;s support for transactions is significantly more rigid.<\/p>\n<p>If you&#8217;re build a SSB app, you&#8217;re typical execution thread looks like this:<\/p>\n<ol>\n<li>Start a transaction.  <\/li>\n<li>Receive message(s) from top of the queue.  <\/li>\n<li>Execute service business logic. Obviously, this varies from service to service but it typically involves reading and writing data in the database as well as sending messages to other services.  <\/li>\n<li>Commit the transaction<\/li>\n<\/ol>\n<p>When I sat down to marry SSB and WF, I naively assumed I could simply use WF for step three above. Alas, that turns out to be impossible. <a href=\"http:\/\/forums.microsoft.com\/MSDN\/ShowPost.aspx?PostID=843580&amp;SiteID=1\">This thread<\/a> on MSDN Forums has most of the gory details, but the short version is that WF does not support flowing host managed transactions into the workflow instance. As per <a href=\"http:\/\/forums.microsoft.com\/MSDN\/User\/Profile.aspx?UserID=154457&amp;SiteID=1\">Joel West<\/a>\u00a0in the aforementioned thread:<\/p>\n<blockquote><p>&#8220;[T]he WF runtime in V1 only supports flowing in a transaction on WorkflowInstance.Unload. There are various ways that you could try and hack this (with a custom persistence service or WorkflowCommitWorkBatchService) but if you do this it won&#8217;t work correctly 100% of the time and the times when it fails (error conditions or failures causing the tx to rollback) will be exactly when you are expecting transactional consistency.<\/p>\n<p>Bottom line &#8211; the only way to make this work is to call WorkflowInstance.Unload inside your transaction scope.\u00a0 This\u00a0was the best that we could do in V1 to try and enable this pattern in some form.\u00a0 Not always ideal but it can be made to work for most scenarios that require usage of an external transaction.&#8221;<\/p>\n<\/blockquote>\n<p>So the WF compatible execution thread looks like this:  <\/p>\n<ol>\n<li>Start a transaction  <\/li>\n<li>Receive message(s) from the top of the queue  <\/li>\n<li>Load\/Create the associated workflow instance for the received messages\n<ul>\n<li>All messages received are guaranteed to be from the same SSB conversation group, which is roughly analogous to a WF instance, so this turns out to be fairly easy<\/li>\n<\/ul>\n<\/li>\n<li>Enqueue the received message in the workflow instance  <\/li>\n<li>Unload the workflow instance  <\/li>\n<li>Commit the host transaction <\/li>\n<li>Reload the workflow instance  <\/li>\n<li>Run the workflow instance (note, I&#8217;m using the manual scheduling service)\n<ul>\n<li>Workflow instance creates a transaction if\u00a0needed<\/li>\n<\/ul>\n<\/li>\n<li>Unload the workflow instance (typically done via UnloadOnIdle in the persistence service)<\/li>\n<ul>\n<li>Assuming the workflow instance needed a transaction, it gets committed after unload<\/li>\n<\/ul>\n<\/ol>\n<p>Basically, you use two transactions. One host managed transaction to move the message from SSB to WF instance and one WF managed transaction to process the message.The need for two transaction instead of one is unfortunate, but required given the current design of WF. And frankly, given the importance and difficulty of transaction management, I&#8217;m not that surprised that WF has hard coded transaction semantics. Trying to build a generic transaction flow model that would work in the myriad of scenarios WF is targeting would have been extremely difficult. At least there is a work around, even if it means using two transactions and loading and unloading the workflow instance twice.<\/p>\n<p>However, there is a silver lining to the two transaction approach: two unexpected benefits when dealing with poison messages. First, SSB doesn&#8217;t have dead letter queue like MSMQ does. Moving a poison message to a dead letter queue would break SSB&#8217;s exactly once and in order semantics.(MSMQ doesn&#8217;t guarantee in order delivery) But moving all messages into the WF instance gets them out of the main SSB queue so poison messages don&#8217;t continue to get processed over and over. <\/p>\n<p>Second, because the workflow instance is peristed after the messages are enqueued, there&#8217;s a representation of the workflow after the message is received but before the message is processed. If there&#8217;s a poison message, attempting to processing the message will fail and rollback to this state. This persisted workflow instance could be sent to a developer who could step through it to determine the cause of the error. We could even have developer versions of runtime workflow services so we could read remote data and simulate data updates. I wouldn&#8217;t want the developer updating production data in this way, but it would be great for troubleshooting issues.<\/p>\n","excerpt":"<p>I&#8217;ve been spending some quality time\u00a0with SSB and WF of late. On the balance, my opinion of both these technologies is very positive, though each has some warts of note. For Service Broker, they got the\u00a0transactional messaging semantics right, but\u00a0much of the lower level connection management &#8211; what SSB calls &#8220;routes&#8221; are clumsy to deal [&hellip;]<\/p>\n","date":"2006-12-11 14:58:26","modified":"2006-12-11 14:58:26","categories":[],"tags":[{"id":320,"slug":"service-broker","title":"Service Broker","description":"","post_count":14},{"id":268,"slug":"wf","title":"WF","description":"","post_count":21}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2436,"name":"Tomas Restrepo","url":"http:\/\/www.winterdom.com\/weblog","date":"2006-12-11 16:11:51","content":"<p>The WF transaction model makes more sense if you come from a BizTalk background (like me), because BizTalk has essentially the same restriction. <\/p>\n<p>That said, BizTalk is far, far more flexible in its transaction facilities, but you still have to remember that message receive and send operations operate in completely separate transactions from orchestrations. However, this is improved in BizTalk because you have the MessageBox right in the middle of the messaging engine and the orchestration engine which makes implementing your kind of scenario completely natural even under the two-transaction separation.<\/p>\n<p>I&#8217;m not quite sure I agree about the whole poison message thingie, though. First of all, handling &#8220;real&#8221; poison messages (i.e. malformed ones that you really need to discard) requires breaking In-order delivery semantics if you hope to keep processing. The only way to avoid if the problematic message is important is to completely stop processing, fix the offending message(s) and resume processing. And this, I think, pretty much is all across the board (not specific to SSSB or MSMQ). <\/p>\n<p>Second, MSMQ does support in-order delivery, afaik, for *messages sent in the same transaction*. This is key because MSMQ doesn&#8217;t have the notion of a conversation\/dialog like SSSB does (though it&#8217;s certainly possible to implement it if you really want it). That said, I think you may be talking more about &#8220;in-order processing&#8221;, which is a completely different thing, and which you seem to be dismissing. I&#8217;m not quite sure why you&#8217;d care so much about in-order delivery if you&#8217;re not doing in-order processing after that (i.e. message 2 might finish processing before message-1 does), so that might be something to consider.<\/p>\n","parent":0},{"id":2437,"name":"DevHawk","url":"","date":"2006-12-12 09:17:56","content":"<p>I&#8217;m not very deep on BizTalk, but I&#8217;m working on it. That said, comparing the high-level TX capabilities of a product like BizTalk to the low-level TX capabilities of a technology like WF is an apples to oranges comparison. From what I understand about MessageBox, it sounds fairly similar to SSB, which would make a SSB\/WF implementation conceptually similar to BizTalk. But I need to learn much more about BizTalk.<\/p>\n<p>I agree 100% that dealing with poison messages need to be fixed before you can resume processing. But the silver lining of the two transaction approach to SSB &#038; WF is that you&#8217;re only stalling the instance with the poision message. If you left the poison message in the SSB queue, it would keep getting picked up until and throwing an exception until an operator came along to do something. If you move it to WF, then it will only effect the instance that message is intended for.<\/p>\n<p>I&#8217;m not dismissing in-order processing at all. It&#8217;s one of the primary values of SSB in my opinon. Assuming WF doesn&#8217;t reorder messages in a queue, moving them from SSB to WF wouldn&#8217;t break the in order semantics.<\/p>\n","parent":0},{"id":2438,"name":"Tomas Restrepo","url":"http:\/\/www.winterdom.com\/weblog","date":"2006-12-12 20:06:38","content":"<p>Harry,<\/p>\n<p>I just realized I misread your original post and didn&#8217;t notice that you were delivering all messages in a single conversation group to a single workflow instance. In that case, you&#8217;re probably maintaining ordered processing. FWIW, seems you&#8217;re implementing the kind of solution that is usually handled in Biztalk through a feature known as Convoys (look them up, the details might be useful to you at least for ideas, I think)<\/p>\n<p>BTW, the BizTalk MessageBox is far more than SSB, though they share some features, I think. Mostly, the MsgBox does not only queuing, it&#8217;s also the underlying Pub\/Sub and content-based routing engine in BizTalk. I do think it might be possible to implement the message box on top of SSB, and maybe the BizTalk team might explore that for possible performance improvements in future releases. <\/p>\n<p>And yes, I realize I&#8217;m a pita sometimes nagging about biztalk (but I do think for the kind of work you&#8217;re doing, knowing how biztalk manages some of it would prove useful).<\/p>\n","parent":0},{"id":2439,"name":"DevHawk","url":"","date":"2006-12-13 09:59:04","content":"<p>Don&#8217;t worry. I&#8217;m a PITA sometimes nagging about SSB! <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" alt=\":)\" class=\"wp-smiley\" \/> <\/p>\n","parent":0}],"attachments":[],"comment_count":4,"comment_status":"closed","custom_fields":{"dasblog_entryid":["e7b99068-8f9b-47cd-b5d2-e09d5d250ccc"],"dasblog_compressedtitle":["Transactions+In+Workflow+Foundationland"],"dasblog_compressedtitleunique":["2006\/12\/11\/Transactions+In+Workflow+Foundationland"]}},"previous_url":"http:\/\/devhawk.net\/2006\/12\/07\/streaky-caps\/","next_url":"http:\/\/devhawk.net\/2006\/12\/13\/good-week-for-hobbyists-and-students\/"}