{"status":"ok","post":{"id":1230,"type":"post","slug":"writing-an-ironpython-debugger-stepping-thru-code","url":"http:\/\/devhawk.net\/2009\/03\/13\/writing-an-ironpython-debugger-stepping-thru-code\/","status":"publish","title":"Writing an IronPython Debugger: Stepping Thru Code","title_plain":"Writing an IronPython Debugger: Stepping Thru Code","content":"<p>So far, I\u2019ve written seven posts about my IronPython debugger, but frankly it isn\u2019t very functional yet. It <a href=\"http:\/\/devhawk.net\/2009\/02\/28\/Writing+An+IronPython+Debugger+Hello+Debugger.aspx\">runs<\/a>, <a href=\"http:\/\/devhawk.net\/2009\/03\/02\/Writing+An+IronPython+Debugger+Setting+A+Breakpoint.aspx\">breaks on the first line<\/a> and can <a href=\"http:\/\/devhawk.net\/2009\/03\/09\/Writing+An+IronPython+Debugger+Dynamic+Stack+Trace.aspx\">show a stack trace<\/a>. Not exactly <a href=\"http:\/\/www.joltawards.com\/\">Jolt award<\/a> material. In this post, I\u2019m going to add one of the core functions of any debugger: stepping. Where previously I\u2019ve written a bunch of code but had little to show in terms of features, now I\u2019m getting three new features (basic step, step in and step out) at once!<\/p>\n<pre class=\"brush: python\">\ndef _input(self):     \n  #remaining _input code omitted for clarity\n  elif k.Key == ConsoleKey.S:     \n      print \"nStepping\"\n      self._do_step(False)     \n      return\n  elif k.Key == ConsoleKey.I:     \n      print \"nStepping In\"\n      self._do_step(True)     \n      return                 \n  elif k.Key == ConsoleKey.O:     \n      print \"nStepping Out\"\n      stepper = create_stepper(self.active_thread)     \n      stepper.StepOut()     \n\ndef _do_step(self, step_in):     \n  stepper = create_stepper(self.active_thread)     \n  mod = self.active_thread.ActiveFrame.Function.Module     \n  if mod not in self.symbol_readers:     \n      stepper.Step(step_in)     \n  else:     \n    range = get_step_ranges(self.active_thread, self.symbol_readers[mod])     \n    stepper.StepRange(step_in, range)\n<\/pre>\n<p>Here you can see the _input clauses for step, step in and step out. Of the three, step out is the simplest to implement: create the stepper object and call StepOut. For step and step in, I could simply call Step (the boolean argument indicates if you want to step into or over functions) but that only steps a single IL statement. The vast majority of the time there are multiple IL instructions for every line of source code, so IL statement stepping is very tedious. As we learned when <a href=\"http:\/\/devhawk.net\/2009\/03\/02\/Writing+An+IronPython+Debugger+Setting+A+Breakpoint.aspx\">setting a breakpoint<\/a>, debug symbols contain sequence points that map between source and IL locations. If they\u2019re available, I use the sequence points to determine the range of IL statements to step over so that I can step single source statements instead. <\/p>\n<p>The stepping code above depends on three helper functions defined at global scope.<\/p>\n<pre class=\"brush: python\">\ndef create_stepper(thread):     \n  stepper = thread.ActiveFrame.CreateStepper()     \n  stepper.SetUnmappedStopMask(CorDebugUnmappedStop.STOP_NONE)     \n  return stepper  \n   \ndef create_step_range(start, end):     \n  range = Array.CreateInstance(COR_DEBUG_STEP_RANGE, 1)     \n  range[0] = COR_DEBUG_STEP_RANGE(startOffset = UInt32(start),     \n                                  endOffset = UInt32(end))     \n  return range     \n   \ndef get_step_ranges(thread, reader):     \n    frame = thread.ActiveFrame     \n    offset, mapResult = frame.GetIP()     \n    method = reader.GetMethod(SymbolToken(frame.FunctionToken))     \n    for sp in get_sequence_points(method):     \n        if sp.offset &gt; offset:     \n            return create_step_range(offset, sp.offset)     \n    return create_step_range(offset, frame.Function.ILCode.Size)\n<\/pre>\n<p>The first function, create_stepper, simply constructs and configures the stepper object. The call to SetUnmappedStopMask tells the debugger not to stop if it encounters code that can\u2019t be mapped to IL. If you need to debug at that level, ipydbg is *not* for you.<\/p>\n<p>Next is create_step_range, which exists purely for .NET interop purposes. There are three interop warts hidden in this function. First is creating a .NET array of COR_DEBUG_STEP_RANGE structs. Every time I write Array code like this, I wish for a CreateFromCollection static method on Array. However, in this case it isn\u2019t that big a deal since it\u2019s a one element array. Second wart is having to set the values of COR_DEBUG_STEP_RANGE via constructor keyword arguments. It turns out that IronPython disallows direct updates to value type fields (<a href=\"http:\/\/ironpython.codeplex.com\/Wiki\/View.aspx?title=Value%20Types\">read this for the reason why<\/a>). Instead, I pass in the field values into the constructor as keyword arguments. Finally, you have to explicitly convert the start and end offsets to a unsigned int in order to set the offset fields in the COR_DEBUG_STEP_RANGE struct constructor.<\/p>\n<p>Finally is get_step_ranges, which iterates thru the list of sequence points in the current method looking for the one with the smallest offset that is larger than the current offset position. If it can\u2019t find a matching sequence point, it sets the range to the end of the current function. The start range offset is always the current offset. I did make a significant change to get_sequence_points \u2013 it no longer yields sequence points that have a start line of 0xfeefee. <a href=\"http:\/\/blogs.msdn.com\/jmstall\/archive\/2005\/06\/19\/FeeFee_SequencePoints.aspx\">By convention<\/a>, that indicates a sequence point to be skipped. Originally, the logic to ignore 0xfeefee sequence points was in get_location. But when I originally wrote get_step_ranges, it had essentially the same sequence point skipping logic, so I moved it to get_location instead.<\/p>\n<p>Technically, I\u2019ve built three new features but the reality is that if you end up in IronPython infrastructure code it\u2019s really hard to find your way back to python code. Step in is particularly useless right now. Luckily, the .NET debugger API supports a feature called \u201c<a href=\"http:\/\/blogs.msdn.com\/jmstall\/archive\/2004\/12\/31\/344832.aspx\">Just My Code<\/a>\u201d that will make stepping much more useful. In the meantime, the <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/tree\/0840b8cf3918feb70311bc0d0a8e0cb0f06fc37c\">latest version of ipydbg<\/a> is up on GitHub as usual.<\/p>\n","excerpt":"<p>So far, I\u2019ve written seven posts about my IronPython debugger, but frankly it isn\u2019t very functional yet. It runs, breaks on the first line and can show a stack trace. Not exactly Jolt award material. In this post, I\u2019m going to add one of the core functions of any debugger: stepping. Where previously I\u2019ve written [&hellip;]<\/p>\n","date":"2009-03-13 10:31:17","modified":"2009-03-13 10:31:17","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["be843f79-26c2-4593-95ae-b271fe4442b3"],"dasblog_compressedtitle":["Writing+An+IronPython+Debugger+Stepping+Thru+Code"],"dasblog_compressedtitleunique":["2009\/03\/13\/Writing+An+IronPython+Debugger+Stepping+Thru+Code"]}},"previous_url":"http:\/\/devhawk.net\/2009\/03\/12\/vb-dev-lead-position-open\/","next_url":"http:\/\/devhawk.net\/2009\/03\/13\/writing-an-ironpython-debugger-debugging-just-my-code\/"}