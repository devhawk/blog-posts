<p></p>
<p><em>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that&#8217;s turned out to be infeasible. So instead, you get a series of pre-written posts about F#.)</em></p>
<p>It&#8217;s not all puppy dogs and ice cream with F#. Here are a few things that I didn&#8217;t like about the lanugage.</p>
<h3>Linear Scoping</h3>
<p>In C#, a given piece of code is able to call any function it wants to (limited by CAS and visibility of course). If I define two functions, the first can call the second even thought the compiler has never seen the second function when it&#8217;s parsing the first.</p>
<p>F# has linear scoping like C++ does. You can&#8217;t call functions that haven&#8217;t already been defined in the file (or a previous file that&#8217;s already been fed to the compiler). This makes writing mutually recursive functions (A calls B, B calls C, C calls A) fairly annoying. Typically, in F# we declare functions with &#8220;let&#8221;. But in the Additive function above, we&#8217;re declaring the function with &#8220;and&#8221;. By using &#8220;and&#8221;, we&#8217;re basically chaining together function declarations into a logical unit. Then, you mark the first function declaration in the chain as recursive, and now those methods are enabled for mutual recursion. Not exactly intuitive.</p>
<p>Frankly, I like C#&#8217;s ability to bind to methods that haven&#8217;t been declared yet. I wonder if this is an intrinsic issue with FP or F# scoping rules, or if it&#8217;s something they could fix if they took the time.</p>
<h3>No Method Overloading</h3>
<p>In my CheckForToken method, I use a string type to hold the token I&#8217;m looking for, since tokens can often be multi-character. However, for one character tokens, this is over kill. Not just in terms of creating a string object to contain just one character, but also in how I pattern match the token against the input string. If we&#8217;re only looking for one character, we can skip recursion entirely. Yet there&#8217;s no way to define two functions called Token that have different signatures. </p>
<p>Given type inference, this isn&#8217;t surprising, but it&#8217;s still a little annoying for folks coming from C# land.</p>
<h3>Limited VS support</h3>
<p>More evidence of a rotted brain. F#&#8217;s integration into VS is limited at best. It does syntax highlighting and debugging, but that&#8217;s about it. The problem I keep running into is that I have two projects &#8211; my main project and my test project. Even though I&#8217;ve define the test project as being dependent on the main project, it doesn&#8217;t automatically compile the test project when I change the main project. So I keep doing something like fix a bug, recompile, then run NUnit to see if the light turned green. It doesn&#8217;t, because I haven&#8217;t rebuilt the test project and it&#8217;s still referencing the old version of the main project. Now that it&#8217;s a <a href="http://blogs.msdn.com/dsyme/archive/2007/10/17/s-somasegar-on-taking-f-forward.aspx">&#8220;real&#8221; product</a>, I&#8217;m hoping to see better integration into VS08. Maybe even an F# Express that leverages the new VS08 shell?</p>
