<p>Following up on my <a href="PermaLink.aspx?guid=5643b052-f1f2-4c53-ac33-e33d0910f917">XML is not a Deserialized Object Graph</a> post, I was thinking about entity classes from <a href="http://www.rational.com/products/rup/index.jsp">RUP</a>. The official definition (from the <a href="http://www.amazon.com/exec/obidos/ASIN/0201571692/qid=1006990173/sr=1-1/ref=sr_1_10_1/104-0359585-4441512"> RUP manual</a>) for entity classes is: &#8220;An entity class is used to model information that is long-lived and often persistent&#8221; &#8211; i.e. stuff we&#8217;re going to stick in the database, XML files, etc. In weblog terms, entities are posts, comments, trackbacks, etc. In my experience, these entity classes have little business logic &#8211; mostly validation code. The code that will act on this entity are encapsulated within control classes. Control classes are tightly related to use cases. Typically, a one-to-one relationship between use case and control class is a good first order approximation. Again, in weblog terms, the &#8220;create post&#8221; use case would be implemented as a control class that takes an entity class instance and writes it to the persistent store (database, XML file, etc)</p>
<p>If the vast majority of business logic goes into control classes while the entity classes are primarily data containers, why can&#8217;t we just go all the way and make our entity classes conform to the <a href="http://www.w3.org/TR/xml-infoset/">XML Infoset</a>? Expose them via XmlReader/Writer or XPathNavigator (and some as yet undefined interface XPathUpdatable). This way we&#8217;ll have parity between the entity classes local to our application and the XML messages we send and receive as we interact with other web services. XML serialization attempts to do this by unifying everything as strongly typed objects. But I&#8217;d rather unify around infoset, since that&#8217;s what&#8217;s going to be consistent across platforms, vendors and technologies, rather than typing systems. </p>
