<a href="http://www.odetocode.com/blogs/scott/">Scott Allen</a><a href="http://devhawk.net/CommentView,guid,325fc7b2-6102-435a-ae94-6e2686e6889f.aspx#commentstart">pointed out</a> that if you need to declare top level properties in a XAML only workflow, you can subclass the root activity class, add the properties you want, then specify the custom subclass in the XAML workflow. That doesn't really solve my problem. I'm trying to limit to activity vocabulary that the workflow author has access to. If they can specify their own custom type as the root activity of their workflow, they can also add whatever execution logic they want, which is what I'm trying to avoid.

There is an example in the Advanced Authoring chapter of <a href="http://dharmashukla.com/essential-wf-page/">Essential WF</a> where they describe building a root activity class that generate top level properties as part of the workflow compilation process. The root activity (in the example, it's called "SequenceWithVars") where you can specify the top level parameters in the XAML. Here's an example from the book:
<div style="font-family: Courier New;">
<pre class="brush:xml">&lt;SequenceWithVars x:Class="Workflow1" xmlns="..." xmlns:x="..."&gt;

<!-- Remaining workflow XAML goes here --></pre>
The SequenceWithVars type includes a custom <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.componentmodel.compiler.activitycodegenerator.aspx">ActivityCodeGenerator</a> that loops thru the VariableDecls collection and adds a top-level property (via <a href="http://msdn2.microsoft.com/en-us/library/system.codedom.aspx">CodeDOM</a>) for each VariableDecl instance. You end up with a workflow class that looks like this:

</div>
<div style="font-family: Courier New;">

<span style="font-size: 16px; font-family: Georgia, 'Bitstream Charter', serif; line-height: 24px;"> </span>
<pre class="brush:csharp">public partial class Workflow1 : SequenceWithVars
{
  public static DependencyProperty OrderProcConversationProp =
    DependencyProperty.Register("OrderProcConversation",
      typeof(Guid), typeof(Workflow1)); 

  public Guid OrderProcConversation
  {
    get 
    { 
      return (Guid)base.GetValue(Workflow1.OrderProcConversationProp); 
    }
    set 
    { 
      base.SetValue(Workflow1.OrderProcConversationProp, value); 
    }
  }

  //Remaining WF type declaration goes here
}</pre>
In order to use the XAML workflow with the SequenceWithVars activity, you do need to <a href="http://msdn2.microsoft.com/en-us/library/ms734733.aspx">compile</a> the XAML first using the <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.componentmodel.compiler.workflowcompiler.aspx">WorkflowCompiler</a> class. <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.componentmodel.compiler.workflowcompiler.compile.aspx">WorkflowCompiler.Compile()</a> returns a compiled type which can then be passed to <a href="http://msdn2.microsoft.com/en-us/library/ms594868.aspx">CreateWorkflow</a>. But adding the separate compile step is a small price to pay, in my opinion. This approach lets me limit the workflows to XAML only while still allowing for top level properties which are needed in many data binding scenarios.

</div>
<em><span style="text-decoration: underline;">Update</span></em>: removed syntax highlighting because it looked bad in my news reader.

<em><span style="text-decoration: underline;">Later Update</span></em>: Fixed syntax highlighting.