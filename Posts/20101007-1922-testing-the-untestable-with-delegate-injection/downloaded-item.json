{"status":"ok","post":{"id":1304,"type":"post","slug":"testing-the-untestable-with-delegate-injection","url":"http:\/\/devhawk.net\/2010\/10\/07\/testing-the-untestable-with-delegate-injection\/","status":"publish","title":"Testing the Untestable with Delegate Injection","title_plain":"Testing the Untestable with Delegate Injection","content":"<p>My ASP.NET skills may be a bit rusty, but that\u2019s not stopping me from working on a side project in ASP.NET MVC. While it has made significant strides in the 4.0 release, code like this demonstrates that ASP.NET still has a long way to go to improve testability.<\/p>\n<pre class=\"brush: csharp\">\npublic class AccountController : Controller\n{\n    ITwitterService _twitter;\n\n    \/\/constructor dependency injection\n    public AccountController(ITwitterService twitterService)\n    {\n        _twitter = twitterService;\n    }\n\n    public ActionResult SignInWithTwitter()\n    {\n        \/\/check for GetRedirectUrl and sets cookie\n        Response.SetCookie(new HttpCookie(\"RedirectUrl\",\n            FormsAuthentication.GetRedirectUrl(string.Empty, false)));\n\n        \/\/build callback URL\n        var callback_url_builder = new UriBuilder()\n        {\n            Host = Request.ServerVariables[\"SERVER_NAME\"],\n            Port = int.Parse(Request.ServerVariables[\"SERVER_PORT\"]),\n            Path = Url.Action(\"SignInWithTwitterCallback\"),\n        };\n\n        \/\/Helper funciton to invoke Twitter\u2019s oauth\/request_token REST endpoint\n        var url = _twitter.GetRequestToken(callback_url_builder.ToString());\n\n        \/\/redirect to the URL returned from _twitter.GetRequestToken\n        return Redirect(url);\n    }\n<\/pre>\n<p>This code has several dependencies that are hard or impossible to test: FormsAuthentication, Request, Response and Url. Testing this code is a real pain in the ass. When I originally wrote this code, I bit the bullet and wrote said the PITA test code. But I couldn\u2019t help thinking there must be a better way. <\/p>\n<p>Clearly, in order to be able to test this code, I need to introduce points of abstraction that can be filled with mock implementations during unit test runs. I already have one such abstraction point &#8211; the _twitter field of AccountController is an ITwitterService instance that gets injected on construction. I have a \u201creal\u201d implementation that gets injected in production and a mock implementation that I manually inject in my tests.<\/p>\n<p>In order to test the code above, I\u2019ll need to wrap the calls into the untestable objects in some sort of injectable dependency that can be mocked out for tests.<\/p>\n<p>C# being an OO language, typically we think of Dependency Injection in terms interfaces and classes. However, wrapping the untestables in interfaces and then implementing those interfaces is a lot of additional code. Instead of one injected dependency, the code above would need five injected dependencies. Furthermore, since objects are both the unit of dependency injection as well as the typical way the URL namespace is segmented, I also have to consider the dependencies of any other action methods on AccountController. That gets ugly fast.<\/p>\n<p>Instead of thinking in terms of objects and interfaces, I wondered what DI might look like if we thought about dependencies in terms of delegates and anonymous lambdas? You know, <a href=\"http:\/\/devhawk.net\/2007\/12\/05\/Functional+Understanding.aspx\">functional programming<\/a>?\u00a0 It might look something like this: <\/p>\n<pre class=\"brush: csharp\">\nFunc&lt;string&gt; @GetRedirectUrl;\nAction&lt;HttpCookie&gt; @SetCookie;\nFunc&lt;NameValueCollection&gt; @ServerVariables;\nFunc&lt;string, string&gt; @ActionUrl;\n\npublic ActionResult SignInWithTwitter()\n{\n    \/\/check for GetRedirectUrl and sets cookie\n    @SetCookie(new HttpCookie(\"RedirectUrl\", @GetRedirectUrl()));\n\n    \/\/build callback URL\n    var callback_url_builder = new UriBuilder\n    {\n        Host = @ServerVariables()[\"SERVER_NAME\"],\n        Port = int.Parse(@ServerVariables()[\"SERVER_PORT\"]),\n        Path = @ActionUrl(\"SignInWithTwitterCallback\"),\n    };\n\n    \/\/Call twitter.GetRequestToken\n    var url = _twitter.GetRequestToken(callback_url_builder.ToString());\n\n    \/\/redirect to the URL returned from Twitter.GetRequestToken\n    return Redirect(url);\n}\n<\/pre>\n<p>(Note, I&#8217;m using the @ symbol as a prefix for injected delegates, in order to make it easier to pick them out of the code. Looks kinda odd, but it is valid C#.)<\/p>\n<p>This is better in that it\u2019s actually testable without requiring a metric crapload of test code to mock the ASP.NET intrinsics. However, this approach don\u2019t have enough information to inject dependencies based on type alone. For example, the @GetRedirectUrl is a Func&lt;string&gt; (i.e. a function that takes no parameters and returns a string). However, FormsAuth FormsCookieName and DefaultUrl properties would also be represented as Func&lt;string&gt; delegates as well. <\/p>\n<p>Most DI containers have support resolving dependencies by name and type, but that makes declaring dependencies much tougher and more fragile in my opinion. If you\u2019re going to <strike>limit yourself to static typing<\/strike> write compiled code, you might as well let the compiler do as much heavy lifting as possible, right?<\/p>\n<p>Also, wrapping each untestable method call in a delegate has made the explosion of dependencies problem even worse. SignInWithTwitter declares four new dependencies, the callback action (not shown) adds seven new delegate dependencies and the sign out action adds one, making a total of thirteen dependencies! (including the original ITwitterService). However, none of these twelve delegate dependencies are shared across action methods. So they aren\u2019t really controller dependencies so much as action dependencies. So what if I went ahead and declared them as action dependencies directly?<\/p>\n<pre class=\"brush: csharp\">\npublic Func&lt;ActionResult&gt; SignInWithTwitter(\n    Func&lt;string&gt; @GetRedirectUrl,\n    Action&lt;HttpCookie&gt; @SetCookie,\n    Func&lt;NameValueCollection&gt; @ServerVariables,\n    Func&lt;string, string&gt; @ActionUrl)\n{\n    return () =&gt;\n    {\n        \/\/check for GetRedirectUrl and sets cookie\n        SetCookie(new HttpCookie(\"RedirectUrl\", GetRedirectUrl()));\n\n        \/\/build callback URL\n        var callback_url_builder = new UriBuilder\n        {\n            Host = ServerVariables()[\"SERVER_NAME\"],\n            Port = int.Parse(ServerVariables()[\"SERVER_PORT\"]),\n            Path = ActionUrl(\"LogOnCallback\"),\n        };\n\n        \/\/Call twitter.GetRequestToken\n        var url = _twitter.GetRequestToken(\n            callback_url_builder.ToString());\n\n        \/\/redirect to the URL returned from Twitter.GetRequestToken\n        return Redirect(url);\n    };\n}\n<\/pre>\n<p>SignInWithTwitter is now a function that takes four delegates and returns a delegate &#8211; we\u2019re really down the functional programming rabbit hole now! <\/p>\n<p>The benefit of this approach is that I can make tradeoffs as I see fit between controller and action dependencies. ITwitterService is still injected via the AccountController constructor since it is used by two of the three Account actions. Dependencies only used by a single action can be scoped to that specific action so that only tests for a given action method have to mock them out. And testing this is a breeze compared to <a href=\"http:\/\/www.hanselman.com\/blog\/ASPNETMVCSessionAtMix08TDDAndMvcMockHelpers.aspx\">having to mock out intrinsic ASP.NET objects<\/a>. <\/p>\n<pre class=\"brush: csharp\">\n[Fact]\npublic void returns_redirect_result_with_getrequesttoken_url()\n{\n    \/\/inject controller dependencies\n    var twitter = new Mock&lt;Models.ITwitterService&gt;(MockBehavior.Strict);\n    twitter.Setup(t =&gt; t.GetRequestToken(It.IsAny&lt;string&gt;()))\n        .Returns(\"http:\/\/fake.twittertest.local\");\n    var controller = new AccountController(twitter.Object);\n\n    \/\/inject action dependencies\n    Func&lt;string&gt; @getRedirectUrl = () =&gt; \"\/fake\/redirect\/url\";\n    Action&lt;HttpCookie&gt; @setCookie = c =&gt; { };\n    Func&lt;NameValueCollection&gt; @serverVariables = \n        () =&gt; new NameValueCollection() \n        {\n            {\"SERVER_NAME\", \"testapp.local\"},\n            {\"SERVER_PORT\", \"8888\"}\n        };\n    Func&lt;string, string&gt; @actionUrl = url =&gt; \"\/fake\/url\/action\/result\";\n    var action = controller.SignInWithTwitter(@getRedirectUrl, \n        @setCookie, @serverVariables, @actionUrl);\n\n    \/\/Invoke action\n    var result = action();\n\n    \/\/Validate\n    var redirectResult = Assert.IsType&lt;RedirectResult&gt;(result);\n    Assert.Equal(\"http:\/\/fake.twittertest.local\", redirectResult.Url);\n}\n<\/pre>\n<p>I could make this code even smaller by moving the action dependencies out to be test fixture class fields. Assuming you write multiple tests for each action method, this allows you to reuse the mock action delegates across multiple methods. If I want to do negative testing, I can easily define test-specific delegates that throw exceptions or return unexpected values.<\/p>\n<p>Of course, the down side to this approach is that MVC has *no* idea what to do with an action method that returns Func&lt;ActionResult&gt;. I could envision support for this pattern in MVC someday, though we\u2019d need a robust solution to the type+name dependency issue I described above. For now, I will simply wrap the delegate injection version (aka the testable version) of the action in a non-testable but MVC compatible version that injects the right delegate dependencies. <\/p>\n<\/p>\n<pre class=\"brush: csharp\">\npublic ActionResult SignInWithTwitter()\n{\n    return SignInWithTwitter(\n        () =&gt; FormsAuthentication.GetRedirectUrl(string.Empty, false),\n        Response.SetCookie,\n        () =&gt; Request.ServerVariables,\n        Url.Action)();\n}\n<\/pre>\n<p>Since I\u2019m using the untestable intrinsics, I can\u2019t write any tests for this method. However, it\u2019s nearly declarative because the anonymous delegates I\u2019m injecting are closing over the untestable intrinsics. Personally, I\u2019m willing to make the tradeoff of having an declarative yet untestable wrapper action method in order to get the delegate injected easy-to-test version of SignInWithTwitter that has the real implementation. <\/p>\n","excerpt":"<p>My ASP.NET skills may be a bit rusty, but that\u2019s not stopping me from working on a side project in ASP.NET MVC. While it has made significant strides in the 4.0 release, code like this demonstrates that ASP.NET still has a long way to go to improve testability. public class AccountController : Controller { ITwitterService [&hellip;]<\/p>\n","date":"2010-10-07 19:22:18","modified":"2010-10-07 19:22:18","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":178,"slug":"asp-net","title":"ASP.NET","description":"","post_count":27},{"id":296,"slug":"asp-net-mvc","title":"ASP.NET MVC","description":"","post_count":2},{"id":235,"slug":"c-sharp","title":"C#","description":"","post_count":17},{"id":202,"slug":"functional-programming","title":"Functional Programming","description":"","post_count":18},{"id":211,"slug":"unit-testing","title":"Unit Testing","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2306,"name":"Robert Seso","url":"","date":"2010-10-08 06:44:16","content":"<p>Hm&#8230;has a spaghetti code touch to it. Wouldn&#8217;t using a better mocking framework that can mock sealed ASP.NET classes (such as TypeMock or JustMock) be a simpler solution in this case? <\/p>\n","parent":0},{"id":2307,"name":"DevHawk","url":"","date":"2010-10-08 09:45:48","content":"<p>Using TypeMock or JustMock might be easier, but I don&#8217;t think they&#8217;re widely used due to their price tag. <\/p>\n<p>I&#8217;m curious why you think this is spaghetti. I mean, I get why this might feel strange if you&#8217;re not familiar with functional programming. But spaghetti to me is &#8220;complex and tangled control structure&#8221; (Wikipedia). The control structure here is very straightforward &#8211; one layer of abstraction in order to be able to test the untestable intrinsics.<\/p>\n","parent":0},{"id":2308,"name":"Robert Seso","url":"","date":"2010-10-08 12:05:30","content":"<p>Well, any problem in programming could be solved by adding layers of abstraction, but at one point or another those layers start generating more problems then they solve. It&#8217;s nothing to do with my understanding of functional programming, but in this case this is a clear overkill and I couldn&#8217;t imagine maintaining anything but simplest classes coded in this way. In addition, you can&#8217;t easily set expectations on delegates this way, e.g. test that certain delegate was called exactly X times, or that it was called with a certain input parameter etc.<\/p>\n<p>Yes, advanced mocking frameworks do cost some money, but they are well worth it and typically cost less than one day spent debugging overly complex code.<\/p>\n<p>Don&#8217;t get me wrong &#8212; I do find the concept very interesting. You might have a look at Event Based Components architecture which completely evolves around similar concepts.<\/p>\n","parent":0},{"id":2309,"name":"DevHawk","url":"","date":"2010-10-08 14:55:23","content":"<p>Mocking delegates will be supported in Moq v4 (<a href=\"http:\/\/code.google.com\/p\/moq\/issues\/detail?id=235\" rel=\"nofollow\">http:\/\/code.google.com\/p\/moq\/issues\/detail?id=235<\/a>) including support for testing that a certain delegate was called exactly X times or that it was called with certain input parameters, etc.<\/p>\n","parent":0}],"attachments":[],"comment_count":4,"comment_status":"closed","custom_fields":{"dasblog_entryid":["d978e50d-1158-4448-ab5e-c45d1ae8eb67"],"dasblog_compressedtitle":["Testing+The+Untestable+With+Delegate+Injection"],"dasblog_compressedtitleunique":["2010\/10\/08\/Testing+The+Untestable+With+Delegate+Injection"]}},"previous_url":"http:\/\/devhawk.net\/2010\/05\/17\/washington-stealth-lacrosse\/","next_url":"http:\/\/devhawk.net\/2011\/02\/02\/variadic-powershell-functions-with-optional-named-params\/"}