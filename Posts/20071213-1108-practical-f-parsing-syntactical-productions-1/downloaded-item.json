{"status":"ok","post":{"id":1075,"type":"post","slug":"practical-f-parsing-syntactical-productions-1","url":"http:\/\/devhawk.net\/2007\/12\/13\/practical-f-parsing-syntactical-productions-1\/","status":"publish","title":"Practical F# Parsing: Syntactical Productions (1)","title_plain":"Practical F# Parsing: Syntactical Productions (1)","content":"<p>Now that I have my <a href=\"http:\/\/devhawk.net\/2007\/12\/11\/Practical+F+Parsing+The+Parse+Buffer.aspx\" target=\"_blank\">parse buffer functions<\/a> and <a href=\"http:\/\/devhawk.net\/2007\/12\/12\/Practical+F+Parsing+Unit+Testing.aspx\" target=\"_blank\">unit test framework<\/a> taken care of, it&#8217;s time to write some parsing expression grammar productions [1]. In any grammar, there are productions that have semantic meaning and productions that are only used to specify syntax. For example, in C# statements end with a semicolon and code blocks are delineated with curly braces. Syntactical elements don&#8217;t end up in the abstract syntax tree, so they&#8217;re easier to implement.<\/p>\n<p>Most of PEG&#8217;s grammar productions are syntactical in nature. Let&#8217;s start with the simplest production, EndOfFile.<\/p>\n<pre class=\"brush:fsharp\">\/\/\/EndOfFile &lt;- !.\r\nlet EndOfFile input =\r\n    match NC input with\r\n    | None -&gt; Some()\r\n    | _ -&gt; None<\/pre>\n<p>Similar to the underscore in F#, the period represents any character In the PEG grammar and the exclamation point is a backtracking not. In other words, EndOfFile succeeds if NC fails, which only happens when the parse buffer is empty. Since the parse buffer is empty on a successful match, there&#8217;s no value to return so Ireturn Some(). Some() is kinda like Nullable, which doesn&#8217;t make much sense in C#. But here it means I have a successful match but no data to pass back to the caller.<\/p>\n<p>Here&#8217;s a slightly more complex grammar production, EndOfLine:<\/p>\n<pre class=\"brush:fsharp\">\/\/\/EndOfLine &lt;- \u2018rn\u2019 \/ \u2018n\u2019 \/ \u2018r\u2019\r\nlet EndOfLine input =\r\n    match NC input with\r\n    | Some(\u2018r\u2019, input) -&gt;\r\n        match NC input with\r\n        | Some (\u2018n\u2019, input) -&gt; Some(input)\r\n        | _ -&gt; Some(input)\r\n    | Some(\u2018n\u2019, input) -&gt; Some(input)\r\n    | _ -&gt; None<\/pre>\n<p>EndOfLine has three possible matches: rn, n and r. Here, you see the use of nested match statements in the r match clause. If the top character is r, the function checks the top of the remaining text buffer for n. F#&#8217;s ability to reuse symbols comes in very handy here.<\/p>\n<p>Unfortunately, this isn&#8217;t code very readable. In particular, the match priority order, which matters in PEGs, is totally lost. For this production, it&#8217;s no big deal, but that won&#8217;t always be the case. I&#8217;m also not using the handy TOKEN function I wrote in <a href=\"http:\/\/devhawk.net\/2007\/12\/11\/Practical+F+Parsing+The+Parse+Buffer.aspx\" target=\"_blank\">a few posts ago<\/a>. Here&#8217;s an alternative version that uses TOKEN and preserves the match priority order.<\/p>\n<pre class=\"brush:fsharp\">\/\/\/EndOfLine &lt;- \u2018rn\u2019 \/ \u2018n\u2019 \/ \u2018r\u2019\r\nlet EndOfLine input =\r\n    match TOKEN \u201crn\u201d input with\r\n    | Some(input) -&gt; Some(input)\r\n    | _ -&gt;\r\n        match TOKEN \u201cn\u201d input with\r\n        | Some(input) -&gt; Some(input)\r\n        | _ -&gt;\r\n            match TOKEN \u201cr\u201d input with\r\n            | Some(input) -&gt; Some(input)\r\n            | _ -&gt; None<\/pre>\n<p>This time, I use the TOKEN function and nested match statements to chain the results together. The previous method is probably faster, but this approach is more readable and explicitly preserves the match order. However, it sure is a pain to type. Wouldn&#8217;t it be great if we could write something like this:<\/p>\n<pre class=\"brush: fsharp\">\/\/\/EndOfLine &lt;- 'rn' \/ 'n' \/ 'r'\r\nlet EndOfLine input =\r\n    match input with\r\n    | TOKEN \"rn\" (input) -&gt; Some(input)\r\n    | TOKEN \"n\" (input) -&gt; Some(input)\r\n    | TOKEN \"r\" (input) -&gt; Some(input)\r\n    | _ -&gt; None<\/pre>\n<p>Turns out, F#&#8217;s <a href=\"http:\/\/devhawk.net\/2007\/11\/29\/F+Hawkeye+Pattern+Matching.aspx\" target=\"_blank\">Active Patterns feature<\/a> let&#8217;s me implement EndOfLine exactly like this. We&#8217;ll look at how it works in the next post.<\/p>\n<hr \/>\n<p>[1] The full PEG grammar is listed in &#8220;<a href=\"http:\/\/pdos.csail.mit.edu\/~baford\/packrat\/popl04\/\" target=\"_blank\">Parsing Expression Grammars: A Recognition-Based Syntactic Foundation<\/a>&#8221; by <a href=\"http:\/\/www.brynosaurus.com\/\" target=\"_blank\">Brian Ford<\/a>.<\/p>\n","excerpt":"<p>Now that I have my parse buffer functions and unit test framework taken care of, it&#8217;s time to write some parsing expression grammar productions [1]. In any grammar, there are productions that have semantic meaning and productions that are only used to specify syntax. For example, in C# statements end with a semicolon and code [&hellip;]<\/p>\n","date":"2007-12-13 11:08:13","modified":"2011-04-17 16:03:32","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":202,"slug":"functional-programming","title":"Functional Programming","description":"","post_count":18},{"id":209,"slug":"parsing-expression-grammar","title":"Parsing Expression Grammar","description":"","post_count":16}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["86444fb7-507c-4a5c-b3c3-350fc44f616e"],"dasblog_compressedtitle":["Practical+F+Parsing+Syntactical+Productions+1"],"dasblog_compressedtitleunique":["2007\/12\/13\/Practical+F+Parsing+Syntactical+Productions+1"]}},"previous_url":"http:\/\/devhawk.net\/2007\/12\/13\/morning-coffee-130\/","next_url":"http:\/\/devhawk.net\/2007\/12\/14\/practical-f-parsing-active-patterns\/"}