<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>The Irrelevant Semantics of Compiled XAML</title>
  <link>http://devhawk.net/2005/10/07/the-irrelevant-semantics-of-compiled-xaml/</link>
  <pubDate>Fri, 07 Oct 2005 00:09:48 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://7bbba116-0039-45ac-986c-e294b5695266</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>From newly converted ARC MVP <a href="http://samgentile.com/blog">Sam Gentile</a>, I found <a href="http://blog.hackedbrain.com/archive/2005/10/06/3193.aspx">this interesting post</a> from <a href="http://blog.hackedbrain.com/">Drew Marsh</a> about how XAML is compiled:</p><blockquote dir="ltr" style="MARGIN-RIGHT: 0px"><p>XAML is indeed a language, but it is never compiled into C# or IL... The truth is, it's not "compiled" at all. If anything you can say it is "compacted" and that only happens in scenarios where it is turned into a BAML stream. That, however, is an optimization and not a necessity for XAML to work. XAML can be interpreted purely in it's raw XML text form, using <a href="http://winfx.msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/O_T_System_Windows_Serialization_Parser_LoadXml.asp"><font color="#146c9a">Parser::LoadXml</font></a>. Even BAML is interpreted, it's just a far more compact and efficient representation of the object graph than raw XML text.<br />[Drew Marsh - <a class="singleposttitle" id="viewpost.ascx_TitleUrl" href="http://blog.hackedbrain.com/archive/2005/10/06/3193.aspx"><font color="#146c9a">The XAML Experience</font></a>]</p></blockquote><p dir="ltr">Given that I just <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">wrote about compiling</a>, I wanted to weigh with a couple of points:</p><ul dir="ltr"><li><div>First, by definition compilation is a translation from one format to another. Therefore, converting XAML to BAML is a compilation step. The <a href="http://lab.msdn.microsoft.com/teamsystem/workshop/sdm/default.aspx">SDM folks</a> have a <a href="http://msdn2.microsoft.com/en-us/library/ms151031">command line tool</a> for compiling deployment reports from the models in the <a href="http://lab.msdn.microsoft.com/teamsystem/teamcenters/architect/">Architect edition of VSTS</a>. However, I assume what Drew meant here was that XAML isn't compiled into a directly executable format, so in reality I'm just being picky about the use of the word "compiled". </div></li><li><div>Second, the fact that the XAML is compiled into an efficient binary representation and then embedded as a resource (<a href="http://www.longhornblogs.com/rrelyea/archive/2004/01/31/2306.aspx">as per Rob Relyea</a>) is fascinating from an implementation perspective, but somewhat irrelevant semantically. Drew points out that the BAML is interpreted. With VM environments like CLR, the line between interpreted and compiled blurs considerably. <a href="http://pluralsight.com/blogs/dbox/archive/2005/09/30/15100.aspx">Rob's post</a> referenced above is based on the PDC 03 XAML bits, and at the time, XAML could be compiled into BAML <i>or </i>IL. However, at the time (20 months ago) Rob guessed that the IL compilation would be cut because the BAML perf was just as good or better, the file size was smaller and localization is easier. In the end, the XAML file is converted into a format the machine can execute - the specific choice of compilers and transformations isn't particularly interesting from a modeling perspective since it happens automatically.</div></li></ul><p>XAML isn't the only place where the traditional compiling to executable model is being stretched. In <a href="http://msdn.microsoft.com/windowsvista/building/workflow/default.aspx">Windows Workflow Foundation</a>, though your workflow is defined as a type, you can actually <a href="http://blogs.msdn.com/markhsch/archive/2005/09/23/473373.aspx">modify running instances</a> of the workflow. Given that WF supports declaring workflows as C# or XOML (soon to be XAML), I wonder if they are going to go the same route as WPF and eliminate the C#/IL way of declaring workflows. Another interesting example is <a href="http://msdn.microsoft.com/netframework/future/linq/default.aspx">LINQ</a> and C# 3.0. This is interesting because you can use LINQ directly on in memory data, but when you apply it to database (via <a href="http://download.microsoft.com/download/c/f/b/cfbbc093-f3b3-4fdb-a170-604db2e29e99/DLinq%20Overview.doc">DLinq</a>) the LINQ statements are parsed into expression trees then converted into SQL. (Check out <a href="http://www.interact-sw.co.uk/iangblog/2005/09/30/expressiontrees">this post</a> from <a href="http://www.interact-sw.co.uk/iangblog">Ian Griffiths</a> for deeper coverage of expression trees).</p><p>Anyway, it's late and I realize I've written quite a bit to basically say that the definition of "compiled" is pretty blurry at this point and getting blurrier going forward. In the end, it's much more interesting IMO to focus on the model environment you're working in (XAML in this case) rather than the details of how that model is translated into the execution environment, unless you're the one building those translation tools.</p><p><strong>UPDATE</strong> - I had one other thought on all this. It's interesting that computing power (CPU + IO bandwidth) have improved to a point where the performance of interpreting BAML at runtime is as fast than executing XAML compiled to IL directly. I certainly wouldn't have assumed that. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">641</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2005-10-07 00:09:48</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2005-10-07 00:09:48</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">the-irrelevant-semantics-of-compiled-xaml</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[7bbba116-0039-45ac-986c-e294b5695266]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[The+Irrelevant+Semantics+Of+Compiled+XAML]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2005/10/07/The+Irrelevant+Semantics+Of+Compiled+XAML]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2861</wp:comment_id>
    <wp:comment_author><![CDATA[Rob Relyea]]></wp:comment_author>
    <wp:comment_author_email>rrelyea@microsoft.com</wp:comment_author_email>
    <wp:comment_author_url>http://longhornblogs.com/rrelyea</wp:comment_author_url>
    <wp:comment_author_IP>131.107.0.102</wp:comment_author_IP>
    <wp:comment_date>2005-10-08 04:57:23</wp:comment_date>
    <wp:comment_date_gmt>2005-10-08 11:57:23</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[A) IL still works
You said:
I wonder if they are going to go the same route as WPF and eliminate the C#/IL way of declaring workflows
RR: WPF still supports using code only (you don't need to ever use XAML if you don't want to...most tools will be built using XAML as the persistance model though).  We just don't convert XAML into all IL anymore.  I believe WWF/XAML will be similar, but I'm not positive.

B) CPU + IO Bandwidth
The BAML vs IL question you raise in your UPDATE is an interesting one.

When we used to compile XAML to IL, the EXEs were much larger.  IL can't be processed as it is downloaded.  With BAML, you have a shared amount of code to load it, and repeated baml records to load and discard.

So there are a bunch of factors here.  Download size of the assembly, streamability of the baml, etc...

We were surprised that IL wasn't much faster than BAML.  Happily, that allowed us to focus all of our developement, optimizations, testing on one code path, which is a good thing.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>