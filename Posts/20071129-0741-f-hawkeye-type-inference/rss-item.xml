<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>F# Hawkeye : Type Inference</title>
  <link>http://devhawk.net/2007/11/29/f-hawkeye-type-inference/</link>
  <pubDate>Thu, 29 Nov 2007 07:41:16 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://2cb86ed8-f847-44e8-8f95-62758e370a45</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p><em>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that's turned out to be infeasible. So instead, you get a series of pre-written posts about F#.)</em></p><p>For you LINQ early adopters, you may think you know everything about type inference, but F#'s uses it much more extensively. In C#3 , you can write "var o = new SomeObject()" and the compiler is smart enough to figure out the variable o is of type SomeObject. Saves some typing, but it's not exactly brain surgery. F# can not only infer the type of local variables like C#, but it can also infer type of a function's input parameters and return value based on how those variables are used in the function. For example, in the Additive function, F# can infer that the "input" parameter is a char list because Token takes a generic list and '+' is a char. </p><p>F# automatically "generisizes" the functions you write. So if you write a function for traversing a list, by default it will work on a list of any type. You don't have to explicitly declare the generics, F# automatically makes your code as generic as possible, based on your usage of the variables.</p><p>What's really interesting about this approach is that changes to parameter or return types in a low-level function can have a rippling effect up the stack. In my parsing code, I haven't settled on the type I'm going to use to represent the string to be parsed. My tests are all short strings, so F#'s intrinsic char list type is fine. However, I don't know how well that will work for longer strings like a typical input file. F#'s native parsing tools (based on lex &amp; yacc which I dislike) have a special LexBuffer class to represent the parse string. However, I've written my code so I can change the type of the lowest-level functions (NextChar and CheckForToken) and not affect the rest of my code. That's pretty wicked.</p><p>Type inference does have a downside. I guess VS has <a href="http://charlespetzold.com/etc/DoesVisualStudioRotTheMind.html">rotted my mind</a>, but I'm hooked on Intellisense. The BCL is too big to remember all the classes and all the method parameters. Intellisense is kinda like <strike>Google</strike> a web search engine. If you sorta know what you're looking for, Intellisense helps close the gap to find it. Otherwise, it's time to break out the docs. However, if you're inferring type based on usage, Intellisense is out of luck. Honestly, there have been times where I've put in an explicit type declaration to get Intellisense to work, written the code, then removed the type declaration. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1060</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-11-29 07:41:16</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-11-29 07:41:16</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">f-hawkeye-type-inference</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="f-sharp"><![CDATA[F#]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[2cb86ed8-f847-44e8-8f95-62758e370a45]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[F+Hawkeye+Type+Inference]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/11/29/F+Hawkeye+Type+Inference]]></wp:meta_value>
  </wp:postmeta>
</item>