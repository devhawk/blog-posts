<p><em>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that&#8217;s turned out to be infeasible. So instead, you get a series of pre-written posts about F#.)</em></p>
<p>For you LINQ early adopters, you may think you know everything about type inference, but F#&#8217;s uses it much more extensively. In C#3 , you can write &#8220;var o = new SomeObject()&#8221; and the compiler is smart enough to figure out the variable o is of type SomeObject. Saves some typing, but it&#8217;s not exactly brain surgery. F# can not only infer the type of local variables like C#, but it can also infer type of a function&#8217;s input parameters and return value based on how those variables are used in the function. For example, in the Additive function, F# can infer that the &#8220;input&#8221; parameter is a char list because Token takes a generic list and &#8216;+&#8217; is a char. </p>
<p>F# automatically &#8220;generisizes&#8221; the functions you write. So if you write a function for traversing a list, by default it will work on a list of any type. You don&#8217;t have to explicitly declare the generics, F# automatically makes your code as generic as possible, based on your usage of the variables.</p>
<p>What&#8217;s really interesting about this approach is that changes to parameter or return types in a low-level function can have a rippling effect up the stack. In my parsing code, I haven&#8217;t settled on the type I&#8217;m going to use to represent the string to be parsed. My tests are all short strings, so F#&#8217;s intrinsic char list type is fine. However, I don&#8217;t know how well that will work for longer strings like a typical input file. F#&#8217;s native parsing tools (based on lex &amp; yacc which I dislike) have a special LexBuffer class to represent the parse string. However, I&#8217;ve written my code so I can change the type of the lowest-level functions (NextChar and CheckForToken) and not affect the rest of my code. That&#8217;s pretty wicked.</p>
<p>Type inference does have a downside. I guess VS has <a href="http://charlespetzold.com/etc/DoesVisualStudioRotTheMind.html">rotted my mind</a>, but I&#8217;m hooked on Intellisense. The BCL is too big to remember all the classes and all the method parameters. Intellisense is kinda like <strike>Google</strike> a web search engine. If you sorta know what you&#8217;re looking for, Intellisense helps close the gap to find it. Otherwise, it&#8217;s time to break out the docs. However, if you&#8217;re inferring type based on usage, Intellisense is out of luck. Honestly, there have been times where I&#8217;ve put in an explicit type declaration to get Intellisense to work, written the code, then removed the type declaration. </p>
