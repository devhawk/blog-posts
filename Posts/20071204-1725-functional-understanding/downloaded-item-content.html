<p>I was showing some of my cool (well, I think it&#8217;s cool) F# parsing code to some folks @ DevTeach. I realized very quickly that a) most mainstream developers are fairly unaware of functional programming and b) I suck at explaining why functional programming matters. So I decided to take another stab at it. I probably should have posted this before my <a href="http://devhawk.net/2007/11/28/F+As+A+Second+NET+Language.aspx">recent series on F#</a>, but better late than never I suppose.</p>
<p>Right off the bat, the term &#8220;functional&#8221; is confusing. When you say &#8220;function&#8221; to a mainstream developer, they hear &#8220;<a href="http://en.wikipedia.org/wiki/Function_%28computer_science%29">subroutine</a>&#8220;. But when you say &#8220;function&#8221; to a mathematician, they hear &#8220;<a href="http://en.wikipedia.org/wiki/Function_%28math%29">calculation</a>&#8220;. Functions in functional programming (aka FP) are closer to the mathematic concept. If you think about math functions, they&#8217;re very different than subroutines. In particular, math functions have no intrinsic mutable data. If you have a math function like f(x) = x<sup>3</sup>, f(7) always equals 343, no matter how many times you call it. This is very different then a function like String.Length() where the value returned depends on the value of the string. </p>
<p>Another interesting aspect of math-style functions is that they have no side-effects. When you call StringBuilder.Append(), you&#8217;re changing the internal state of the StringBuilder object. But FP functions don&#8217;t work like that. Providing the same input always provides the same output (i.e. the same independent variable always yields the same dependent value). </p>
<p>If you&#8217;re a .NET developer, this may sound strange, but you&#8217;re probably very familiar with the <a href="http://msdn2.microsoft.com/library/system.string.aspx">String class</a> which works exactly the same way.</p>
<blockquote><p>A <b>String</b> object is a sequential collection of <a href="http://msdn2.microsoft.com/en-us/library/k493b04s.aspx">System.Char</a> objects that represent a string. The value of the <b>String</b> object is the content of the sequential collection, and that value is immutable.  </p>
<p>A <b>String</b> object is called immutable (read-only) because its value cannot be modified once it has been created. Methods that appear to modify a <b>String</b> object actually return a new <b>String</b> object that contains the modification. </p>
</blockquote>
<p>In other words, all variables in FP are a lot like .NET Strings. In fact, in many FP languages, variables are actually called &#8220;values&#8221; because they don&#8217;t, in fact, vary.  </p>
<p>It turns out that this approach to programming has significant upside for unit testing and concurrency. Unit tests typically spend a significant effort getting the objects they&#8217;re testing into the right state to invoke the function under test. In FP, the result of a function is purely dependent on the values passed into it, which makes unit testing very straight forward. For concurrency, since functions don&#8217;t share mutable state, there&#8217;s no need to do complicated locking across multiple processors.  </p>
<p>But if values don&#8217;t vary, how to we managed application state? FP apps typically maintain their state on the stack. For example, my F# parser starts with a string input and return an abstract syntax tree. All the data is passed between functions on the stack. However, for most user-oriented non-console applications, keeping all state on the stack isn&#8217;t realistic.&nbsp; As Simon Peyton Jones <a href="http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/" target="_blank">points out</a>, &#8220;The ultimate purpose of running a program is invariably to cause some side effect: a changed file, some new pixels on the screen, a message sent, or whatever.&#8221; So all FP languages provide some mechanism for purposefully implementing side effects, some (like Haskell) stricter in their syntax than others. </p>
<p>One of the nice things about F#&#8217;s <a href="http://research.microsoft.com/fsharp/faq.aspx#WhatSortOfLanguage">multi-paradigm nature</a> is that side effects is a breeze. Of course, that&#8217;s both a blessing and a curse, since the much of the aforementioned upside comes from purposefully building side-effect free functions. But the more I work with F#, the more I appreciate the ability to do both functional as well as imperative object-oriented operations in the same language. For example, my parsing code so far is purely functional &#8211; it takes in a string to be parsed and returns an AST. But the logical next step would be to generate output based on that AST. Since F# supports non-functional code &#8211; not to mention the rich Base Class Library &#8211; generating output should be straightforward.</p>
