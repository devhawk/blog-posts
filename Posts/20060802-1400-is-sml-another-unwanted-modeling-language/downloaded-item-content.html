<p>Piyush Pant <a href="http://unhandledx.blogspot.com/2006/08/modelling-overload.html">wonders</a> if SML solves a problem that nobody has? He also points out <a href="http://www.sysml.org/">SysML</a>&nbsp;project, which recently got folded into the <a href="http://omg.org/">OMG</a>. Well, that explains why we called it &#8220;Service&#8221; instead of &#8220;System&#8221; modeling language.</p>
<p>Now that I work in IT, I can definitely say that SML will <em>eventually </em>solve a problem that I have. Most people agree that operations today is way to dependent on manual processes to scale effectively. Now SML doesn&#8217;t solve that issue directly &#8211; as Piyush pointed out SML is a meta-modeling specification. However, SML is the foundation for the next generation of operational modeling tools like what we see in <a href="http://msdn.microsoft.com/vstudio/teamsystem/architect/">Visual Studio Team System for Architects</a>. As I <a href="http://devhawk.net/2004/02/03/Being+A+Model+Citizen.aspx">wrote several years ago</a>, VSTS:A solves a very common problem &#8211; developers lack of understanding about the deployment environment. Piyush, haven&#8217;t you ever had a long weekend going back to the drawing board because the solution you had built was undeployable and you didn&#8217;t discover that fact until the operations team attempted to deploy it? If you haven&#8217;t, I envy you.</p>
<p>On the surface, I agree with Piyush when he says that &#8220;history of software is littered with unsuccessful attempts to impose monolithic modeling constructs&#8221;. However, the fact that it keeps happening indicates the problem hasn&#8217;t been solved. Wanting to solve a problem and being able to solve a problem are two different things. Furthermore, the history of software is also littered with very successful attempts to raise the level of abstraction by the introduction of new programming languages: C, C++, VB and Ruby are all examples of this. Given that <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a>, what we have is a history of software littered with some successful and some unsuccessful modeling constructs. I would argue that the successful modeling constructs have taken a bottom up approach &#8211; build a language a small abstraction step above something that actually runs and compile down. These unsuccessful modeling constructs (*cough* UML *cough*) take a top down approach &#8211; build a language way above anything that actually runs and hope a miracle happens to keep it in sync with the stuff you actually build.</p>
<p>The question is whether SML will be top-down (i.e. a failure) or bottoms-up (i.e. a success). So far, it&#8217;s to early to tell, but I have high hopes.</p>
