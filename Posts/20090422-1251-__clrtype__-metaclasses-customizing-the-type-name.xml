<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>__clrtype__ Metaclasses: Customizing the Type Name</title>
  <link>http://devhawk.net/2009/04/22/__clrtype__-metaclasses-customizing-the-type-name/</link>
  <pubDate>Wed, 22 Apr 2009 12:51:03 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://ef846228-b0b7-4130-aac8-54dd631f4e89</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Now that we know a <a href="http://devhawk.net/2009/04/21/clrtype+Metaclasses+IronPython+Classes+Under+The+Hood.aspx">little about how IronPython uses CLR types under the hood</a>, let’s start customizing those types. In a nutshell, __clrtype__ metaclasses are metaclasses that implement a function named __clrtype__ that takes the Python class definition as a parameter and returns a <a href="http://msdn.microsoft.com/library/system.type.aspx">System.Type</a>. IronPython will then use the returned Type  as the underlying CLR type whenever you create an instance of the Python class. </p><p>Technically, you could emit whatever custom CLR Type you want to in the __clrtype__, but typically you’ll want to emit a class that both implements whatever static CLR metadata you need as well as the dynamic binding infrastructure that IronPython expects. The easiest way to do this is to ask IronPython emit a type that handles all the dynamic typing and then inherit from that type to add the custom CLR metadata you want.</p><p>Let’s start simple and hello-worldly by just customizing the name of the generated CLR type that’s associated with the Python class. There’s a fair amount of boilerplate code that is needed even for this simple scenario, and I can build on that as we add features that actually do stuff. If you want to follow along at home, you’ll need <a href="http://ironpython.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=22982">IronPython 2.6 Alpha 1</a> (or later) and you can get this code <a href="http://cid-0d9bc809858885a4.skydrive.live.com/browse.aspx/DevHawk%20Content/IronPython%20Stuff/%7C_%7C_clrtype%7C_%7C_">from my SkyDrive</a>. </p><pre class="brush: python">
class ClrTypeMetaclass(type):
  def __clrtype__(cls):
    baseType = super(ClrTypeMetaclass, cls).__clrtype__()
    typename = cls._clrnamespace + "." + cls.__name__ 
                 if hasattr(cls, "_clrnamespace") 
                 else cls.__name__
                 
    typegen = Snippets.Shared.DefineType(typename, baseType, True, False)
    typebld = typegen.TypeBuilder

    for ctor in baseType.GetConstructors(): 
      ctorparams = ctor.GetParameters()
      ctorbld = typebld.DefineConstructor(
                  ctor.Attributes,
                  ctor.CallingConvention,
                  tuple([p.ParameterType for p in ctorparams]))
      ilgen = ctorbld.GetILGenerator()
      ilgen.Emit(OpCodes.Ldarg, 0)
      for index in range(len(ctorparams)):
        ilgen.Emit(OpCodes.Ldarg, index + 1)
      ilgen.Emit(OpCodes.Call, ctor)
      ilgen.Emit(OpCodes.Ret)

    return typebld.CreateType()
</pre><p>Like all Python metaclasses, ClrTypeMetaclass inherits from the <a href="http://docs.python.org/library/stdtypes.html#type-objects">built-in Python type object</a>. If I wanted to <a href="http://docs.python.org/reference/datamodel.html#customizing-class-creation">customize the Python class</a> as well, I could implement __new__ on ClrTypeMetaclass , but I only care about customizing the CLR type so it only implements __clrtype__. If you want to know more about what you can do with Python metaclasses, check out Michael Foord’s <a href="http://www.voidspace.org.uk/python/articles/five-minutes.shtml">Metaclasses in Five Minutes</a>.</p><p>First off, I want to get IronPython to generate the base class that will implement all the typical Pythonic stuff like name resolution and dynamic method dispatch. To do that, I call __clrtype__ on the <a href="http://docs.python.org/library/functions.html#super">supertype</a> of ClrTypeMetaclass – aka the built-in type object. That function returns the System.Type that IronPython would have used as the underlying CLR type for the Python class if we weren’t using __clrtype__ metaclasses.</p><p>Once I have the base class, next I figure out what the name of the generated CLR type will be. This is pretty simple, I just use the name of the Python class. To make this logic a little more interesting, I added support for a custom namespace. If the Python class has a _clrnamespace field, I append that as the custom namespace for the name. I should probably be using a double underscore – i.e. __clrnamespace – but I didn’t want to wrestle with <a href="http://docs.python.org/tutorial/classes.html#private-variables">name mangling</a> in this prototype code.</p><p>Now that I have a name and a base class, I can generate the class I’m going to use. I’m using the DefineType method in <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/49291#760277">Microsoft.Scripting.Generation.Snippets</a> DLR class for three reasons. First, there’s a <a href="http://www.mail-archive.com/users@lists.ironpython.com/msg08702.html">CLR bug</a> that doesn’t let you create a dynamic assembly from a dynamic method. Second, reusing the snippets assembly avoids the overhead of generating a new assembly. Finally, the types in Snippets.Shared get saved to disk if you run with the -X:SaveAssemblies flag, so you can inspect custom CLR type that gets generated. The DefineType function takes four parameters, the type name, the base class, a preserve name flag and a generate debug symbols flag. If you pass false for preserve name, you get a name like foobar$1 instead of just foobar. As for debug symbols, since I don’t have any source code that I’m generating IL from, emitting debug symbols doesn’t make a lot of sense. DefineType returns a <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/49291#760661">TypeGen</a>, but I only need the <a href="http://msdn.microsoft.com/library/system.reflection.emit.typebuilder.aspx">TypeBuilder</a>.</p><p>The last thing I need to do is implement the custom CLR type constructor(s). IronPython CLR types will always have at least one parameter – the <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/49291#384570">PythonType</a> (PythonType == IronPython’s implementation of Python’s built-in type object) that’s used for dynamic name resolution. I don’t want to add any custom functionality in my custom CLR type constructors, so I simply iterate thru the list of constructors on the base class and generate a constructor on the custom CLR type with a matching parameter list and that calls the base class constructor.  </p><p>Generating the IL to emit the constructor and the base class is straightforward, if tedious. I define the constructor with the same attributes, calling convention and parameters as the base class constructor. Then I emit IL to load the local instance (i.e. ldarg 0) and all the parameters onto the stack, call the base constructor and finally return. Once all the constructors are defined, I can create the type and return.</p><p>Using the ClrTypeMetaclass is very easy - simply specify the __metaclass__ field in a class. If you want to customize the namespace, specify the _clrnamespace field as well. Here’s an example:</p><pre class="brush: python">
class Product(object):
  __metaclass__ = ClrTypeMetaclass
  _clrnamespace = "DevHawk.IronPython.ClrTypeSeries"   
  
  def __init__(self, name, cost, quantity):
    self.name = name
    self.cost = cost
    self.quantity = quantity
  
  def calc_total(self):
    return self.cost * self.quantity
</pre><p>You can verify this code has custom CLR metadata by calling GetType on a Product instance and inspecting the result via standard reflection techniques.</p><p></p><pre class="brush: text">
&gt;&gt;&gt; m = Product('Crunchy Frog', 10, 20)
&gt;&gt;&gt; m.GetType().Name
'Product'
&gt;&gt;&gt; m.GetType().FullName
'DevHawk.IronPython.ClrTypeSeries.Product'
</pre><p>Great, so now I have a custom CLR type for my Python class. Unfortunately, at this point it’s pretty useless. Next, I’m going to add instance fields to the CLR type.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1252</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-04-22 12:51:03</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-04-22 12:51:03</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">__clrtype__-metaclasses-customizing-the-type-name</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="__clrtype__"><![CDATA[__clrtype__]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[ef846228-b0b7-4130-aac8-54dd631f4e89]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[clrtype+Metaclasses+Customizing+The+Type+Name]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/04/22/clrtype+Metaclasses+Customizing+The+Type+Name]]></wp:meta_value>
  </wp:postmeta>
</item>