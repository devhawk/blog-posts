{"status":"ok","post":{"id":1206,"type":"post","slug":"ironpython-and-livefx-raw-http-access","url":"http:\/\/devhawk.net\/2008\/12\/16\/ironpython-and-livefx-raw-http-access\/","status":"publish","title":"IronPython and LiveFX: Raw HTTP Access","title_plain":"IronPython and LiveFX: Raw HTTP Access","content":"<p>One of the cool things about the Live Framework is that while there\u2019s a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/dd136352.aspx\">convenient .NET library available<\/a>, you can use the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/dd199240.aspx\">raw HTTP interface<\/a> from any platform. LiveFX data is served up over HTTP and is available in ATOM, RSS, JSON or POX formats. As I\u2019ve already shown, you can easily use the .NET library from IronPython, but I wanted to try working with the raw HTTP interface to get a feel for that as well.<\/p>\n<p>Unfortunately, it was harder than I expected it to be. The big issue is that the documentation on how to LiveFX authorization tokens via raw HTTP is fairly sparse and occasionally contradictory. For example, there\u2019s a whole section on <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/dd137185.aspx\">Authentication and Live Framework<\/a>, but it doesn\u2019t cover this scenario. Luckily, I was able to figure it out with the help of <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/dd135995.aspx\">AtomPub Project Manager LiveFX Sample<\/a>, a <a href=\"http:\/\/blog.opennetcf.com\/afeinman\/PermaLink,guid,80ea4a1d-fbc0-485d-a088-fb8f30efb6ab.aspx\">post on Alex Feinman\u2019s blog<\/a>, a <a href=\"http:\/\/blogs.msdn.com\/emesas\/archive\/2008\/02\/13\/windows-live-id-available-options-part-i.aspx\">post on Emmanuel Mesas\u2019 blog<\/a> and a little groveling around with Reflector. It does appear that the auth docs are in flux \u2013Emmanuel refers to <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/bb447721.aspx\">this MSDN article<\/a> as being about RPS Soap requests, but it\u2019s actually about delegated authority. (Is MSDN reusing URLs? Bad idea.) Also, the sample code has a comment that reads \u201cto be replaced by delegated authorization\u201d so it looks like changes are coming. In other words, no promises on how long this code will work!<\/p>\n<p>If you look at the AtomPub Project Manager sample, there\u2019s a WindowsLiveIdentity.cs file that implements static GetTicket method that looks similar to both the code on Alex\u2019s blog as well as the implementation of <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/dd157462.aspx\">GetWindowsLiveAuthenticationToken<\/a>. The upshot is that there\u2019s a <a href=\"http:\/\/en.wikipedia.org\/wiki\/WS-Trust\">WS-Trust<\/a> endpoint for Windows Live at <a href=\"https:\/\/dev.login.live.com\/wstlogin.srf\">https:\/\/dev.login.live.com\/wstlogin.srf<\/a>. You send it a RequestSecurityToken (aka RST) message (with a couple of extra WL specific extensions) and it responds with the security token you\u2019ll need for accessing the LiveFx HTTP endpoints. <\/p>\n<p>I ported the GetTicket function over to IronPython. I\u2019m using .NET classes like WebRequest and XmlReader, but there\u2019s nothing fancy here so I would expect it to be easy enough to port over to the standard Python library.<\/p>\n<pre class=\"brush: python\">\ndef get_WL_ticket(username, password, compactTicket):\n    req = WebRequest.Create(_LoginEndPoint)\n    req.Method = \"POST\"\n    req.ContentType = \"application\/soap+xml; charset=UTF-8\"\n    req.Timeout = 30 * 10000\n     \n    rst = get_RST_message(username, password, compactTicket)\n    rstbytes = Encoding.UTF8.GetBytes(rst)\n    with req.GetRequestStream() as reqstm:\n      reqstm.Write(rstbytes, 0, rstbytes.Length)\n       \n    with req.GetResponse() as resp:\n      with resp.GetResponseStream() as respstm:\n        with XmlReader.Create(respstm) as reader:\n          if compactTicket:\n            name = \"BinarySecurityToken\"\n            namespace = \"http:\/\/docs.oasis-open.org\/wss\/2004\/01\/oasis-200401-wss-wssecurity-secext-1.0.xsd\"\n          else:\n            name = \"RequestedSecurityToken\"\n            namespace = \"http:\/\/schemas.xmlsoap.org\/ws\/2005\/02\/trust\"\n\n          if not reader.ReadToDescendant(name, namespace):\n            raise \"couldn't find security token element\"\n           \n          reader.ReadStartElement(name, namespace)\n          token = reader.ReadContentAsString()\n          reader.ReadEndElement()\n           \n          return Convert.ToBase64String(Encoding.UTF8.GetBytes(token))\n<\/pre>\n<p>This code simply uses a WebRequest object to post the RST message to the WS-Trust enpoint then parses the result to find the token. get_RST_message uses <a href=\"http:\/\/www.python.org\/doc\/2.5.2\/lib\/typesseq-strings.html\">standard Python string formatting<\/a> to generate the RST message that gets posted to the WS-Trust endpoint. I\u2019m not exactly sure why you need to convert the token value to a byte array and then Base64 encode it, but that\u2019s what the sample code does so I did it to.<\/p>\n<p>Once you have the authentication ticket, you need to download root service endpoint document in order to get the base URL and the profiles link. Then you can download all the profiles or you can download a specific one if you know it\u2019s <a href=\"http:\/\/orand.blogspot.com\/2008\/11\/l1v3-m35h-l337-h4x0rz.html\">leet-speak identifier<\/a>. LiveFX data can be downloaded in a variety of formats: ATOM, JSON, RSS or POX. You choose your format by setting the Accept and Content-Type headers. <\/p>\n<p>I wrote the following functions, the generic boilerplate download function as well a specific versions for downloading JSON and POX:<\/p>\n<pre class=\"brush: python\">\ndef download(url, contentType, authToken):\n  req = WebRequest.Create(url)\n  req.Accept = contentType     \n  req.ContentType = contentType     \n  req.Headers.Add(HttpRequestHeader.Authorization, authToken)\n   \n  return req.GetResponse()  \n   \ndef download_json(url, authToken):\n  resp = download(url, 'application\/json', authToken)\n  with StreamReader(resp.GetResponseStream()) as reader:  \n      data = reader.ReadToEnd()\n      return eval(data)\n\ndef download_pox(url, authToken):\n  resp = download(url, 'text\/xml', authToken)\n  return XmlReader.Create(resp.GetResponseStream())\n<\/pre>\n<p>Using JSON in Python is really easy, since I can simply eval the returned string and get back Python dictionary objects, similar to what you can do in Javascript. <\/p>\n<p>Here\u2019s some code that uses the get_WL_ticket and download_json functions above to retrieve the the user\u2019s Personal Status Message<\/p>\n<pre class=\"brush: python\">\n#Get user's WL ticket\nuid = raw_input(\"enter WL ID: \")    \npwd = raw_input(\"enter password: \")   \n\nauthToken = livefx_http.get_WL_ticket(uid, pwd, True)   \n\n#download root service document \nservice = livefx_http.download_json(_LiveFxUri, authToken)   \n\n#download general profile document \nurl = service['BaseUri'] + service['ProfilesLink'] + \"\/G3N3RaL\"   \n\ngenprofile = livefx_http.download_json(url, authToken)   \nprint genprofile['ProfileBase']['PersonalStatusMessage']\n<\/pre>\n<p>POX is also fairly easy, though a bit more verbose than JSON. The sample code, which I have <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/self.aspx\/DevHawk%20Content\/IronPython%20Stuff\/LiveFxHttp.zip\">stuck on my SkyDrive<\/a>, includes both POX and JSON code, so you can compare and contrast the differences. <\/p>\n","excerpt":"<p>One of the cool things about the Live Framework is that while there\u2019s a convenient .NET library available, you can use the raw HTTP interface from any platform. LiveFX data is served up over HTTP and is available in ATOM, RSS, JSON or POX formats. As I\u2019ve already shown, you can easily use the .NET [&hellip;]<\/p>\n","date":"2008-12-16 15:36:48","modified":"2008-12-16 15:36:48","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":275,"slug":"live-framework","title":"Live Framework","description":"","post_count":3},{"id":207,"slug":"windows-live","title":"Windows Live","description":"","post_count":29}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["47b36a30-e4af-42a0-8609-fbc0a83fe083"],"dasblog_compressedtitle":["IronPython+And+LiveFX+Raw+HTTP+Access"],"dasblog_compressedtitleunique":["2008\/12\/16\/IronPython+And+LiveFX+Raw+HTTP+Access"]}},"previous_url":"http:\/\/devhawk.net\/2008\/12\/16\/ironpython-and-livefx-oris-liveoe-py\/","next_url":"http:\/\/devhawk.net\/2008\/12\/17\/powershell-find-to-set-alias\/"}