{"status":"ok","post":{"id":87,"type":"post","slug":"platform-or-plumbing","url":"http:\/\/devhawk.net\/2003\/05\/14\/platform-or-plumbing\/","status":"publish","title":"Platform or Plumbing","title_plain":"Platform or Plumbing","content":"<blockquote><p>I definately agree with Scott to a point. In the end, you can&#8217;t have pure .NET, because even the APIs themselves are going to call COM objects. So, if .NET can do it, why not my app? Well, for one, I want my apps to work under Mono and any other runtimes that come out. Not a big deal today, but planning ahead is a good thing.<br \/> [<a href=\"http:\/\/dotnetweblogs.com\/jezell\/posts\/7018.aspx\">Jesse Ezell&#8217;s Weblog<\/a>]<\/p>\n<\/blockquote>\n<p>To me, the biggest reason to write 100% managed code is the obvious one &#8211; <a href=\"http:\/\/www.microsoft.com\/resources\/casestudies\/CaseStudy.asp?CaseStudyID=14042\"> less work<\/a>. CLR and BCL do much more heavy lifting than COM or Win32. What better reason do you need?<\/p>\n<p>.NET APIs not only call to COM objects but also into the Win32 API as well. When you call System.IO.File.Open(), eventually that ends up as a call to CreateFile(). In Rotor, File.Open results in the construction of a FileStream object. You can see the call to CreateFile in the internal FileStream constructor (sscliclrsrcbclsystemiofilestream.cs). <a href=\"http:\/\/www.aisto.com\/roeder\/dotnet\/\">Reflector<\/a> reveals a similar implementation for the .NET Framework. But as we start to see other <a href=\"http:\/\/msdn.microsoft.com\/net\/sscli\">CLR<\/a><a href=\"http:\/\/www.go-mono.com\">implementations<\/a> on <a href=\"http:\/\/www.linux.org\/\">other<\/a><a href=\"http:\/\/www.freebsd.org\/\"> platforms<\/a>, I start to wonder how many of the underlying platform unmanaged API&#8217;s will be consistent across platforms? Some will obviously be consistent &#8211; file access, memory management, network sockets to name a few. Others such as distributed transaction management or 3D rendering will be missing or implemented in a inconsistent manner. For example: it would be very difficult to build a generic 3D library that used DirectX or OpenGL under the hood. You&#8217;d probably wind up with a library that targets the lowest common denominator, leaving vast portions of both APIs unexposed. Developers using your 3D library would be able to target both environments, but at a stiff price &#8211; lack of access to the cutting edge features of either environment. <\/p>\n<p>Here&#8217;s a question I pose to blogspace: Is the .NET Framework a platform or just better plumbing for the underlying platform?<\/p>\n","excerpt":"<p>I definately agree with Scott to a point. In the end, you can&#8217;t have pure .NET, because even the APIs themselves are going to call COM objects. So, if .NET can do it, why not my app? Well, for one, I want my apps to work under Mono and any other runtimes that come out. [&hellip;]<\/p>\n","date":"2003-05-14 23:02:56","modified":"2003-05-14 23:02:56","categories":[],"tags":[],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["7e40eff9-21c8-4990-bfdc-54d0ea3638c1"],"dasblog_compressedtitle":["Platform+Or+Plumbing"],"dasblog_compressedtitleunique":["2003\/05\/15\/Platform+Or+Plumbing"]}},"previous_url":"http:\/\/devhawk.net\/2003\/05\/14\/tracking-bugs-with-pure-managed-code\/","next_url":"http:\/\/devhawk.net\/2003\/05\/14\/support-for-web-services\/"}