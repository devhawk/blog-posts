{"status":"ok","post":{"id":1266,"type":"post","slug":"__clrtype__-metaclasses-positional-attribute-parameters","url":"http:\/\/devhawk.net\/2009\/06\/17\/__clrtype__-metaclasses-positional-attribute-parameters\/","status":"publish","title":"__clrtype__ Metaclasses: Positional Attribute Parameters","title_plain":"__clrtype__ Metaclasses: Positional Attribute Parameters","content":"<p>The <a href=\"http:\/\/devhawk.net\/2009\/06\/15\/clrtype+Metaclasses+Simple+Custom+Attributes.aspx\">basic infrastructure<\/a> for custom attributes in IronPython is in place, but it\u2019s woefully limited. Specifically, it only works for custom attributes that don\u2019t have parameters. Of course, most of the custom attributes that you\u2019d really want to use require additional parameters, both the positional or named variety. Since positional parameters are easier, let\u2019s start with them.<\/p>\n<p>Positional parameters get passed to the custom attribute\u2019s constructor. As we saw in the previous post, you need a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.customattributebuilder.aspx\">CustomAttributeBuilder<\/a> to attach a custom attribute to an attribute target (like a class). Previously, I just needed to know the attribute type since I was hard coding the positional parameters. But now, I need to know both the attribute type as well as the desired positional parameters. I could have built a custom Python class to track this information, but it made much more sense just to use CustomAttributeBuilder instances. I built a utility function make_cab to construct the CustomAttributeBuilder instances.<\/p>\n<pre class=\"brush: python\">\ndef make_cab(attrib_type, *args):\n  argtypes = tuple(map(lambda x:clr.GetClrType(type(x)), args))\n  ci = clr.GetClrType(attrib_type).GetConstructor(argtypes)\n  return CustomAttributeBuilder(ci, args)\n\nfrom System import ObsoleteAttribute \n\nclass Product(object):\n  __metaclass__ = ClrTypeMetaclass\n  _clrnamespace = \"DevHawk.IronPython.ClrTypeSeries\"   \n  _clrclassattribs = [make_cab(ObsoleteAttribute , \"Warning Lark's Vomit\")]\n\n  # remaining Product class definition omited for clarity\n<\/pre>\n<p>In make_cab, I build a tuple of CLR types from the list of positional arguments that was passed in. If you haven\u2019t seed the *args syntax before, it works like C#\u2019s params keyword \u2013 any extra arguments are passed into the function as a tuple names args. I use Python\u2019s built in map function (FP FTW!) to build a tuple of CLR types of the provided arguments, which I then pass to GetConstructor. Previously, I passed an empty tuple to GetConstructor because I wanted the default constructor. If you don\u2019t pass any positional arguments, you still get the default constructor. Once I\u2019ve found the right constructor, I pass it and the original tuple of arguments to the CustomAttributeBuilder constructor.<\/p>\n<p>One major benefit of this approach is that it simplifies the metaclass code. Since _clrclassattribs is now a list of CustomAttributeBuilders, now I just need to iterate over that list and call SetCustomAttribute for each.<\/p>\n<pre class=\"brush: python\">\nif hasattr(cls, '_clrclassattribs'):\n      for cab in cls._clrclassattribs:\n        typebld.SetCustomAttribute(cab)\n<\/pre>\n<p>The only problem with this approach is that specifying the list of custom attributes is now extremely verbose. Not only am I specifying the full attribute class name as well as the positional arguments, I\u2019m also having to insert a call to make_cab. Previously, it kinda looked like a C# custom attribute, albeit in the wrong place. Not anymore. So I decided to write a function called cab_builder to generates less verbose calls to make_cab:<\/p>\n<pre class=\"brush: python\">\ndef cab_builder(attrib_type):\n  return lambda *args:make_cab(attrib_type, *args)\n\nfrom System import ObsoleteAttribute \nObsolete = cab_builder(ObsoleteAttribute)\n\nclass Product(object):\n  __metaclass__ = ClrTypeMetaclass\n  _clrnamespace = \"DevHawk.IronPython.ClrTypeSeries\"   \n  _clrclassattribs = [Obsolete(\"Warning Lark's Vomit\")]\n\n  # remaining Product class definition omited for clarity\n<\/pre>\n<p>The cab_builder function returns an anonymous lambda function that closes over the attrib_type variable. Python lambdas are just like C# lambdas, except that they only support expressions [1]. The results of calling the lambda returned from cab_builder is exactly the same as calling make_cab directly, but less verbose. And since I named the function returned from cab_builder Obsolete, now my list of class custom attributes looks <em>exactly <\/em>like it does in C# (though still in a different place). As usual, the code is <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/self.aspx\/DevHawk%20Content\/IronPython%20Stuff\/%7C_%7C_clrtype%7C_%7C_\/custom%7C_attrib%7C_with%7C_positional%7C_args.py\">up on my skydrive<\/a>.<\/p>\n<p>If you\u2019re only using the attribute once like this, it is kind of annoying to first declare the cab_builder function. If you wanted to you could iterate over the types in a given assembly, looking for ones that inherit from Attribute and generate the cab_builder call dynamically. However, I\u2019m not sure how performant that would be. Another possibility would be to iterate over the types in a given assembly and generate a Python module on disk with the calls to cab_builder. Then, you\u2019d just have to import this module of common attributes but still be able to include additional calls to cab_builder as needed.<\/p>\n<\/p>\n<p>[1] The lack of statement lambdas in Python is one of my few issues with the language. <\/p>\n","excerpt":"<p>The basic infrastructure for custom attributes in IronPython is in place, but it\u2019s woefully limited. Specifically, it only works for custom attributes that don\u2019t have parameters. Of course, most of the custom attributes that you\u2019d really want to use require additional parameters, both the positional or named variety. Since positional parameters are easier, let\u2019s start [&hellip;]<\/p>\n","date":"2009-06-17 11:02:38","modified":"2009-06-17 11:02:38","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":281,"slug":"__clrtype__","title":"__clrtype__","description":"","post_count":9}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["2687c504-afe1-44a9-a261-fc36de5ac8d8"],"dasblog_compressedtitle":["clrtype+Metaclasses+Positional+Attribute+Parameters"],"dasblog_compressedtitleunique":["2009\/06\/17\/clrtype+Metaclasses+Positional+Attribute+Parameters"]}},"previous_url":"http:\/\/devhawk.net\/2009\/06\/15\/__clrtype__-metaclasses-simple-custom-attributes\/","next_url":"http:\/\/devhawk.net\/2009\/06\/18\/__clrtype__-metaclasses-named-attribute-parameters\/"}