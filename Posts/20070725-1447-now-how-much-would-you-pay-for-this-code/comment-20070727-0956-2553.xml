<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>2553</wp:comment_id>
  <wp:comment_author><![CDATA[Nick Malik]]></wp:comment_author>
  <wp:comment_author_email></wp:comment_author_email>
  <wp:comment_author_url>http://blogs.msdn.com/nickmalik</wp:comment_author_url>
  <wp:comment_author_IP>67.183.175.157</wp:comment_author_IP>
  <wp:comment_date>2007-07-27 09:56:47</wp:comment_date>
  <wp:comment_date_gmt>2007-07-27 16:56:47</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[It's unfortunate that no one answered your questions, Harry.  if they ever do, let me know.

I do thing that the stuff you saw was useful and necessary.  Just, as you point out, probably incomplete.

My personal opinion is that we are serious about code reuse, we need to identify the services that SHOULD be provided by that reusable code.  The .Net framework takes the horizontal approach, and tries to fill in gaps for a dozen different types of projects for any business need.  If we want to do something in IT, it needs to take the opposite approach: build for one or two project types for one or two business needs, but cross all the way up across the stack.  That's right: Components at every level of the stack.

Perhaps something for patterns that connect dynamic user interfaces down through the stacks, including workflow and business rules engine, and through to adapters that save data?  See what I mean?]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>