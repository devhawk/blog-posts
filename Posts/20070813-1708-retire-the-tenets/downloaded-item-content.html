<p>John Heintz and I <a href="http://johnheintz.blogspot.com/2007/08/soa-integration-rpc-and-constraints.html">continue to be</a> in mostly violent agreement. It&#8217;s kinda like me saying &#8220;You da architect! Look at my massive scale EAI Mashup!&#8221; and having him respond &#8220;No, you da architect! The SOA tenets drive me bonkers!&#8221; Makes you wonder what would happen after a few beers. What&#8217;s the architect version of <a href="http://en.wikipedia.org/wiki/Miller_Lite#Advertising">Tastes Great, Less Filling</a>? [1]</p>
<p>Speaking of <a href="http://msdn.microsoft.com/msdnmag/issues/04/01/Indigo/default.aspx#S1">the tenets</a>, John gives them a good shredding:</p>
<blockquote><p>Tenet 1: Boundaries are Explicit<br>(Sure, but isn&#8217;t everything? Ok, so SQL based integration strategies don&#8217;t fall into this category. How do I build a good boundary? What will version better? What has a lower barrier to mashup/integration?)</p>
<p>Tenet 2: Services are Autonomous<br>(Right. This is a great goal, but provides no guidance or boundaries to achieve it.)</p>
<p><strong>Tenet 3: Services share schema and contract, not class</strong><br>(So do all of my OO programs with interface and classes. What is different from OO design that makes SOA something else?)</p>
<p>Tenet 4: Service compatibility is based upon policy<br>(This is a good start: the types and scope of policy can shape an architecture. The policies are the constraints in a system. There not really defined though, just a statement that they should be there.)</p>
<p>Ah, I feel better getting that out.</p>
</blockquote>
<p>As John points out, the four tenets aren&#8217;t particularly useful as guidance. They&#8217;re too high level (like <a href="http://www.nps.gov/mora/">Mt. Rainier</a> high) to be really actionable. They&#8217;re like knowing a pattern&#8217;s name but not understanding how and when to use the actual pattern. However, I don&#8217;t think the tenets were ever intended to be guidance. Instead, they were used to shift the conversation on how to build distributed applications just as Microsoft was introducing the new distributed application stack @ PDC03.</p>
<p>John&#8217;s response to the first tenet makes it sound like having explicit boundaries is obvious. And today, maybe it is. But back in 2003, mainstream platforms typically used a <a href="http://en.wikipedia.org/wiki/Distributed_objects">distributed object</a>&nbsp;approach to building distributed apps. Distributed objects were widely implemented and fairly well understood. You created an object like normal, but the underlying platform would create the actual object on a remote machine. You&#8217;d call functions on your local proxy and the platform would marshal the call across the network to the real object. The network hop would still be there, but the platform abstracted away the mechanics of making it. Examples of distributed object platforms include CORBA via <a href="http://en.wikipedia.org/wiki/Interoperable_Object_Reference">IOR</a>, Java <a href="http://en.wikipedia.org/wiki/Java_remote_method_invocation">RMI</a>, COM via <a href="http://en.wikipedia.org/wiki/Distributed_Component_Object_Model">DCOM</a> and .NET <a href="http://en.wikipedia.org/wiki/.Net_Remoting">Remoting</a>.</p>
<p>The (now well documented and understood) problem with this approach is that distributed objects can&#8217;t be designed like other objects. For performance reasons, distributed objects have to have what Martin Fowler <a href="http://www.ddj.com/architect/184414966">called</a> a &#8220;coarse-grained interface&#8221;, a design which sacrifices flexibility and extensibility in return for minimizing the number of cross-network calls.&nbsp;Because the network overhead can&#8217;t be abstracted away, distributed objects are a very <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">leaky abstraction</a>. </p>
<p>So in 2003, Indigo folks came along and basically said &#8220;You know the distributed object paradigm? The one we&#8217;ve been shipping in our platform since <a href="http://en.wikipedia.org/wiki/NT4">1996</a>? Yeah, turns out we think that&#8217;s the wrong approach.&#8221; Go back and check out <a href="http://www.theserverside.net/tt/talks/videos/DonBox/interview.tss?bandwidth=56k">this interview</a> with Don Box from early 2004. The interviewer asks Don if WCF will &#8220;declare the death of distributed objects&#8221;. Don hems and haws at first, saying &#8220;that&#8217;s probably too strong of a statement&#8221; but then later says that the &#8220;contract, protocol, messaging oriented style will win out&#8221; over distributed objects because of natural selection. </p>
<p>The tenets, IMHO, were really designed to help the Windows developer community wrap their heads around some of the implications of messaging and service orientation. These ideas weren&#8217;t really new &#8211; the four tenets apply to <a href="http://en.wikipedia.org/wiki/Electronic_Data_Interchange">EDI</a>,&nbsp;which has been around for decades. But for a generation of Windows developers who had cut their teeth on DCOM, MTS and VB, it was a significant paradigm shift. </p>
<p>These days, with the tenets going on four years old, the conversation has shifted. Platform vendors are falling over themselves to ship service/messaging stacks like WCF and most developers are looking to these stacks for the next systems they build. Did the tenets do that? In part, I think. Mainstream adoption of RSS was probably the single biggest driver of this paradigm shift, but the tenets certainly helped. Either way, now that service orientation is mainstream, I would say that the tenets&#8217; job is done and it&#8217;s time to retire them. Once you accept the service-oriented paradigm, what further guidance do the tenets provide? Not much, if any. </p>
<p></p>
<hr>
<p>[1] Not that you would catch me drinking Miller Lite. Ever. </p>
