{"status":"ok","post":{"id":752,"type":"post","slug":"thinking-about-object-models","url":"http:\/\/devhawk.net\/2006\/05\/31\/thinking-about-object-models\/","status":"publish","title":"Thinking About Object Models","title_plain":"Thinking About Object Models","content":"<p>I&#8217;m doing some experiments with Amazon&#8217;s S3 Service. Very cool service, I might add. Anyway, the sample C# REST code basically wraps the network requests with a single connection class that has individual methods for each type of service interaction (list all my buckets, list all objects in a bucket, create a bucket, create an object, you get the idea). <\/p>\n<p>However, S3&#8242;s service is a natural hierarchy. The Service contains many Buckets, which in turn contain many Objects. So another way to wrap the service interaction is with a series of objects that are related to one another and only implement the service interactions relevant to that class. (Service would implement List My Buckets and perhaps Create Bucket. Bucket would implement List Objects and Delete Bucket. Again, you get the idea.)<\/p>\n<p>For an interface as relatively simple as S3 (the SOAP interface has a grand total of 13 operations) it probably doesn&#8217;t matter one way or the other. Furthermore, it&#8217;s probably a question of personal preference. My question: What&#8217;s <em>your<\/em> personal preference? A single object with many methods or a hierarchy of objects each with fewer methods?<\/p>\n","excerpt":"<p>I&#8217;m doing some experiments with Amazon&#8217;s S3 Service. Very cool service, I might add. Anyway, the sample C# REST code basically wraps the network requests with a single connection class that has individual methods for each type of service interaction (list all my buckets, list all objects in a bucket, create a bucket, create an [&hellip;]<\/p>\n","date":"2006-05-31 22:54:05","modified":"2006-05-31 22:54:05","categories":[{"id":177,"slug":"architecture","title":"Architecture","description":"","parent":0,"post_count":296}],"tags":[],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2362,"name":"orcmid","url":"http:\/\/orcmid.com\/blog\/","date":"2006-06-01 11:22:17","content":"<p>Well &#8230;. this is a pretty abstract question and circumstances matter.  But I will put on my T-shirt and take an abstracted architectural view.  <\/p>\n<p>First, you need to know that I find classes like CFile to be repelling.  I don&#8217;t like classes like that any more than I like control coupling (one method, many parameters, some parameters say what needs to be done).  It is a separation of concerns for me.  Making it one object and many methods (often hairy ones) is some improvement but basically a dual of the same problem.<\/p>\n<p>OK, it isn&#8217;t so much hierarchy for me although many situations do come out that way, especially when navigating information systems.  But what I see it as is separation of concerns.  The first part has to do with breaking down the work and using helpers and functions that work on parts of the procedure I&#8217;m developing.  What objects do I pass to other methods (for their use), or do I by inheritance graft other methods onto?  Can I keep the surface that I expose to other processes\/objects\/methods be kept small and understandable and invariant (that is, making a contract) and that leaves out everything that is irrelevant stuff.  (Example from CFile &#8212; I may have a process to apply against a file, I should not have to deal with it being able to close, re-open, and otherwise mess with the file I&#8217;ve opened to be processed.)  So I want to pass it a live data stream.  Also, I may want what it does to not interfere with *my* current position in the data stream (or I may want choice in the matter).<\/p>\n<p>Beside separation of concerns and removing extraneous elements from interface agreements (so they are not brittle and are easily preserved over time and substitutions) is the opportunity that factoring objects into hierarchies or subordinates (or interfaces) provides. For example, if you need to be holding onto more than one place under an access, you can arrange your object design to support that.  It&#8217;s like having multiple cursors and enumerators and whatnot.  Also there is no reason to expose write methods on a component that I will only use for reading and that I only want some other service to read with.  That&#8217;s my thinking about all of that. Some of this can be handled by factoring out a nice set of true interfaces and others involve methods that make new objects or that take objects\/interfaces and use them.  <\/p>\n<p>The down side?  This can become too fine-grained and performance and understandability can both go out the window (especially if remoting is happening).  I was reading some code the other day where it began with this traditional stack of declarations where each new one was for an object that was delivered by a method on the object declared and initialized one line above.  It was all to get to one deep &#8220;place&#8221; and the upshot of all this methodology was to insert an element in an XML document being used to hold a configuration.  <\/p>\n<p>So sometimes it is necessary to breach conceptual purity to handle a simple use case.  Nothing wrong with that.  The definition of a shortcut\/accelerator method can be in terms of the &#8220;pure&#8221; ones, and the implementation might be one that performs better.  But it takes all the lifting away from the user and lets the simple thing be done with a simple method.  I&#8217;ve done that in places where it worked quite well (and preserved legacy code that used a flatter model that I had refactored to get a clean conceptual breakdown of the architecture). <\/p>\n<p>It all depends.  It especially depends on whether others (including you later) will be (re-) using what you&#8217;ve done, and how much attention to factoring you can put in up front.<\/p>\n","parent":0},{"id":2363,"name":"01976","url":"","date":"2006-06-16 15:56:50","content":"<p>Hi,<br \/>\nHow do you deal with thinking in so many dimensional thoughts.<br \/>\nOh,well.I way to tired to read your blog right now.my abstract mind would rather look at pictures.<\/p>\n<p>Thanks though,I appreciate your efforts,<br \/>\nThanks, 01976<\/p>\n","parent":0}],"attachments":[],"comment_count":2,"comment_status":"closed","custom_fields":{"dasblog_entryid":["c719933e-eb08-4303-a078-9a4151fd5368"],"dasblog_compressedtitle":["Thinking+About+Object+Models"],"dasblog_compressedtitleunique":["2006\/06\/01\/Thinking+About+Object+Models"]}},"previous_url":"http:\/\/devhawk.net\/2006\/05\/31\/enterprise-2-0-arcast\/","next_url":"http:\/\/devhawk.net\/2006\/06\/02\/june-dsl-ctp\/"}