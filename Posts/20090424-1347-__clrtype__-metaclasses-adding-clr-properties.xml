<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>__clrtype__ Metaclasses: Adding CLR Properties</title>
  <link>http://devhawk.net/2009/04/24/__clrtype__-metaclasses-adding-clr-properties/</link>
  <pubDate>Fri, 24 Apr 2009 13:47:30 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://5d800133-200d-40ec-a7b1-956d49ffaaac</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>When I was first experimenting with __clrtype__, I got to the point of making CLR fields work and then immediately tried to do some data binding with Silverlight. Didn’t work. Turns out Silverlight can only data bind against properties – fields aren’t supported. So now let’s add basic property support to ClrTypeMetaclass. Python has a <a href="http://docs.python.org/library/functions.html#property">rich mechanism</a> for defining properties, but hooking that up requires DLR binders so for now I’m going to generate properties that are simple wrappers around the associated fields.</p><p>There’s enough code involved in defining a property to break it out into it’s own method:</p><p></p><pre class="brush: python">
@staticmethod
  def define_prop(typebld, name, fieldtype, fieldbld):
    attribs = ( MethodAttributes.Public 
              | MethodAttributes.SpecialName 
              | MethodAttributes.HideBySig)
    clrtype = clr.GetClrType(fieldtype)
    
    getbld = typebld.DefineMethod("get_" + name, attribs, clrtype, None)
    getilgen = getbld.GetILGenerator()
    getilgen.Emit(OpCodes.Ldarg_0)
    getilgen.Emit(OpCodes.Ldfld, fieldbld)
    getilgen.Emit(OpCodes.Ret)

    setbld = typebld.DefineMethod("set_" + name, attribs, None, (clrtype,))
    setilgen = setbld.GetILGenerator()
    setilgen.Emit(OpCodes.Ldarg_0)
    setilgen.Emit(OpCodes.Ldarg_1)
    setilgen.Emit(OpCodes.Stfld, fieldbld)
    setilgen.Emit(OpCodes.Ret)

    prpbld = typebld.DefineProperty(name, 
      PropertyAttributes.None, clrtype, None)
    prpbld.SetGetMethod(getbld)
    prpbld.SetSetMethod(setbld)
</pre><p></p><p>You provide define_prop the TypeBuilder for the Type being constructed, the name and type of the property as well as the FieldBuilder that gets returned from the call to DefineField. In the <a href="http://devhawk.net/2009/04/23/clrtype+Metaclasses+Adding+CLR+Fields.aspx">previous installment</a>, I wasn’t bothering to save the FieldBuilder to a variable since I never used it again. Now, I’m stashing it away for the call to define_prop as I’ll show below.</p><p>For each field, we define a get method, a set method and a property. The get function first executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldarg_0.aspx">ldarg_0</a> to load the current object reference onto the execution stack, then it executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldfld.aspx">ldfld</a> to load the specified field from the object onto the stack, then it returns. The set function executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldarg_0.aspx">ldarg_0</a> to load the current object reference and <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldarg_1.aspx">ldarg_1</a> to load the value passed as the first argument onto the execution stack, then it executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.stfld.aspx">stfld</a> to store the value in the specified field of the object. Once I have the two methods, I call DefineProperty to create the PropertyBuilder and then associate the get and set methods with that property. </p><p>As I said before, Reflection.Emit is straightforward though tedious. Honestly, I didn’t go thru the Emit docs to figure out what the methods should look like. Instead, I wrote a basic wrapper property in C# and looked at the generated IL in Reflector. </p><p>The only other change here is adding the call to define_prop on our first iteration thru list of _clrfields. Since the rest of __clrtype__ is the same, here’s just that code snippet:</p><pre class="brush: python">
if hasattr(cls, "_clrfields"):
      for fldname in cls._clrfields: 
        fieldtype = clr.GetClrType(cls._clrfields[fldname])
        fieldbld = typebld.DefineField(fldname, fieldtype, 
                             FieldAttributes.Public)
        ClrTypeMetaclass.define_prop(typebld, fldname, fieldtype, fieldbld)
</pre><p>As I said above, I simply save off the result of calling DefineField so I can pass it to define_prop. I also save off the field type in a variable since I use it more than once. Avoids the second dictionary lookup and is clearer to understand what the function does.</p><p>Accessing the CLR properties via reflection is pretty straightforward – not very different than reflecting over CLR fields. The only significant difference between them is that CLR properties can be indexable and fields can’t, so you have to pass an index parameter to <a href="http://msdn.microsoft.com/en-us/library/b05d59ty.aspx">GetValue</a> and <a href="http://msdn.microsoft.com/en-us/library/xb5dd1f1.aspx">SetValue</a>. These aren’t indexed properties, so I pass in None for the index parameter.</p><pre class="brush: text">
&gt;&gt;&gt; p = Product("Crunchy Frog", 10, 12)
&gt;&gt;&gt; pi = p.GetType().GetProperty("name")
&gt;&gt;&gt; pi.GetValue(p, None)
'Crunchy Frog'
&gt;&gt;&gt; pi.SetValue(p, "Spring Surprise", None)
&gt;&gt;&gt; pi.GetValue(p, None)
'Spring Surprise'
&gt;&gt;&gt; p.name
'Spring Surprise'
</pre><p></p><p>One quick aside about the CLR type I’m generating here. I’m fairly certain this reflected object wouldn’t pass muster with the C# compiler. I’m defining a field and a property with the same name. It clearly works at the IL level, but I’m not sure what the C# compiler would do if you tried to refer to a CLR type like this. I should probably be prepending an underscore or something on the field name, but then I wonder if the field should also be private. There’s a whole API design discussion down that road, but I’m not quite ready to have that yet so I’m just leaving the fields public and having fields and properties with the same name. Luckily, I’m never generating a CLR type on disk so you can’t build a C# project that refers to it anyway.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1254</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-04-24 13:47:30</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-04-24 13:47:30</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">__clrtype__-metaclasses-adding-clr-properties</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="__clrtype__"><![CDATA[__clrtype__]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[5d800133-200d-40ec-a7b1-956d49ffaaac]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[clrtype+Metaclasses+Adding+CLR+Properties]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/04/24/clrtype+Metaclasses+Adding+CLR+Properties]]></wp:meta_value>
  </wp:postmeta>
</item>