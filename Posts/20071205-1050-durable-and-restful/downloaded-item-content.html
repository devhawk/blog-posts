<p>A while back I <a href="http://devhawk.net/2007/06/05/A+REST+Question.aspx">wondered</a> if it&#8217;s still REST if you don&#8217;t use HTTP. The reason I wondered that is because like many I&#8217;ve become disillusioned with the WS-* stack over time and see REST as a viable alternative to all that spec-driven complexity. However, just because I&#8217;m looking to REST means I&#8217;m willing to give up on <a href="http://devhawk.net/2007/05/30/The+Case+For+Durable+Messaging+In+Service+Orientation.aspx">durable messaging</a>. So I shouldn&#8217;t be asking &#8220;can I do REST without HTTP?&#8221; I should be asking &#8220;what protocol can I use to do durable messaging with REST?&#8221;</p>
<p>It turns out HTTP is just fine for RESTful durable messaging, if you take the time to make your POSTs idempotent. There&#8217;s even a IETF RFC that builds on HTTP and specifies a mechanism to do it.</p>
<p>As I wrote last month, <a href="http://devhawk.net/2007/11/09/The+Importance+Of+Idempotence.aspx">idempotence is critically important</a> to ensuring &#8220;things&#8221; happen exactly once when connecting disparate systems together. At the end of that post, I asked you, dear reader, to contemplate just how durable messaging systems ensures exactly once delivery. They do it by assigning messages to be delivered a unique identifier. Any non-idempotent operations can be made idempotent with unique identifiers and a message ID log.</p>
<blockquote><p>&#8220;<u>Not Idempotent</u>: <br>&nbsp;&nbsp;&nbsp;&nbsp; Withdrawing $1 Billion. <br><u>Idempotent</u>: <br>&nbsp;&nbsp;&nbsp;&nbsp; If Haven&#8217;t Yet Done Withdrawal #XYZ for $1 Billion, <br>&nbsp;&nbsp;&nbsp;&nbsp; Then Withdraw $1 Billion and Label as #XYZ&#8221; <br>Pat Helland </p>
</blockquote>
<p>For example, when you send a message in MSMQ, it&#8217;s assigned a <a href="http://msdn2.microsoft.com/en-us/library/ms705091.aspx">20 byte identifier</a> which is &#8220;unique within your enterprise.&#8221; [1] If the destination system receives multiple messages with the same message ID, it knows they are duplicates and can safely toss all but one of the messages with the same ID. Exactly once, no transactions.</p>
<p>While many operations in REST are naturally idempotent, using REST doesn&#8217;t magically make all your operations idempotent, contrary to <a href="http://diveintomark.org/archives/2004/09/29/restagra">popular belief</a>. Have you ever seen a message like &#8220;please don&#8217;t press submit order twice&#8221; on the checkout page of an e-commerce website? It&#8217;s there because POST is <u>not</u> naturally idempotent and the site hasn&#8217;t taken any extra steps to identify duplicate POSTs. If the site embedded a unique ID in a hidden form field, it could use that to identify duplicate orders. </p>
<p>If you&#8217;re a RESTifarian, haven&#8217;t you <a href="http://bitworking.org/projects/atom/rfc5023.html">seen this approach somewhere before</a>?</p>
<p>Given that POST isn&#8217;t <u>naturally</u> idempotent, I think it&#8217;s kinda surprising that new <a href="http://bitworking.org/projects/atom/rfc5023.html#crwp">resources are created in AtomPub</a> by POSTing them to a collection rather than PUTting them to a specific URL. <a href="http://www.oreilly.com/catalog/9780596529260/" target="_blank">RESTful Web Services</a> specifically points out that PUT is idempotent, so I wonder why AtomPub uses POST. I&#8217;d guess most AtomPub implementations (aka blogs) aren&#8217;t much concerned about ensuring Exactly Once. If an blog entry gets posted twice, you delete one and go on with your life. </p>
<p>However, if you wanted to use AtomPub and ensure Exactly Once, you can use the fact that Atom entries <a href="http://tools.ietf.org/html/rfc4287#section-4.1.2">must contain exactly one ID element</a> which as per the spec <a href="http://tools.ietf.org/html/rfc4287#section-4.2.6">must be universally unique</a>. From reading the Atom spec, the ID element seems primarily designed for Atom feed consumers, but AtomPub servers could also use it as an &#8220;idempotence identifier&#8221;, similar to how MSMQ uses the message ID. If you end up with multiple entries with the same entry ID, discard all but one.</p>
<p>So by creating a unique identifier on the client side and logging that identifier on the server side, we can make any REST service idempotent. We can make it a durable service if we write the outgoing message &#8211; with the message ID we generate &#8211; to a durable store before trying to send it. If you write it to a durable store within the scope of a local transaction, you&#8217;re even closer to duplicating MSMQ&#8217;s functionality, yet the only protocol requirement beyond vanilla HTTP is having a unique message ID.</p>
<p>The one problem with the Atom entity ID approach is that it requires cracking the message in order to see if we should process it. For REST services, I would think we&#8217;d want to stick the idempotence identifier in an HTTP header. We already headers to implement <a href="http://fishbowl.pastiche.org/2002/10/21/http_conditional_get_for_rss_hackers">conditional GET</a>, why not a header for what amounts to conditional POST?</p>
<p>Turns out such a header exists in the <a href="http://www.ietf.org/rfc/rfc4130.txt" target="_blank">AS2 spec</a>, i.e. &#8220;MIME-Based Secure Peer-to-Peer Business Data Interchange Using HTTP&#8221;. AS2 defines a <a href="http://tools.ietf.org/html/rfc4130#section-5.3.3" target="_blank">Message-Id HTTP header</a> which &#8220;SHOULD be globally unique&#8221;. In the case of <a href="http://tools.ietf.org/html/rfc4130#section-5.5" target="_blank">an HTTP error</a>, AS2 specifies the &#8220;POST operation with identical content, including same Message-ID, SHOULD be repeated&#8221; and that &#8220;Servers SHOULD be prepared to receive a POST with a repeated Message-ID.&#8221; I assume this implies a server shouldn&#8217;t process a message with the same ID twice.</p>
<p>So what would a durable REST service look like? I think like this:</p>
<ol>
<li>Sending system records the intent to send a message by saving it to a local durable store, potentially in the scope of a local transaction. As part of saving the message, a unique message id is generated (I&#8217;d use a <a href="http://en.wikipedia.org/wiki/Guid" target="_blank">GUID</a>, but as long as it&#8217;s unique it doesn&#8217;t matter.)
</li>
<li>A background thread in the sending system monitors the durable message store. When a new to-be-sent message arrives, the thread POSTs it to the destination, setting the Message-Id HTTP header to the unique identifier generated in step 1.
</li>
<li>The receiving system stores the Message-Id header value in a log table and processes the received message, potentially in the scope of a local transaction. Optionally, it can store the return message (if there is one) in the durable store as well.
</li>
<li>If the sending system doesn&#8217;t receive a 2xx status code, it rePOSTs the message to the receiving system until it does.
</li>
<li>If the receiving system receives a message that&#8217;s already listed in the log table, it ignores it and returns a success status code. Optionally, if the return message has been saved, the receiving system can resend the return message as long as it doesn&#8217;t redo the work.</li>
</ol>
<p>This seems like a better approach than my original direction of doing REST over a durable protocol like MSMQ or SSB. What do you think? </p>
<p>UPDATE &#8211; <a class="commentPermalinkStyle" href="http://appside.blogspot.com/" rel="nofollow"><font color="#017cbc">Erik Johnson</font></a>&nbsp;<a href="http://devhawk.net/CommentView,guid,becd3f0f-5484-4a9e-ae6a-4a61cebc2a4a.aspx#commentstart">points out</a> that an HTTP POST&#8217;s idempotency is &#8220;left unsaid&#8221;. So my statement that &#8220;POST isn&#8217;t idempotent&#8221; isn&#8217;t quite correct. POST isn&#8217;t <em>naturally</em> idempotent. I&#8217;ve updated the post accordingly.</p>
<p></p>
<hr>
<p>[1] Technically, the MSMQ message ID isn&#8217;t universally unique as it is a 16 byte GUID representing the source system + a 4 byte sequence number. The sequence number can rollover, after sending 2^32 messages. In practice, rolling over the message ID after 4 billion messages is rarely an issue.</p>
