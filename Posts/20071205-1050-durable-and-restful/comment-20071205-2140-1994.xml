<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>1994</wp:comment_id>
  <wp:comment_author><![CDATA[Erik Johnson]]></wp:comment_author>
  <wp:comment_author_email>ejohnson@epicor.com</wp:comment_author_email>
  <wp:comment_author_url>http://appside.blogspot.com</wp:comment_author_url>
  <wp:comment_author_IP>70.181.194.38</wp:comment_author_IP>
  <wp:comment_date>2007-12-05 21:40:18</wp:comment_date>
  <wp:comment_date_gmt>2007-12-06 05:40:18</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[> Given that POST isn't idempotent...

But like you said, idempotency is in the eye of the HTTP implementor.  The HTTP spec says that PUT and GET are meant to be idempotent and leaves the idempotency (is that a word?) of POST lesft unsaid.  It doesn't say POST MUST NOT be idempotent.  

One issue with PUT is that the spec says that I am saving a whole resource (replacing the data rep) which implies a programming model around that semantic.  There's nothing wrong with that, but it might not be the best fit for Pat's withdraw-a-billion-bucks scenario.

POST just says I am handing data to a processor.  Your notion of having the implementing the idempotent behavior using HTTP headers is fine.  So does putting the message ID tags inside the payload.  Since the HTTP spec leaves the implementation of idempotency up to you (for all verbs) both are equally cool for RESTful apps.

Anyway, I just wanted to point out that POST doesn't have to mean non-idempotent -- and then I started rambling as usual.]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>