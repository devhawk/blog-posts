<p>Back at <a href="http://www.cs.princeton.edu/~dpw/popl/06/">POPL 06</a>, <a href="http://en.wikipedia.org/wiki/Tim_Sweeney_(game_developer)">Tim Sweeny</a> of <a href="http://www.epicgames.com/">Epic Games</a> delivered a talk titled &#8220;<a href="http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt">The Next Mainstream Programming Language: A Game Developer&#8217;s Perspective</a>&#8220;. I imagine he was a little too busy getting <a href="http://www.gearsofwar.com/">Gears of War</a> out the door to attend the <a href="http://www.langnetsymposium.com/">Lang.NET Symposium</a>. Too bad, as there were interesting solutions presented that solved two of the issues Tim identified in his his POPL talk.</p>
<p>One of the issues Tim identified is one of Modularity. Gears of War uses the <a href="http://www.unrealtechnology.com/html/technology/ue30.shtml">Unreal Engine 3</a>. In other words, UE3 is a game framework and GoW uses that framework. As you might expect, this framework is exposed as a hierarchy of objects. Tim&#8217;s example had &#8220;Actor&#8221; as the base class in the framework hierarchy, with classes like &#8220;Player&#8221;, &#8220;Enemy&#8221; and &#8220;InventoryItem&#8221; inheriting from &#8220;Actor&#8221;. Then he had game-specific classes like &#8220;Dragon&#8221; and &#8220;Sword&#8221; inheriting from the generic &#8220;Enemy&#8221; class. The problem is that game developers also need to extend the functionality of the framework&#8217;s base classes. That is, they need a game-specific version of &#8220;Actor&#8221; or &#8220;InventoryItem&#8221; in addition to the game specific subclasses like &#8220;Dragon&#8221; and &#8220;Sword&#8221;. Unfortunately, the current generation of languages don&#8217;t support this, so game developers often clone the entire framework, which is error-prone and hard to support.</p>
<p>At Lang.NET, <a href="http://www.cs.iastate.edu/~lumpe/">Professor Markus Lumpe</a> demonstrated an implementation of the Classbox concept for .NET. Classbox is essentially a solution to the modularity problem Tim identified. They&#8217;ve modified C#&#8217;s using syntax to apply to individual classes. When using a class in this fashion, you can add extensions to it like new methods and new fields. I&#8217;m not sure the scope of these extensions &#8211; whether it&#8217;s the file with the using clause or the containing assembly &#8211; but it&#8217;s key to realize this is a local extension. The original framework isn&#8217;t modified at all. Within you assembly, the metadata for the extended classes is re-written to include the new extension. So to use Tim&#8217;s example, if you extended the framework&#8217;s &#8220;Actor&#8221; class, it would create a YourGame.Actor class that inherited from the Framework.Actor and contained your extensions. Then it would re-write the inheritance metadata (again, only for your assembly) so classes that inherited from Framework.Actor such as Framework.Enemy and Framework.InventoryItem now inherit from YourGame.Actor.</p>
<p>Now I&#8217;m sure there are some nefarious uses of this type of inheritance tree hacking. But there are scenarios such as Tim&#8217;s Gaming Framework example where this behavior is exactly what you want. I spoke briefly to Markus and at length with Hua Ming, one of Markus&#8217; grad students, about perhaps having a keyword indicating that a class is &#8220;classbox enabled&#8221; rather than allowing any class to be classboxed in this way. Looking forward to their future work.</p>
<p>Another issue Tim identified was Reliability. He called this problem &#8220;If the compiler doesn&#8217;t beep, my program should work&#8221;. He showed a very simple method to iterate an index array and transform the associated vertex from a vertex array by a provided matrix. A simple function &#8211; four lines of code. Yet, the compiler can&#8217;t detect null pointer or out-of-bound array access. Adding code to check those runtime conditions would easily double or triple the length of the function. While modern managed languages (C#/VB/Java) have made great strides in eliminating &#8220;random memory overwrites&#8221; (via type safety) and &#8220;memory leaks&#8221; (via garbage collection) they don&#8217;t help you with these other types of dynamic failures.</p>
<p>At Lang.NET, Microsoft Researcher <a href="http://research.microsoft.com/users/mbarnett/">Mike Barnett</a> demonstrated <a href="http://research.microsoft.com/specsharp/">Spec#.</a> Spec# is a superset of C# that solves these and other types of dynamic errors. The idea, in Mike&#8217;s words, is to better bridge developer intent and code by embedding certain specifications into the code itself. Furthermore, it uses a combination of static and data flow analysis to detect the types of dynamic errors Tim described in his talk. So if you took Tim&#8217;s simple transform function and fed it into the Spec# compiler, it would warn you of the possible null pointer dereferences. Furthermore, you can eliminate this warning by specifying the caller never pass you a null pointer. This is simply accomplished by adding an exclamation point to the type declaration. In other words, the vertex array method parameter would be declared &#8220;Vertex[]! vertices&#8221; to indicate you can&#8217;t pass in a null array. With Spec#, you can also specify method pre and post conditions, which can solve the out-of-bound array access issue, as well as object invariants, which can specify the valid states an object instance can be in.</p>
<p>I didn&#8217;t see Tim give this&nbsp;presentation, I only saw the slides after the fact. But I get the feeling that one of Tim&#8217;s points is that game development is extremely cutting edge, and the issues they&#8217;re running into now will be mainstream issues in a few years. Good to see language researchers are already well on their way to solving these issues. </p>
<p>The only thing I worry about is when will these ideas make it into mainstream languages? And will they be extensions to existing languages &#8211; i.e. will C# 4.0 and VB 10 include classboxing and specifications &#8211; or will they be entirely new languages? How much can you improve a language by adding features until it collapses under it&#8217;s own weight?</p>
