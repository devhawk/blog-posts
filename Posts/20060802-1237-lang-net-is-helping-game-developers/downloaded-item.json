{"status":"ok","post":{"id":778,"type":"post","slug":"lang-net-is-helping-game-developers","url":"http:\/\/devhawk.net\/2006\/08\/02\/lang-net-is-helping-game-developers\/","status":"publish","title":"Lang.NET Is Helping Game Developers","title_plain":"Lang.NET Is Helping Game Developers","content":"<p>Back at <a href=\"http:\/\/www.cs.princeton.edu\/~dpw\/popl\/06\/\">POPL 06<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Tim_Sweeney_(game_developer)\">Tim Sweeny<\/a> of <a href=\"http:\/\/www.epicgames.com\/\">Epic Games<\/a> delivered a talk titled &#8220;<a href=\"http:\/\/www.cs.princeton.edu\/~dpw\/popl\/06\/Tim-POPL.ppt\">The Next Mainstream Programming Language: A Game Developer\u2019s Perspective<\/a>&#8220;. I imagine he was a little too busy getting <a href=\"http:\/\/www.gearsofwar.com\/\">Gears of War<\/a> out the door to attend the <a href=\"http:\/\/www.langnetsymposium.com\/\">Lang.NET Symposium<\/a>. Too bad, as there were interesting solutions presented that solved two of the issues Tim identified in his his POPL talk.<\/p>\n<p>One of the issues Tim identified is one of Modularity. Gears of War uses the <a href=\"http:\/\/www.unrealtechnology.com\/html\/technology\/ue30.shtml\">Unreal Engine 3<\/a>. In other words, UE3 is a game framework and GoW uses that framework. As you might expect, this framework is exposed as a hierarchy of objects. Tim&#8217;s example had &#8220;Actor&#8221; as the base class in the framework hierarchy, with classes like &#8220;Player&#8221;, &#8220;Enemy&#8221; and &#8220;InventoryItem&#8221; inheriting from &#8220;Actor&#8221;. Then he had game-specific classes like &#8220;Dragon&#8221; and &#8220;Sword&#8221; inheriting from the generic &#8220;Enemy&#8221; class. The problem is that game developers also need to extend the functionality of the framework&#8217;s base classes. That is, they need a game-specific version of &#8220;Actor&#8221; or &#8220;InventoryItem&#8221; in addition to the game specific subclasses like &#8220;Dragon&#8221; and &#8220;Sword&#8221;. Unfortunately, the current generation of languages don&#8217;t support this, so game developers often clone the entire framework, which is error-prone and hard to support.<\/p>\n<p>At Lang.NET, <a href=\"http:\/\/www.cs.iastate.edu\/~lumpe\/\">Professor Markus Lumpe<\/a> demonstrated an implementation of the Classbox concept for .NET. Classbox is essentially a solution to the modularity problem Tim identified. They&#8217;ve modified C#&#8217;s using syntax to apply to individual classes. When using a class in this fashion, you can add extensions to it like new methods and new fields. I&#8217;m not sure the scope of these extensions &#8211; whether it&#8217;s the file with the using clause or the containing assembly &#8211; but it&#8217;s key to realize this is a local extension. The original framework isn&#8217;t modified at all. Within you assembly, the metadata for the extended classes is re-written to include the new extension. So to use Tim&#8217;s example, if you extended the framework&#8217;s &#8220;Actor&#8221; class, it would create a YourGame.Actor class that inherited from the Framework.Actor and contained your extensions. Then it would re-write the inheritance metadata (again, only for your assembly) so classes that inherited from Framework.Actor such as Framework.Enemy and Framework.InventoryItem now inherit from YourGame.Actor.<\/p>\n<p>Now I&#8217;m sure there are some nefarious uses of this type of inheritance tree hacking. But there are scenarios such as Tim&#8217;s Gaming Framework example where this behavior is exactly what you want. I spoke briefly to Markus and at length with Hua Ming, one of Markus&#8217; grad students, about perhaps having a keyword indicating that a class is &#8220;classbox enabled&#8221; rather than allowing any class to be classboxed in this way. Looking forward to their future work.<\/p>\n<p>Another issue Tim identified was Reliability. He called this problem &#8220;If the compiler doesn\u2019t beep, my program should work&#8221;. He showed a very simple method to iterate an index array and transform the associated vertex from a vertex array by a provided matrix. A simple function &#8211; four lines of code. Yet, the compiler can&#8217;t detect null pointer or out-of-bound array access. Adding code to check those runtime conditions would easily double or triple the length of the function. While modern managed languages (C#\/VB\/Java) have made great strides in eliminating &#8220;random memory overwrites&#8221; (via type safety) and &#8220;memory leaks&#8221; (via garbage collection) they don&#8217;t help you with these other types of dynamic failures.<\/p>\n<p>At Lang.NET, Microsoft Researcher <a href=\"http:\/\/research.microsoft.com\/users\/mbarnett\/\">Mike Barnett<\/a> demonstrated <a href=\"http:\/\/research.microsoft.com\/specsharp\/\">Spec#.<\/a> Spec# is a superset of C# that solves these and other types of dynamic errors. The idea, in Mike&#8217;s words, is to better bridge developer intent and code by embedding certain specifications into the code itself. Furthermore, it uses a combination of static and data flow analysis to detect the types of dynamic errors Tim described in his talk. So if you took Tim&#8217;s simple transform function and fed it into the Spec# compiler, it would warn you of the possible null pointer dereferences. Furthermore, you can eliminate this warning by specifying the caller never pass you a null pointer. This is simply accomplished by adding an exclamation point to the type declaration. In other words, the vertex array method parameter would be declared &#8220;Vertex[]! vertices&#8221; to indicate you can&#8217;t pass in a null array. With Spec#, you can also specify method pre and post conditions, which can solve the out-of-bound array access issue, as well as object invariants, which can specify the valid states an object instance can be in.<\/p>\n<p>I didn&#8217;t see Tim give this\u00a0presentation, I only saw the slides after the fact. But I get the feeling that one of Tim&#8217;s points is that game development is extremely cutting edge, and the issues they&#8217;re running into now will be mainstream issues in a few years. Good to see language researchers are already well on their way to solving these issues. <\/p>\n<p>The only thing I worry about is when will these ideas make it into mainstream languages? And will they be extensions to existing languages &#8211; i.e. will C# 4.0 and VB 10 include classboxing and specifications &#8211; or will they be entirely new languages? How much can you improve a language by adding features until it collapses under it&#8217;s own weight?<\/p>\n","excerpt":"<p>Back at POPL 06, Tim Sweeny of Epic Games delivered a talk titled &#8220;The Next Mainstream Programming Language: A Game Developer\u2019s Perspective&#8220;. I imagine he was a little too busy getting Gears of War out the door to attend the Lang.NET Symposium. Too bad, as there were interesting solutions presented that solved two of the [&hellip;]<\/p>\n","date":"2006-08-02 12:37:41","modified":"2006-08-02 12:37:41","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":229,"slug":"lanugages","title":"Lanugages","description":"","post_count":43}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2396,"name":"orcmid","url":"http:\/\/miser-theory.info\/astraendo\/pn","date":"2006-08-03 12:42:26","content":"<p>You were there?  Dang, I should have worn my &#8220;The Architect is In&#8221; T-Shirt.  <\/p>\n<p>The more I talked to others, including some people from the BCL Team on Tuesday night, the more that class boxing the way Markus did it seems useful.  I rarely want simple inheritance off of an existing class.  I usually need to come up with a &#8220;parallel&#8221; class hierarchy that injects extensions\/contractions on the interfaces of the original hierarchy.<\/p>\n<p>By the way, that was an awesome symposium.  On Monday there was no moment that I was wishing that I could check my e-mail instead.<\/p>\n<p>PS: Spec# can be done entirely in the IDE, as far as I can tell. That makes it a very rich idea.  I think it will be far more acceptable than formal verification, especially in use on production development projects.  (Think if FX cop but with way fewer need for test cases &#8212; the reduction of test-coverage burden should pay for Spec# use hundreds of times over.)<\/p>\n","parent":0},{"id":2397,"name":"orcmid","url":"http:\/\/miser-theory.info\/astraendo\/pn","date":"2006-08-03 16:29:43","content":"<p>Well, I pulled the trigger a little too quickly there.  <\/p>\n<p>There are some language tweaks that the Spec# folk put into the C# language (for example) to make it easier to assert that a reference is not allowed to be null, that sort of thing.  There are probably decorations that would not require fudging with the language, and then there might be some sugar to make the decorations less painful.  But basically, the main work and the game of verifying the assertions is accomplished with an integration into the IDE.<\/p>\n","parent":0}],"attachments":[],"comment_count":2,"comment_status":"closed","custom_fields":{"dasblog_entryid":["72b02910-07e9-41a0-958e-d63a9c6d15db"],"dasblog_compressedtitle":["LangNET+Is+Helping+Game+Developers"],"dasblog_compressedtitleunique":["2006\/08\/02\/LangNET+Is+Helping+Game+Developers"]}},"previous_url":"http:\/\/devhawk.net\/2006\/08\/01\/more-on-lang-net\/","next_url":"http:\/\/devhawk.net\/2006\/08\/02\/is-sml-another-unwanted-modeling-language\/"}