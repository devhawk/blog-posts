{"status":"ok","post":{"id":1213,"type":"post","slug":"ironpython-and-codedom-dynamically-compiling-c-files","url":"http:\/\/devhawk.net\/2009\/01\/29\/ironpython-and-codedom-dynamically-compiling-c-files\/","status":"publish","title":"IronPython and CodeDOM: Dynamically Compiling C# Files","title_plain":"IronPython and CodeDOM: Dynamically Compiling C# Files","content":"<p>As part of my series on <a href=\"http:\/\/devhawk.net\/2008\/11\/13\/IronPython+And+WPF+Part+1+Introduction.aspx\">using IronPython with WPF<\/a> [1], I built an extension method in C# that does <a href=\"http:\/\/devhawk.net\/2008\/11\/14\/IronPython+And+WPF+Part+2+Loading+XAML.aspx\">dynamic member resolution on WPF FrameworkElements<\/a>. The upshot of this code is that I can write \u201cwin1.listbox1\u201d instead of \u201cwin1.FindName(\u2018listbox1\u2019)\u201d when using WPF objects from Python or any DLR language. Convenient, right?<\/p>\n<p>The problem with this approach is that the C# extension method gets compiled into an assembly that\u2019s bound to a specific version of the DLR. I recently started experimenting with a <a href=\"http:\/\/nightlybuilds.cloudapp.net\/Project.aspx?project=ironpython\">more recent build<\/a> of IronPython and I couldn\u2019t load the extension method assembly due to a conflict between the different versions of Microsoft.Scripting.dll. Of course, I could have simply re-compiled the assembly against the new bits, but that would mean every time I moved to a new version of IronPython, I\u2019d have to recompile. Worse, it would limit my ability to run multiple versions of IronPython on my machine at once. I currently have three \u2013 count \u2018em, *three* \u2013 copies of IronPython installed: <a href=\"http:\/\/www.codeplex.com\/IronPython\/Release\/ProjectReleases.aspx?ReleaseId=8365\">2.0 RTM<\/a>, <a href=\"http:\/\/nbs.blob.core.windows.net\/ironpython\/IronPython.46242.release.zip\">nightly build version 46242<\/a>, and an internal version <a href=\"http:\/\/devhawk.net\/2008\/09\/17\/DLR+Namespace+Change+Fire+Drill.aspx\">without the mangled namespaces<\/a> of our public CodePlex releases. Having to manage multiple copies of my extension assembly would get annoying very quickly.<\/p>\n<p>Instead of adding a reference to the compiled assembly, what if I could add a reference to a C# file directly? Kinda like how adding references to Python files works, but for statically compiled C#. That would let me write code like the following, which falls back to adding a reference to the C# file directly if adding a reference to the compiled assembly fails.<\/p>\n<pre class=\"brush: python\">try:\r\n  clr.AddReference('Microsoft.Scripting.Extension.Wpf.dll')\r\nexcept:\r\n  import codedom\r\n  codedom.add_reference_cs_file('FrameworkElementExtension.cs',\r\n    ['System', 'WindowsBase', 'PresentationFramework',\r\n     'PresentationCore', 'Microsoft.Scripting'])<\/pre>\n<p>Since this technique uses <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/f1dfsbhc.aspx\">CodeDOM<\/a>, I decided to encapsulate the code in a Python module named codedom, which is frankly pretty simple. As a shout-out to my pals on the <a href=\"http:\/\/blogs.msdn.com\/vbteam\/\">VB team<\/a>, I broke compiling out into it\u2019s own separate function so I could easily support adding VB as well as C# files.<\/p>\n<pre class=\"brush: python\">def compile(prov, file, references):\r\n  cp = CompilerParameters()\r\n  cp.GenerateInMemory = True\r\n  for ref in references:\r\n    a = Assembly.LoadWithPartialName(ref)\r\n    cp.ReferencedAssemblies.Add(a.Location)\r\n  cr = prov.CompileAssemblyFromFile(cp, file)\r\n  if cr.Errors.Count &gt; 0:\r\n    raise Exception(cr.Errors)\r\n  return cr.CompiledAssembly\r\n\r\ndef add_reference_cs_file(file, references):\r\n  clr.AddReference(compile(CSharpCodeProvider(), file, references))\r\n\r\ndef add_reference_vb_file(file, references):\r\n  clr.AddReference(compile(VBCodeProvider(), file, references))<\/pre>\n<p>The compile function uses a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.codedom.compiler.codedomprovider.aspx\">CodeDOM provider<\/a>, which provides a convenient function to <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.codedom.compiler.codedomprovider.compileassemblyfromfile.aspx\">compile an assembly from a single file<\/a>. The only tricky part was adding the references correctly. Of the five references in this example, the only one CodeDOM can locate automatically is System.dll. For the others, it appears that CodeDOM needs the full path to the assembly in question.<\/p>\n<p>Of course, hard-coding the assembly paths in my script would be too fragile, so instead I use partial names. I load each referenced assembly via <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.assembly.loadwithpartialname.aspx\">Assembly.LoadWithPartialName<\/a> then pass it\u2019s Location to the CodeDOM provider via the CompilerParameters object. I realize that loading an assembly just to find its location it kind of overkill but a) I couldn\u2019t find another mechanism to locate an assemblies location given only a partial name and b) I\u2019m going to be loading the referenced assemblies when I load the generated assembly anyway, so I figured it loading them to find their location wasn\u2019t a big deal. Note, that typically you\u2019re used to passing a string to clr.AddReference, but it also can accept an assembly object directly.<\/p>\n<p>Of course, this approach isn\u2019t what you would call \u201cfast\u201d. Loading the pre-compiled assembly is much, <em>much<\/em> faster than compiling the C# file on the fly. But I figure slow code is better than code that doesn\u2019t work at all. Besides, the way the code is written, I only take the extra compile hit if the pre-compiled assembly won\u2019t load.<\/p>\n<p>I stuck my <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/self.aspx\/DevHawk%20Content\/IronPython%20Stuff\/codedom.py\">codedom.py<\/a> file up on my SkyDrive. Feel free to leverage as you need.<\/p>\n<hr \/>\n<p>[1] I had to put that series on the back burner in part because the <a href=\"http:\/\/windowslivewire.spaces.live.com\/blog\/cns!2F7EB29B42641D59!26304.entry\">December update to Windows Live<\/a> totally broke my WPF photo viewing app. I\u2019ve got a new WPF app I\u2019m working on, but I\u2019m not quite ready to blog about it yet.<\/p>\n","excerpt":"<p>As part of my series on using IronPython with WPF [1], I built an extension method in C# that does dynamic member resolution on WPF FrameworkElements. The upshot of this code is that I can write \u201cwin1.listbox1\u201d instead of \u201cwin1.FindName(\u2018listbox1\u2019)\u201d when using WPF objects from Python or any DLR language. Convenient, right? The problem with [&hellip;]<\/p>\n","date":"2009-01-29 16:53:30","modified":"2011-04-17 01:02:18","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":235,"slug":"c-sharp","title":"C#","description":"","post_count":17}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["34f7ae3f-7d89-46d9-832a-981283b8df2f"],"dasblog_compressedtitle":["IronPython+And+CodeDOM+Dynamically+Compiling+C+Files"],"dasblog_compressedtitleunique":["2009\/01\/30\/IronPython+And+CodeDOM+Dynamically+Compiling+C+Files"]}},"previous_url":"http:\/\/devhawk.net\/2009\/01\/21\/thoughts-from-inauguration-day\/","next_url":"http:\/\/devhawk.net\/2009\/02\/09\/register-now-for-lang-net-symposium-2009\/"}