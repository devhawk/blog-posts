{"status":"ok","post":{"id":1293,"type":"post","slug":"hybrid-app-debugging-tracebackdelegate-and-settrace","url":"http:\/\/devhawk.net\/2009\/10\/07\/hybrid-app-debugging-tracebackdelegate-and-settrace\/","status":"publish","title":"Hybrid App Debugging &#8211; TracebackDelegate and SetTrace","title_plain":"Hybrid App Debugging &#8211; TracebackDelegate and SetTrace","content":"<p>Now that I\u2019ve introduced my <a href=\"http:\/\/devhawk.net\/2009\/10\/06\/Lightweight+Debugging+For+Hybrid+CIronPython+Apps.aspx\">simple hybrid GetThings app<\/a>, we need to set about adding support for debugging just the IronPython part of the app via the new lightweight debugging functionality we\u2019re introducing in 2.6. Note, the code is <a href=\"http:\/\/github.com\/devhawk\/LightweightDebuggerDemo\">up on github<\/a>, but isn\u2019t going to exactly match what I show on the blog. Also, I have a post RC1 daily build of IronPython in the <a href=\"http:\/\/github.com\/devhawk\/LightweightDebuggerDemo\/tree\/deac85aaf14b37352ce4248917fd857c173d8997\/External\">Externals folder<\/a> since I discovered a few issues while building this sample that Dino had to fix after RC1. Those assemblies will be updated as needed as the sample progresses.<\/p>\n<p>We saw last time how how easy it is to execute a Python script to configure a C# app \u2013 only four lines of code. If we want to support debugging, we need to add a fifth:<\/p>\n<pre class=\"brush: csharp\">\nprivate void Window_Loaded(object sender, RoutedEventArgs e)\n{\n    ScriptEngine engine = Python.CreateEngine();\n    engine.SetTrace(this.OnTraceback);\n\n    ScriptScope s = engine.CreateScope();\n    s.SetVariable(\"items\", lbThings.Items);\n    engine.ExecuteFile(\"getthings.py\", s);\n}\n<\/pre>\n<p>You\u2019ll notice the one new line \u2013 the call to engine.SetTrace. This is actually an extension method \u2013 ScriptEngine is a DLR hosting API class and but SetTrace is IronPython specific functionality [1]. If you look at the source of Python.SetTrace, you\u2019ll see that it\u2019s just a wrapper around SysModule.settrace, but it avoids needing to get the engine\u2019s shared PythonContext yourself.<\/p>\n<p>SetTrace takes a TracebackDelegate as a parameter. That delegate gets registered as the global traceback handler for the Python engine (on that thread, but we\u2019ll ignore threading for now). Whenever that engine enters a new scope (i.e. a new function), the IronPython runtime calls into the global traceback handler. While the traceback handler runs, execution of the python code in that engine is paused. When the traceback handler returns, the engine resumes executing python code.<\/p>\n<p>In addition to the global traceback handler, each scope has a local traceback handler as well. The TracebackDelegate type returns a TracebackDelegate which is used as the local traceback handler for the next traceback event within that scope. Traceback handlers can return themselves, some other TracebackDelegate, or null if they don\u2019t want any more traceback events for the current scope. It\u2019s kinda confusing, so here\u2019s a picture:<\/p>\n<p><a href=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/HybridAppDebuggingTracebackDelegateandSe_F502\/image_10.png\" class=\"grouped_elements\" rel=\"tc-fancybox-group1293\"><img style=\"border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto\" title=\"image\" border=\"0\" alt=\"image\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/HybridAppDebuggingTracebackDelegateandSe_F502\/image_thumb_4.png\" width=\"514\" height=\"206\" \/><\/a><\/p>\n<p>You\u2019ll notice three different traceback event types in the picture above: call, line and return. Call indicates the start of a scope, and is always invoked on the global traceback handler (i.e. the traceback passed to SetTrace). Line indicates the Python engine is about to execute a line of code and return indicates the end of a scopes execution. As you can see, the runtime uses the return value of the traceback for the next tracing call until the end of the scope. The return value from the \u201creturn\u201d event handler is ignored. <\/p>\n<p>So now that we know the basics of traceback handlers, here\u2019s a simple TracebackDelegate that simply returns itself. The \u201cHello, world!\u201d of traceback debugging if you will.<\/p>\n<pre class=\"brush: csharp\">\nprivate TracebackDelegate OnTraceback\n    (TraceBackFrame frame, string result, object payload)\n{\n    return this.OnTraceback;\n}\n<\/pre>\n<p>If you run this code, there will be no functional difference from the code before you added the SetTrace call. That\u2019s because we\u2019re not doing anything in the traceback handler. But if you run this in the debugger with a breakpoint on this function, you\u2019ll see that it gets called a bunch of times. In the python code <a href=\"http:\/\/devhawk.net\/2009\/10\/06\/Lightweight+Debugging+For+Hybrid+CIronPython+Apps.aspx\">from the last post<\/a>, there are three scopes \u2013 module scope, download_stuff function scope and the get_nodes function scope. Each of those function scopes will have a call and return event, plus a bunch of line events in between. <\/p>\n<p>The parameters for TracebackDelegate are described <a href=\"http:\/\/docs.python.org\/library\/sys.html#sys.settrace\">in the Python docs<\/a>. The frame parameter is the current stack frame \u2013 it has information about the local and global variables, the code object currently executing, the line number being executed and a pointer to the previous stack frame if there is one. More information on code and frame objects is available in the <a href=\"http:\/\/docs.python.org\/reference\/datamodel.html#the-standard-type-hierarchy\">python data model<\/a> (look for \u201cinternal types\u201d). Result is the reason why the traceback function is being called (in Python docs, it\u2019s called \u201cevent\u201d but that\u2019s a keyword in C#). IronPython supports four traceback results: \u201ccall\u201d, \u201cline\u201d and \u201creturn\u201d as described above plus \u201cexception\u201d when an exception is thrown. Finally, the payload value\u2019s meaning depends on the traceback result. For call and line, payload is null. For return, payload is the value being returned from the function. For exception, the payload is information about the exception and where it was thrown. <\/p>\n<p>As I mentioned above, python code execution is paused while the traceback handler executes and then continues when the traceback handler returns. That means you need to block in that function if you want to let the user interact with the debugger. For a console app like PDB, you can do that with a single thread of execution easily enough. For a GUI app like GetThings, that means running the debugger and debugee windows on separate threads. And as I alluded to, tracing for Python script engines is per thread. So next time, we\u2019ll look deeper into how to use multiple threads for lightweight debugging a hybrid app.<\/p>\n<hr \/>\n<p>[1] Eventually, I\u2019d like to see IronRuby support lightweight debugging as well. However, there\u2019s no built in mechanism for Ruby debugging the way there is for Python, so it\u2019s less clear how we should expose debugging to the Ruby developer. We\u2019d also want to build a language neutral DLR Hosting API mechanism for lightweight debugging as well at that point. But honestly, we have higher priorities at this point.<\/p>\n","excerpt":"<p>Now that I\u2019ve introduced my simple hybrid GetThings app, we need to set about adding support for debugging just the IronPython part of the app via the new lightweight debugging functionality we\u2019re introducing in 2.6. Note, the code is up on github, but isn\u2019t going to exactly match what I show on the blog. Also, [&hellip;]<\/p>\n","date":"2009-10-07 13:43:27","modified":"2009-10-07 13:43:27","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23},{"id":291,"slug":"lightweight-debugger","title":"Lightweight Debugger","description":"","post_count":5},{"id":293,"slug":"polyglot","title":"Polyglot","description":"","post_count":3}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["0cbc8971-2ce0-4098-b3b4-23a7f852cc86"],"dasblog_compressedtitle":["Hybrid+App+Debugging+Ndash+TracebackDelegate+And+SetTrace"],"dasblog_compressedtitleunique":["2009\/10\/07\/Hybrid+App+Debugging+Ndash+TracebackDelegate+And+SetTrace"]}},"previous_url":"http:\/\/devhawk.net\/2009\/10\/06\/lightweight-debugging-for-hybrid-cironpython-apps\/","next_url":"http:\/\/devhawk.net\/2009\/10\/07\/hybrid-app-debugging-aside-the-dlr-hosting-api\/"}