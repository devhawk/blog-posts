<p>Now that I&#8217;ve introduced my <a href="http://devhawk.net/2009/10/06/Lightweight+Debugging+For+Hybrid+CIronPython+Apps.aspx">simple hybrid GetThings app</a>, we need to set about adding support for debugging just the IronPython part of the app via the new lightweight debugging functionality we&#8217;re introducing in 2.6. Note, the code is <a href="http://github.com/devhawk/LightweightDebuggerDemo">up on github</a>, but isn&#8217;t going to exactly match what I show on the blog. Also, I have a post RC1 daily build of IronPython in the <a href="http://github.com/devhawk/LightweightDebuggerDemo/tree/deac85aaf14b37352ce4248917fd857c173d8997/External">Externals folder</a> since I discovered a few issues while building this sample that Dino had to fix after RC1. Those assemblies will be updated as needed as the sample progresses.</p>
<p>We saw last time how how easy it is to execute a Python script to configure a C# app &#8211; only four lines of code. If we want to support debugging, we need to add a fifth:</p>
<pre class="brush: csharp">private void Window_Loaded(object sender, RoutedEventArgs e)
{
    ScriptEngine engine = Python.CreateEngine();
    engine.SetTrace(this.OnTraceback);

    ScriptScope s = engine.CreateScope();
    s.SetVariable(&quot;items&quot;, lbThings.Items);
    engine.ExecuteFile(&quot;getthings.py&quot;, s);
}
</pre>
<p>You&#8217;ll notice the one new line &#8211; the call to engine.SetTrace. This is actually an extension method &#8211; ScriptEngine is a DLR hosting API class and but SetTrace is IronPython specific functionality [1]. If you look at the source of Python.SetTrace, you&#8217;ll see that it&#8217;s just a wrapper around SysModule.settrace, but it avoids needing to get the engine&#8217;s shared PythonContext yourself.</p>
<p>SetTrace takes a TracebackDelegate as a parameter. That delegate gets registered as the global traceback handler for the Python engine (on that thread, but we&#8217;ll ignore threading for now). Whenever that engine enters a new scope (i.e. a new function), the IronPython runtime calls into the global traceback handler. While the traceback handler runs, execution of the python code in that engine is paused. When the traceback handler returns, the engine resumes executing python code.</p>
<p>In addition to the global traceback handler, each scope has a local traceback handler as well. The TracebackDelegate type returns a TracebackDelegate which is used as the local traceback handler for the next traceback event within that scope. Traceback handlers can return themselves, some other TracebackDelegate, or null if they don&#8217;t want any more traceback events for the current scope. It&#8217;s kinda confusing, so here&#8217;s a picture:</p>
<p><a class="grouped_elements" href=".\image_10.png" rel="tc-fancybox-group1293"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="image" border="0" alt="image" src=".\image_thumb_4.png" width="514" height="206"></a></p>
<p>You&#8217;ll notice three different traceback event types in the picture above: call, line and return. Call indicates the start of a scope, and is always invoked on the global traceback handler (i.e. the traceback passed to SetTrace). Line indicates the Python engine is about to execute a line of code and return indicates the end of a scopes execution. As you can see, the runtime uses the return value of the traceback for the next tracing call until the end of the scope. The return value from the &#8220;return&#8221; event handler is ignored. </p>
<p>So now that we know the basics of traceback handlers, here&#8217;s a simple TracebackDelegate that simply returns itself. The &#8220;Hello, world!&#8221; of traceback debugging if you will.</p>
<pre class="brush: csharp">private TracebackDelegate OnTraceback
    (TraceBackFrame frame, string result, object payload)
{
    return this.OnTraceback;
}
</pre>
<p>If you run this code, there will be no functional difference from the code before you added the SetTrace call. That&#8217;s because we&#8217;re not doing anything in the traceback handler. But if you run this in the debugger with a breakpoint on this function, you&#8217;ll see that it gets called a bunch of times. In the python code <a href="http://devhawk.net/2009/10/06/Lightweight+Debugging+For+Hybrid+CIronPython+Apps.aspx">from the last post</a>, there are three scopes &#8211; module scope, download_stuff function scope and the get_nodes function scope. Each of those function scopes will have a call and return event, plus a bunch of line events in between. </p>
<p>The parameters for TracebackDelegate are described <a href="http://docs.python.org/library/sys.html#sys.settrace">in the Python docs</a>. The frame parameter is the current stack frame &#8211; it has information about the local and global variables, the code object currently executing, the line number being executed and a pointer to the previous stack frame if there is one. More information on code and frame objects is available in the <a href="http://docs.python.org/reference/datamodel.html#the-standard-type-hierarchy">python data model</a> (look for &#8220;internal types&#8221;). Result is the reason why the traceback function is being called (in Python docs, it&#8217;s called &#8220;event&#8221; but that&#8217;s a keyword in C#). IronPython supports four traceback results: &#8220;call&#8221;, &#8220;line&#8221; and &#8220;return&#8221; as described above plus &#8220;exception&#8221; when an exception is thrown. Finally, the payload value&#8217;s meaning depends on the traceback result. For call and line, payload is null. For return, payload is the value being returned from the function. For exception, the payload is information about the exception and where it was thrown. </p>
<p>As I mentioned above, python code execution is paused while the traceback handler executes and then continues when the traceback handler returns. That means you need to block in that function if you want to let the user interact with the debugger. For a console app like PDB, you can do that with a single thread of execution easily enough. For a GUI app like GetThings, that means running the debugger and debugee windows on separate threads. And as I alluded to, tracing for Python script engines is per thread. So next time, we&#8217;ll look deeper into how to use multiple threads for lightweight debugging a hybrid app.</p>
<hr>
<p>[1] Eventually, I&#8217;d like to see IronRuby support lightweight debugging as well. However, there&#8217;s no built in mechanism for Ruby debugging the way there is for Python, so it&#8217;s less clear how we should expose debugging to the Ruby developer. We&#8217;d also want to build a language neutral DLR Hosting API mechanism for lightweight debugging as well at that point. But honestly, we have higher priorities at this point.</p>
