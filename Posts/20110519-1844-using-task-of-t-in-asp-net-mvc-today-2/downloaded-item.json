{"status":"ok","post":{"id":1888,"type":"post","slug":"using-task-of-t-in-asp-net-mvc-today-2","url":"http:\/\/devhawk.net\/2011\/05\/19\/using-task-of-t-in-asp-net-mvc-today-2\/","status":"publish","title":"Using Task<T> in ASP.NET MVC Today","title_plain":"Using Task in ASP.NET MVC Today","content":"<p>I&#8217;ve been experimenting with the\u00a0<a href=\"http:\/\/msdn.microsoft.com\/en-us\/vstudio\/async.aspx\">new async support<\/a> coming in the next version of C# (and VB). I must say, I&#8217;m very impressed. Async is one of those things you know you&#8217;re supposed to be doing. However, traditionally it has taken a lot of code and been hard to get right. The new await keyword changes all that.<\/p>\n<p>For example, here&#8217;s an async function to download the\u00a0<a href=\"http:\/\/dev.twitter.com\/doc\/get\/statuses\/public_timeline\">Twitter public timeline<\/a>:<\/p>\n<pre class=\"brush:csharp\">public async Task PublicTimelineAsync()\n{\n  var url = \"http:\/\/api.twitter.com\/1\/statuses\/public_timeline.xml\";\n  var xml = await new WebClient().DownloadStringTaskAsync(url);\n  return XDocument.Parse(xml);\n}<\/pre>\n<p>That&#8217;s not much more difficult that writing the\u00a0synchronous\u00a0version. By using the new async and await keywords, all the ugly async <a href=\"http:\/\/en.wikipedia.org\/wiki\/Continuation-passing_style\">CPS<\/a> code you&#8217;re supposed to write is generated for you automatically by the compiler. That&#8217;s a huge win.<\/p>\n<p>The only downside to async is that\u00a0support for it is spotty in\u00a0the .NET Framework today. Each major release of .NET to date has introduced a new async API pattern. .NET 1.0 had the\u00a0<a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms228963.aspx\">Async Programming Model (APM)<\/a>. .NET 2.0 introduced the\u00a0<a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/wewwczdw.aspx\">Event-based Async Pattern (EAP)<\/a>. Finally .NET 4.0 gave us the\u00a0<a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/dd537609.aspx\">Task Parallel Library (TPL)<\/a>. The await keyword only works with APIs writen using the TPL pattern.\u00a0APIs using older async patterns have to be wrapped as TPL APIs to work with await. The <a href=\"http:\/\/www.microsoft.com\/downloads\/en\/details.aspx?FamilyID=4738205d-5682-47bf-b62e-641f6441735b&amp;displaylang=en\">Async CTP<\/a> includes a bunch of extension methods that wrap common async APIs, such as DownloadStringTaskAsync from the code above.<\/p>\n<p>The async wrappers are nice, but there are a few places where we really need the TPL pattern plumbed deeper. For example, ASP.NET MVC\u00a0supports\u00a0<a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ee728598.aspx\">AsyncControllers<\/a>. AsyncControllers are used to avoid blocking IIS threads waiting on long running I\/O operations &#8211; such as getting the public timeline from Twitter.\u00a0Now that I&#8217;ve been bitten by the <a href=\"http:\/\/blogs.msdn.com\/b\/lucian\/archive\/2011\/04\/15\/async-ctp-refresh-design-changes.aspx\">async zombie virus<\/a>, I want to write my async controller methods using await:<\/p>\n<pre class=\"brush:csharp\">public async Task&lt;ActionResult&gt; Index()\n{\n    var t = new Twitter();\n    var timeline = await t.PublicTimelineAsync();\n    var data = timeline.Root.Elements(\"status\")\n        .Elements(\"text\").Select(e =&gt; e.Value);\n    return View(data);\n}<\/pre>\n<p>Unfortunately, neither the main trunk of MVC nor the MVC futures project has support for the TPL model [1].\u00a0Instead, I have to manually write some semblance of the async code that await would have emitted on my behalf. In particular, I have to manage the outstanding operations, implement a\u00a0continuation method and\u00a0map the parameters in my controller manually.<\/p>\n<pre class=\"brush:csharp\">public void IndexAsync()\n{\n    var twitter = new Twitter();\n\n    AsyncManager.OutstandingOperations.Increment();\n    twitter\n        .PublicTimelineAsync()\n        .ContinueWith(task =&gt;\n        {\n            AsyncManager.Parameters[\"timeline\"] = task.Result;\n            AsyncManager.OutstandingOperations.Decrement();\n        });\n}\n\npublic ActionResult IndexCompleted(XDocument timeline)\n{\n    var data = timeline.Root.Elements(\"status\")\n        .Elements(\"text\").Select(e =&gt; e.Value);\n    return View(data);\n}<\/pre>\n<p>I promise you, writing that boilerplate code over and over gets old pretty darn quick.\u00a0So I wrote the following helper function to eliminate as much boilerplate code as I could.<\/p>\n<pre class=\"brush:csharp\">public static void RegisterTask&lt;T&gt;(\n    this AsyncManager asyncManager,\n    Task&lt;T&gt; task,\n    Func&lt;T, object&gt; func)\n{\n    asyncManager.OutstandingOperations.Increment();\n    task.ContinueWith(task2 =&gt;\n    {\n        \/\/invoke the provided function with the\n        \/\/result of running the task\n        var o = func(task2.Result);\n\n        \/\/use reflection to set asyncManager.Parameters\n        \/\/for the returned object's fields and properties\n        var ty = o.GetType();\n        foreach (var f in ty.GetFields())\n        {\n            asyncManager.Parameters[f.Name] = f.GetValue(o);\n        }\n        foreach (var p in ty.GetProperties())\n        {\n            var v = p.GetGetMethod().Invoke(o, null);\n            asyncManager.Parameters[p.Name] = v;\n        }\n\n        asyncManager.OutstandingOperations.Decrement();\n    });\n}<\/pre>\n<p>With this helper function, you pass in the Task&lt;T&gt; that you are waiting on as well as a delegate to invoke when the task completes. RegisterTask takes care of incrementing and decrementing the outstanding operations count as appropriate. It also registers a continuation that reflects over the object returned from the invoked delegate to populate\u00a0the Parameters collection.<\/p>\n<p>With this helper function, you can write the async controller method like this:<\/p>\n<pre class=\"brush:csharp\">public void IndexAsync()\n{\n    var twitter = new Twitter();\n\n    AsyncManager.RegisterTask(\n        twitter.PublicTimelineAsync(),\n        data =&gt; new { timeline = data });\n}\n\n\/\/IndexCompleted hasn't changed\npublic ActionResult IndexCompleted(XDocument timeline)\n{\n    var data = timeline.Root.Elements(\"status\")\n        .Elements(\"text\").Select(e =&gt; e.Value);\n    return View(data);\n}<\/pre>\n<p>It&#8217;s not as clean as the purely TPL based version. In particular, you still need to write separate\u00a0Async and Completed methods for each controller method. You also need to build an object to map values from the completed tasks into parameters in the completed method. Mapping parameters is a pain, but\u00a0the\u00a0anonymous\u00a0object syntax is terser than setting values in the AsyncManager Parameter collection.<\/p>\n<p>It&#8217;s not full TPL support, but it&#8217;ll do for now. Here&#8217;s hoping that the MVC team has async controller methods with TPL on their backlog.<\/p>\n<hr \/>\n<p>[1] I&#8217;m familiar with Craig Cavalier&#8217;s\u00a0<a href=\"http:\/\/craigcav.wordpress.com\/2010\/12\/23\/asynchronous-mvc-using-the-task-parallel-library\/\">Async MVC with TPL<\/a> post, but a fork of the MVC Futures project is a bit too bleeding edge for my needs at this point.<\/p>\n","excerpt":"<p>I&#8217;ve been experimenting with the\u00a0new async support coming in the next version of C# (and VB). I must say, I&#8217;m very impressed. Async is one of those things you know you&#8217;re supposed to be doing. However, traditionally it has taken a lot of code and been hard to get right. The new await keyword changes [&hellip;]<\/p>\n","date":"2011-05-19 18:44:07","modified":"2011-05-19 18:44:07","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":178,"slug":"asp-net","title":"ASP.NET","description":"","post_count":27},{"id":296,"slug":"asp-net-mvc","title":"ASP.NET MVC","description":"","post_count":2},{"id":360,"slug":"async","title":"Async","description":"","post_count":1},{"id":235,"slug":"c-sharp","title":"C#","description":"","post_count":17}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":3175,"name":"gautam kinkar","url":"","date":"2011-05-24 04:43:44","content":"<p>sir please guide me that c or c++ is nessesory for asp.net<\/p>\n","parent":0},{"id":3176,"name":"DevHawk","url":"","date":"2011-05-24 09:39:51","content":"<p>@gautam, The code in this post is C#. There is a managed version of C++ (aka <a href=\"http:\/\/en.wikipedia.org\/wiki\/C%2B%2B\/CLI\" rel=\"nofollow\">C++\/CLI<\/a>) but I don&#8217;t think it works with ASP.NET.<\/p>\n","parent":3175,"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""}},{"id":3177,"name":"Rashmi","url":"http:\/\/www.Beejak.com","date":"2011-05-24 20:39:40","content":"<p>That&#8217;s nice. Will give it a try. I am sure the performance would increase.<\/p>\n","parent":0},{"id":3178,"name":"Haacked","url":"http:\/\/haacked.com\/","date":"2011-05-25 09:27:30","content":"<p>We plan to support this in ASP.NET MVC 4.<\/p>\n","parent":0},{"id":3179,"name":"Felix","url":"","date":"2011-05-29 15:32:01","content":"<p>Ideally, I would like to use asynch controller for POST call where I pass a few parameters and await result. Async controller assumes that the service implements Event-based Asynchronous Pattern or BeginMethod\/EndMethod Pattern (or at least documentation assumes). Your example here calls DownloadStringTaskAsync which assumes GET or REST service.<br \/>\nSo, I am not sure if I can call WebRequest.GetResponse asynchronously and just don&#8217;t know how; or it is only possible for specially crafted services (and then Async CTP just simplifies what is already available).<\/p>\n","parent":0},{"id":3180,"name":"DevHawk","url":"","date":"2011-06-01 22:08:17","content":"<p>With an async controller, you can choose which of your controller methods are async and which are sync &#8211; they don&#8217;t all have to be sync.<\/p>\n<p>As for DownloadStringTaskAsync, it&#8217;s provided as part of the Async CTP and works with any site that DownloadString would work with AFAIK<\/p>\n","parent":3179,"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""}}],"attachments":[],"comment_count":7,"comment_status":"closed","custom_fields":{}},"previous_url":"http:\/\/devhawk.net\/2011\/05\/19\/build-your-own-wds-discovery-image\/","next_url":"http:\/\/devhawk.net\/2011\/06\/15\/open-position-on-my-team\/"}