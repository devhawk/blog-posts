<p>I&#8217;ve been experimenting with the&nbsp;<a href="http://msdn.microsoft.com/en-us/vstudio/async.aspx">new async support</a> coming in the next version of C# (and VB). I must say, I&#8217;m very impressed. Async is one of those things you know you&#8217;re supposed to be doing. However, traditionally it has taken a lot of code and been hard to get right. The new await keyword changes all that.</p>
<p>For example, here&#8217;s an async function to download the&nbsp;<a href="http://dev.twitter.com/doc/get/statuses/public_timeline">Twitter public timeline</a>:</p>
<pre class="brush:csharp">public async Task PublicTimelineAsync()
{
  var url = &quot;http://api.twitter.com/1/statuses/public_timeline.xml&quot;;
  var xml = await new WebClient().DownloadStringTaskAsync(url);
  return XDocument.Parse(xml);
}</pre>
<p>That&#8217;s not much more difficult that writing the&nbsp;synchronous&nbsp;version. By using the new async and await keywords, all the ugly async <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a> code you&#8217;re supposed to write is generated for you automatically by the compiler. That&#8217;s a huge win.</p>
<p>The only downside to async is that&nbsp;support for it is spotty in&nbsp;the .NET Framework today. Each major release of .NET to date has introduced a new async API pattern. .NET 1.0 had the&nbsp;<a href="http://msdn.microsoft.com/en-us/library/ms228963.aspx">Async Programming Model (APM)</a>. .NET 2.0 introduced the&nbsp;<a href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">Event-based Async Pattern (EAP)</a>. Finally .NET 4.0 gave us the&nbsp;<a href="http://msdn.microsoft.com/en-us/library/dd537609.aspx">Task Parallel Library (TPL)</a>. The await keyword only works with APIs writen using the TPL pattern.&nbsp;APIs using older async patterns have to be wrapped as TPL APIs to work with await. The <a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=4738205d-5682-47bf-b62e-641f6441735b&displaylang=en">Async CTP</a> includes a bunch of extension methods that wrap common async APIs, such as DownloadStringTaskAsync from the code above.</p>
<p>The async wrappers are nice, but there are a few places where we really need the TPL pattern plumbed deeper. For example, ASP.NET MVC&nbsp;supports&nbsp;<a href="http://msdn.microsoft.com/en-us/library/ee728598.aspx">AsyncControllers</a>. AsyncControllers are used to avoid blocking IIS threads waiting on long running I/O operations &#8211; such as getting the public timeline from Twitter.&nbsp;Now that I&#8217;ve been bitten by the <a href="http://blogs.msdn.com/b/lucian/archive/2011/04/15/async-ctp-refresh-design-changes.aspx">async zombie virus</a>, I want to write my async controller methods using await:</p>
<pre class="brush:csharp">public async Task&lt;ActionResult&gt; Index()
{
    var t = new Twitter();
    var timeline = await t.PublicTimelineAsync();
    var data = timeline.Root.Elements(&quot;status&quot;)
        .Elements(&quot;text&quot;).Select(e =&gt; e.Value);
    return View(data);
}</pre>
<p>Unfortunately, neither the main trunk of MVC nor the MVC futures project has support for the TPL model [1].&nbsp;Instead, I have to manually write some semblance of the async code that await would have emitted on my behalf. In particular, I have to manage the outstanding operations, implement a&nbsp;continuation method and&nbsp;map the parameters in my controller manually.</p>
<pre class="brush:csharp">public void IndexAsync()
{
    var twitter = new Twitter();

    AsyncManager.OutstandingOperations.Increment();
    twitter
        .PublicTimelineAsync()
        .ContinueWith(task =&gt;
        {
            AsyncManager.Parameters[&quot;timeline&quot;] = task.Result;
            AsyncManager.OutstandingOperations.Decrement();
        });
}

public ActionResult IndexCompleted(XDocument timeline)
{
    var data = timeline.Root.Elements(&quot;status&quot;)
        .Elements(&quot;text&quot;).Select(e =&gt; e.Value);
    return View(data);
}</pre>
<p>I promise you, writing that boilerplate code over and over gets old pretty darn quick.&nbsp;So I wrote the following helper function to eliminate as much boilerplate code as I could.</p>
<pre class="brush:csharp">public static void RegisterTask&lt;T&gt;(
    this AsyncManager asyncManager,
    Task&lt;T&gt; task,
    Func&lt;T, object&gt; func)
{
    asyncManager.OutstandingOperations.Increment();
    task.ContinueWith(task2 =&gt;
    {
        //invoke the provided function with the
        //result of running the task
        var o = func(task2.Result);

        //use reflection to set asyncManager.Parameters
        //for the returned object's fields and properties
        var ty = o.GetType();
        foreach (var f in ty.GetFields())
        {
            asyncManager.Parameters[f.Name] = f.GetValue(o);
        }
        foreach (var p in ty.GetProperties())
        {
            var v = p.GetGetMethod().Invoke(o, null);
            asyncManager.Parameters[p.Name] = v;
        }

        asyncManager.OutstandingOperations.Decrement();
    });
}</pre>
<p>With this helper function, you pass in the Task&lt;T&gt; that you are waiting on as well as a delegate to invoke when the task completes. RegisterTask takes care of incrementing and decrementing the outstanding operations count as appropriate. It also registers a continuation that reflects over the object returned from the invoked delegate to populate&nbsp;the Parameters collection.</p>
<p>With this helper function, you can write the async controller method like this:</p>
<pre class="brush:csharp">public void IndexAsync()
{
    var twitter = new Twitter();

    AsyncManager.RegisterTask(
        twitter.PublicTimelineAsync(),
        data =&gt; new { timeline = data });
}

//IndexCompleted hasn't changed
public ActionResult IndexCompleted(XDocument timeline)
{
    var data = timeline.Root.Elements(&quot;status&quot;)
        .Elements(&quot;text&quot;).Select(e =&gt; e.Value);
    return View(data);
}</pre>
<p>It&#8217;s not as clean as the purely TPL based version. In particular, you still need to write separate&nbsp;Async and Completed methods for each controller method. You also need to build an object to map values from the completed tasks into parameters in the completed method. Mapping parameters is a pain, but&nbsp;the&nbsp;anonymous&nbsp;object syntax is terser than setting values in the AsyncManager Parameter collection.</p>
<p>It&#8217;s not full TPL support, but it&#8217;ll do for now. Here&#8217;s hoping that the MVC team has async controller methods with TPL on their backlog.</p>
<hr>
<p>[1] I&#8217;m familiar with Craig Cavalier&#8217;s&nbsp;<a href="http://craigcav.wordpress.com/2010/12/23/asynchronous-mvc-using-the-task-parallel-library/">Async MVC with TPL</a> post, but a fork of the MVC Futures project is a bit too bleeding edge for my needs at this point.</p>
