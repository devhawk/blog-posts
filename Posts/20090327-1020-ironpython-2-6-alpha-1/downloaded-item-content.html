<p>Just in type for <a href="http://us.pycon.org/2009/about/">PyCon</a>, we just shipped the <a href="http://ironpython.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=22982">first alpha of IronPython 2.6</a>. As you can guess from the version number, the main feature of this version of IronPython will be the <a href="http://docs.python.org/whatsnew/2.6.html">new features introduced in Python 2.6</a>. As you can see, we&#8217;ve synced version numbers between IronPython and Python. No more explaining which version of IPy goes with which version of Python.</p>
<p>In addition to the start of 2.6 support, the other big feature of IronPython 2.6 is something called Adaptive Compilation. IronPython&#8217;s performance <a href="http://ironpython.codeplex.com/Wiki/View.aspx?title=IP201VsCPy25Perf&referringTitle=IronPython%20Performance">is pretty good</a> compared to CPython. We&#8217;re about 28% faster than CPython (IPy 2.0.1 vs. CPy 2.5) on PyStone and about 10% faster on PyBench <em>if you exclude the TryRaiseExcept test</em>. [1] However, our startup time is not very good. These two facts are related: it takes a long time on startup to compile to Python code to IL (and then JITted from IL to native code), but once that&#8217;s done the code runs really fast. However, if you&#8217;re only going to execute a function a few times, it typically isn&#8217;t worth the overhead to compile the function to IL. The Adaptive Compilation feature is an <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/48484#706048">interpreter</a> for DLR trees. The first few times you run a given Python function, it gets interpreted. At some point, after you&#8217;ve called the function enough times, IronPython 2.6 decides to take the hit and compile the function. If you want to go back to the old &#8220;always compile to IL&#8221; model, you can pass &#8211;O on the command line.</p>
<p>This is our first alpha of 2.6, and some things are kinda broken. In particular, there was a change to collections.py that breaks much of the Python Standard Library under IronPython. Dave <a href="http://knowbody.livejournal.com/13271.html">has the details</a> and the workaround. Rest assured, this will get fixed before we release. Dino is hard at work making <a href="http://docs.python.org/library/sys.html#sys._getframe">_getframe</a> work for depths greater than zero. Because it will have some perf impact, it won&#8217;t be enabled by default &#8211; you&#8217;ll have to pass a command-line parameter to enable it. But if you have to opt-in to _getframe support for depth &gt; 0, it makes sense to opt-into _getframe support entirely and do away with the current _getframe(0) only support. What&#8217;s nice about this approach is that it will work with collections.py regardless if you opt-in to _getframe or not.</p>
<p>As stated in the release notes, the release cycle on 2.6 will be much shorter than 2.0. There was only seven months between 1.0 and 1.1, and we&#8217;re shooting for a slightly longer timeframe for 2.6. Certainly not like the twenty months that passed between 1.1 and 2.0. So please start trying it out as soon as you can and give us your feedback.</p>
<hr>
<p>[1] IPy is <em>over 4000% slower</em> than CPy on TryRaiseExcept, 58,234 ms vs. 1,286ms. This one test represents 44% of our overall test run time and causes IPy to run PyBench 57% slower than CPy instead of 10% faster. Python has a different philosophy on exceptions than CLR does. Several Python exceptions like <a href="http://docs.python.org/library/exceptions.html#exceptions.GeneratorExit">GeneratorExit</a> and <a href="http://docs.python.org/library/exceptions.html#exceptions.StopIteration">StopIteration</a> are explicitly documented as &#8220;not considered an error&#8221;. This is a very different approach to <a href="http://blogs.msdn.com/ricom/archive/2003/12/19/44697.aspx">CLR&#8217;s approach</a>. At some point, we&#8217;re going to have to look at improving exception performance, but it&#8217;s not really a priority for the 2.6 release.</p>
