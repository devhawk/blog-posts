<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Writing an IronPython Debugger: Setting a Breakpoint</title>
  <link>http://devhawk.net/2009/03/02/writing-an-ironpython-debugger-setting-a-breakpoint/</link>
  <pubDate>Mon, 02 Mar 2009 15:59:04 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://08c13b80-ad18-43f8-955d-6fa5fd5d9714</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Now that we have a debugger process <a href="http://devhawk.net/2009/02/28/Writing+An+IronPython+Debugger+Hello+Debugger.aspx">up and running</a>, let start adding some actual features. First up, we want to be able to set breakpoints. One of the nice things MDbg does is auto-set a breakpoint on the entrypoint function. For ipydbg, we’re going to auto-set a breakpoint on the first line of the python file being debugged.</p><p>In order to set a breakpoint, we need debugger symbols. They allow us to translate between “line one of simpletest.py” and the actual location in the code and back. We’re all used to seeing the PDB files that are produced when we compile a C# assembly. Unsurprisingly, the <a href="http://msdn.microsoft.com/en-us/library/ms232451.aspx">symbol store binder</a> provides a method to <a href="http://msdn.microsoft.com/en-us/library/ms230866.aspx">load these PDB files from disk</a>. But where do IronPython debug symbols come from? I know from my extensive reading of the ipy.exe command line parameters that you pass –D to enable application debugging, but since all the IL is being generated in memory, how does the debugger get access to the PDB files?</p><p>It turns out the debugger API includes a <a href="http://msdn.microsoft.com/en-us/library/ms230148.aspx">UpdateModuleSymbols callback method</a> that the runtime uses to notify the debugger when the symbols change. The debugger symbols are provided in an IStream, and then you <a href="http://msdn.microsoft.com/en-us/library/ms232101.aspx">use the symbol binder</a> to get a <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.symbolstore.isymbolreader.aspx">symbol reader</a>. The .NET Framework already provides a <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.symbolstore.aspx">managed API</a> for reading and writing debug symbols. However, that API doesn’t support loading symbols from a stream, so the MDbg code includes it’s own <a href="http://github.com/devhawk/ipydbg/blob/5858695ff85ed4740ad06466d4f54394e7f00f9b/CorDebug/CorSymbolStore/symbinder.cs">wrapper</a> around the symbol binder API to include that functionality. Here’s some code to get the debug symbol reader for an updated module and iterate through the associated files:</p><pre class="brush: python">
sym_binder = SymbolBinder()   
     
def OnUpdateModuleSymbols(s,e):   
  print "OnUpdateModuleSymbols"   
     
  metadata_import = e.Module.GetMetaDataInterface[IMetadataImport]()   
  reader = sym_binder.GetReaderFromStream(metadata_import, e.Stream)   

  for doc in reader.GetDocuments():    
    print "t", doc.URL     

process.OnUpdateModuleSymbols += OnUpdateModuleSymbols
</pre><p>If we run <a href="http://github.com/devhawk/ipydbg/blob/965e2fbf4834177cb7aa7816dd5d0d729672dec6/ipydbg.py">this version of ipydbg</a> on simpletest.py with the <a href="http://ironpython.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=12481">IPy 2.0.1 release</a> and the Python standard library installed, OnUpdatedModuleSymbols gets called six times, once for each python file that gets loaded when simpletest runs. (site.py, os.py, ntpath.py, stat.py, UserDict.py and simpletest.py). BTW, I tried running this code on the <a href="http://nbs.blob.core.windows.net/ironpython/IronPython.47624.release.zip">latest build of IPy</a> (<a href="http://www.codeplex.com/IronPython/SourceControl/changeset/view/47624">changeset 47624</a>) and I’m getting a COM Interop exception. So for now, stick with 2.0.1.</p><p>Now that we can get these dynamically generated debug symbols, we can use them to create a breakpoint on the first line of the script being debugged. Everytime OnUpdateModuleSympols is called, I try to bind the initial breakpoint (unless it’s already been bound of course) by calling the following create_breakpoint function.</p><pre class="brush: python">
def create_breakpoint(doc, line, module, reader):     
  line = doc.FindClosestLine(line)     
  method = reader.GetMethodFromDocumentPosition(doc, line, 0)     
  function = module.GetFunctionFromToken(method.Token.GetToken())     
   
  for sp in get_sequence_points(method):     
    if sp.doc.URL == doc.URL and sp.start_line == line:     
      bp = function.ILCode.CreateBreakpoint(sp.offset)     
      bp.Activate(True)     
      return bp     
       
  bp = function.CreateBreakpoint()     
  bp.Activate(True)     
  return bp
</pre><p>This code translates a given document/line into a function/offset where we can set a breakpoint. To do this, we use sequence points which <a href="http://blogs.msdn.com/rmbyers/archive/2005/09/08/debuggingmodes-ignoresymbolstoresequencepoints.aspx">as per Rick Byers</a> are “used to mark a spot in the IL code that corresponds to a specific location in the original source”. So once we find the function that corresponds to a given line of code, we iterate over the sequence points until we find the one that matches the line we want to break on. If we find a matching sequence point, we set the breakpoint there. If we don’t, we set the breakpoint on the function itself. get_sequence_points is a simple wrapper around <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.symbolstore.isymbolmethod.getsequencepoints.aspx">ISymbolMethod GetSequencePoints</a>. The original API is pretty ugly to use – managing six separate arrays of information – so get_sequence_points turns it into a generator function you can iterate over.</p><p>Now that the breakpoint is set, we want to trap the breakpoint event as well. That’s easy enough, we create an event handler for process.OnBreakpoint similar to the OnUpdateModuleSymbols event above. Eventually, we’ll have the ability to step when we break, but for now I’m just going to print out the current location when the breakpoint is hit. This is kind of the reverse of the operation above. Setting a breakpoint means going from a source location to an IL offset within a function. Printing the current location means going from an IL offset in a function back to the source location. Here’s the function to do that:</p><pre class="brush: python">
def get_location(reader, thread):  
  frame = thread.ActiveFrame  
  function = frame.Function  
    
  offset, mapping_result = frame.GetIP()  
  method = reader.GetMethod(SymbolToken(frame.Function.Token))  
    
  real_sp = None  
  for sp in get_sequence_points(method):  
    if sp.offset &gt; offset:   
      break  
    if sp.start_line != 0xfeefee:   
      real_sp = sp  
        
  if real_sp == None:  
    return "Location (offset %d)" % (offset)  
    
  return "Location %s:%d (offset %d)" % (  
    Path.GetFileName(real_sp.doc.URL), real_sp.start_line, offset)  

def OnBreakpoint(s,e):     
  print "OnBreakpoint", get_location(     
    symbol_readers[e.Thread.ActiveFrame.Function.Module], e.Thread)
</pre><p></p><p>Given a symbol reader and a debug thread, get_location returns a location string. It loops thru the sequence points, similar to create_breakpoint, in order to find the closest corresponding line of python code to the current offset (check out Mike Stall’s blog as for <a href="http://blogs.msdn.com/jmstall/archive/2005/06/19/FeeFee_SequencePoints.aspx">why I’m checking for 0xfeefee</a>). In order to make this work, I need the symbol reader for the module that I retrieved in OnUpdateModuleSymbols. For now, I’m stashing the reader in a global dictionary keyed by the module named symbol_readers where OnBreakpoint can access it. </p><p>Ipydbg isn’t interactive yet, but it is now running, setting a breakpoint and successfully breaking at that breakpoint. As usual, the <a href="http://github.com/devhawk/ipydbg/commit/92521a59c3d6a4679a30bb019bda26a4eff8c894#diff-0">latest version of ipydbg</a> is up on GitHub.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1222</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-03-02 15:59:04</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-03-02 15:59:04</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">writing-an-ironpython-debugger-setting-a-breakpoint</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="debugger"><![CDATA[Debugger]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[08c13b80-ad18-43f8-955d-6fa5fd5d9714]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Writing+An+IronPython+Debugger+Setting+A+Breakpoint]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/03/02/Writing+An+IronPython+Debugger+Setting+A+Breakpoint]]></wp:meta_value>
  </wp:postmeta>
</item>