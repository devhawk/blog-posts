<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>2896</wp:comment_id>
  <wp:comment_author><![CDATA[Matt Dotson]]></wp:comment_author>
  <wp:comment_author_email></wp:comment_author_email>
  <wp:comment_author_url>http://blogs.msdn.com/mattdotson/</wp:comment_author_url>
  <wp:comment_author_IP>68.235.202.147</wp:comment_author_IP>
  <wp:comment_date>2006-02-21 21:42:52</wp:comment_date>
  <wp:comment_date_gmt>2006-02-22 05:42:52</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[Interesting stuff.  I wonder if it would catch on with the "write to the metal" approach of most game devs.  I could see this sort of thing catching on much better with windows devs where abstraction is everywhere.  I'd like to see this built into existing languages with language extensions to C# (or others) enabled by the phoenix compiler project?

Even if the languages were better equipped to deal with concurrency, we are stuck with so many libraries that don't do concurrency well.  How long will we be bound by windows' single UI thread concept, which is unfortunately not resolved with WPF?

Finally, I'm excited to see a bunch of C++ people saying that the future is garbage collected!!  It makes sense that once you get a bunch of hardware threads (they talked of 20+ hardware threads), giving up 5% processing power would mean the gc could run all of the time and not add any latency to the apps.  With our single threaded apps now, the whole app has to freeze while GC takes place.]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>