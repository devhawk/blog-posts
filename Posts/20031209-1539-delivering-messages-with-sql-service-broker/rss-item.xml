<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Delivering Messages with SQL Service Broker</title>
  <link>http://devhawk.net/2003/12/09/delivering-messages-with-sql-service-broker/</link>
  <pubDate>Tue, 09 Dec 2003 15:39:29 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://974e04d8-30fe-44ba-9103-b8397a2c7b2e</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p><a href="http://www.microsoft.com/sql/yukon/productinfo/top30features.asp#B">SQL Service Broker</a> is probably the least known new feature of <a href="http://www.microsoft.com/sql/yukon/productinfo">SQL Server "Yukon"</a>, but I can't wait for it. It makes messages a first class object in the database. If you've ever had multiple processes banging on your database or you've ever used a flag on a row to indicate if it's been processed or not, you want SQL Service Broker too.</p><p>While there is huge disagreement as to exactly what "Service-Oriented Architecture" is, I think there is some general consensus around the fact that it is an asynchronous message driven model rather than a synchronous RPC model. This means that the thread you receive a message on will <i>never</i> be the same thread that you process the message on. In fact, typically you will write the message to a persistent data store (hello, Yukon native XML support) in order to be handled by a thread in a different process and probably on a different machine. Today, kicking off the thread to handle the message is a pain in the ass. You probably want lots of threads across lots of machines to handle the incoming messages (assuming you're getting lots of incoming messages). In order to synchronize message processing across machines, you need a mechanism to make sure each incoming message is handled once and only once. Today, the closest solution is message queue technology like <a href="http://www.microsoft.com/msmq">MSMQ</a> (or <a href="http://www.ibm.com/software/integration/mqfamily/">MQSeries</a>). However, since that's a different data store from where the data lives (i.e. the database), now you need two phase distributed transactions to get that done. However, since messaging is going to be such a huge piece of architecture going forward, it makes sense to have the concept of messages baked right into the database.</p><p>With Service Broker, when the message is received, it is placed into a service broker queue. (It'll probably get stored for archival and retry avoidance reasons, but that's a different blog entry.) Now I can have processes that, within the scope of a local transaction, receive the incoming message, make whatever data changes that message implies and send off any new messages. This is both more productive (manually handling local transactions for async processing is this kind of a scenario much easier than using serviced components) as well as more performant. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">242</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2003-12-09 15:39:29</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2003-12-09 15:39:29</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">delivering-messages-with-sql-service-broker</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="soa"><![CDATA[SOA]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[974e04d8-30fe-44ba-9103-b8397a2c7b2e]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Delivering+Messages+With+SQL+Service+Broker]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2003/12/09/Delivering+Messages+With+SQL+Service+Broker]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2924</wp:comment_id>
    <wp:comment_author><![CDATA[Benjamin Mitchell]]></wp:comment_author>
    <wp:comment_author_email>benjaminm@benjaminm.net</wp:comment_author_email>
    <wp:comment_author_url>http://benjaminm.net</wp:comment_author_url>
    <wp:comment_author_IP></wp:comment_author_IP>
    <wp:comment_date>2003-12-11 00:58:22</wp:comment_date>
    <wp:comment_date_gmt>2003-12-11 08:58:22</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Good to see more information about the Service Broker.  I think many people are confused about the different approaches to messaging that Microsoft are offering and have collected information about the Yukon Service Broker and how it compares to Indigo and MSMQ in my post 'More on the Microsoft Messaging message[1]'
[1] - http://benjaminm.net/PermaLink.aspx?guid=dceab3fe-5eae-47e1-87a4-c795ca369d2d ]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>