<p><a href="http://www.microsoft.com/sql/yukon/productinfo/top30features.asp#B">SQL Service Broker</a> is probably the least known new feature of <a href="http://www.microsoft.com/sql/yukon/productinfo">SQL Server &#8220;Yukon&#8221;</a>, but I can&#8217;t wait for it. It makes messages a first class object in the database. If you&#8217;ve ever had multiple processes banging on your database or you&#8217;ve ever used a flag on a row to indicate if it&#8217;s been processed or not, you want SQL Service Broker too.</p>
<p>While there is huge disagreement as to exactly what &#8220;Service-Oriented Architecture&#8221; is, I think there is some general consensus around the fact that it is an asynchronous message driven model rather than a synchronous RPC model. This means that the thread you receive a message on will <i>never</i> be the same thread that you process the message on. In fact, typically you will write the message to a persistent data store (hello, Yukon native XML support) in order to be handled by a thread in a different process and probably on a different machine. Today, kicking off the thread to handle the message is a pain in the ass. You probably want lots of threads across lots of machines to handle the incoming messages (assuming you&#8217;re getting lots of incoming messages). In order to synchronize message processing across machines, you need a mechanism to make sure each incoming message is handled once and only once. Today, the closest solution is message queue technology like <a href="http://www.microsoft.com/msmq">MSMQ</a> (or <a href="http://www.ibm.com/software/integration/mqfamily/">MQSeries</a>). However, since that&#8217;s a different data store from where the data lives (i.e. the database), now you need two phase distributed transactions to get that done. However, since messaging is going to be such a huge piece of architecture going forward, it makes sense to have the concept of messages baked right into the database.</p>
<p>With Service Broker, when the message is received, it is placed into a service broker queue. (It&#8217;ll probably get stored for archival and retry avoidance reasons, but that&#8217;s a different blog entry.) Now I can have processes that, within the scope of a local transaction, receive the incoming message, make whatever data changes that message implies and send off any new messages. This is both more productive (manually handling local transactions for async processing is this kind of a scenario much easier than using serviced components) as well as more performant. </p>
