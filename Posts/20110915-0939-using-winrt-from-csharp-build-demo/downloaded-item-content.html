<p>Yesterday at<a href="http://www.buildwindows.com/"> //build</a>, Jesse Kaplan and I delivered the <a href="http://channel9.msdn.com/Events/BUILD/BUILD2011/TOOL-531T">Using Windows Runtime from C# and Visual Basic</a> talk. In the talk, I demonstrated how natural and&nbsp;familiar&nbsp;it is to use WinRT from C# by&nbsp;building a simple Metro style app. This app &nbsp;takes a picture with a webcam and implements the share charm contract in less than 15 lines of C# code.</p>
<p>Instead of making you try and read code off the recorded video stream that should be&nbsp;published soon, I&#8217;ve written this walkthru to explain exactly what I did in that demo.&nbsp;In addition, I&#8217;ve started from scratch (i.e. File-&gt;New Project) so that you can follow along at home if you wish.</p>
<p>First, you need to install the <a href="http://msdn.microsoft.com/en-us/windows/apps/br229516">Windows Developer Preview</a>. I recommend the x64 version with tools. Scott Hanselman has a <a href="http://www.hanselman.com/blog/GuideToInstallingAndBootingWindows8DeveloperPreviewOffAVHDVirtualHardDisk.aspx">great write up</a> on using boot to VHD to run the preview. (though I do disagree w/ his assessment of dual boot. I&#8217;ve been dual booting Win7 and Win8 on my laptop for months and it&#8217;s never ended in tears or blood). Also, you&#8217;re going to need a webcam in order to run the app yourself.</p>
<p>Once the Windows Developer Preview is up and running, run the Socialite app and login with your Facebook credentials. We&#8217;re going to use Socialite to share the picture we take with the webcam. Giving it your credentials up front makes the demo run smoother!</p>
<p>Next, fire up VS11 (aka Microsoft Visual Studio 11 Express for Windows Developer Preview). Create a new project and select the Visual C# -&gt; Windows Metro Style -&gt; Application template.</p>
<p>Once the new project has been created, you should be looking at the MainPage.xaml file. Update the Grid element to contain a button and an image.</p>
<pre class="brush:xml">&lt;Grid x:Name=&quot;LayoutRoot&quot; Background=&quot;#FF0C0C0C&quot;&gt;
    &lt;Button x:Name=&quot;ClickMe&quot; Click=&quot;ClickMe_Click&quot;&gt;Click Me&lt;/Button&gt;
    &lt;Image x:Name=&quot;Photo&quot; Width=&quot;800&quot; Height=&quot;600&quot;
           HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt;
&lt;/Grid&gt;</pre>
<p>Next, hover over the Click=&#8221;ClickMe_Click&#8221; attribute of the button, right click and select &#8220;Navigate to Event Handler&#8221;. VS11 will take you to MainPage.xaml.cs and automatically generate a skeleton event handler for you.</p>
<p>In my //build session, I demonstrated that VS11 can automatically resolve WinRT namespaces the same way that it resolves managed namespaces. But for the purposes of this blog post, it&#8217;s easier if you just add&nbsp;the additional using statements we&#8217;re going to need at the top of MainPage.xaml.cs now.</p>
<pre class="brush:csharp">using Windows.Media.Capture;
using Windows.Storage;
using Windows.UI.Xaml.Media.Imaging;
using Windows.ApplicationModel.DataTransfer;
using Windows.Storage.Streams;</pre>
<p>Now, we add the code for ClickMe_Click:</p>
<pre class="brush:csharp">private async void ClickMe_Click(object sender, RoutedEventArgs e)
{
    var ui = new CameraCaptureUI();
    ui.PhotoSettings.CroppedAspectRatio = new Size(4, 3);

    var file = await ui.CaptureFileAsync(CameraCaptureUIMode.Photo);

    if (file != null)
    {
        var stream = await file.OpenAsync(FileAccessMode.Read);

        var bitmap = new BitmapImage();
        bitmap.SetSource(stream);
        Photo.Source = bitmap;
    }
}</pre>
<p>A few things to note about this code:</p>
<ul>
<li>Even though it&#8217;s using native WinRT libraries, the C# feels natural and familiar &#8211; as if you were calling into traditional managed libraries. We&#8217;re newing up classes, we&#8217;re passing in constructor parameters, we&#8217;re using primitive numbers and enums, we&#8217;re assigning properties, etc. That is very much by design.</li>
<li>We&#8217;re using a couple of async WinRT methods (CaptureFileAsync and OpenAsync). C# 5.0&#8242;s new await keyword to make it extremely easy to write linear looking code that doesn&#8217;t block on async operations.</li>
<li>No P/Invoke or COM Interop attributes anywhere to be seen!</li>
</ul>
<p>Finally, before we can run this code we need to declare our intent to use the webcam. Double click on the Package.appxmanifest file, click on the &#8220;Capabilites&#8221; tab, and then check the Webcam checkbox.</p>
<p>With the capability declared, now we can run the app. Hit F5 and VS11 will compile and deploy the Metro style app you just built. Click the button, acknowledge that you want to let the program use the webcam, take a pic, crop it, and there it is in your UI!</p>
<p>For the second part of the demo, I added share contract support. Here&#8217;s how to do that.</p>
<p>First, we need to pull the stream variable into class instance scope so that we can access it in the share contract event handler. We do that by adding a private IRandomAccessStream variable named stream and removing the var declarations from the line where we call OpenAsync. The updated click event handler looks like this:</p>
<pre class="brush:csharp">//here's the instance scope stream variable
IRandomAccessStream stream;

private async void ClickMe_Click(object sender, RoutedEventArgs e)
{
    var ui = new CameraCaptureUI();
    ui.PhotoSettings.CroppedAspectRatio = new Size(4, 3);

    var file = await ui.CaptureFileAsync(CameraCaptureUIMode.Photo);

    if (file != null)
    {
        //the only change from the code above was to remove
        //the var declaration from the following line
        stream = await file.OpenAsync(FileAccessMode.Read);

        var bitmap = new BitmapImage();
        bitmap.SetSource(stream);
        Photo.Source = bitmap;
    }
}</pre>
<p>Next, we need to wire up the share event handler in the XAML page&#8217;s constructor. That&#8217;s a single line of code and VS11 intellisense writes most of &nbsp;it for you</p>
<pre class="brush:csharp">public MainPage()
{
    InitializeComponent();
    DataTransferManager.GetForCurrentView().DataRequested +=
        new TypedEventHandler&lt;DataTransferManager, DataRequestedEventArgs&gt;(MainPage_DataRequested);
}</pre>
<p>If you&#8217;ve ever wired up an event handler in C# before with VS, you&#8217;ll be familiar with the &#8220;Press TAB to insert&#8221; the correct event handler type followed by &#8220;TAB to generate handler&#8221;. Even though hthis is a WinRT event, VS11 helps you wire it up just the same as it does for managed events.</p>
<p>Now we implement the share contract event handler. That&#8217;s just a simple if statement &#8211; calling args.Request.Data.SetBitmap if the user has taken a picture and calling args.Request.FailWithDisplayText with an error message if they have not.</p>
<pre class="brush:csharp">private void MainPage_DataRequested(DataTransferManager sender,
    DataRequestedEventArgs args)
{
    if (stream == null)
        args.Request.FailWithDisplayText(&quot;No picture taken!&quot;);
    else
        args.Request.Data.SetBitmap(stream);
}</pre>
<p>This part of the demo shows off static methods and event handlers.&nbsp;Again, note how natural and familiar it feels to use WinRT from C#.</p>
<p>And we&#8217;re done, so hit F5 to build, deploy and run the app again.</p>
<p>I didn&#8217;t remember to do this in the //build talk, but first try selecting the share contract <em>before </em>taking a picture. Windows will display the &#8220;No picture taken&#8221; text in share contract window since the user taken a picture to share yet. That&#8217;s pretty boring so dismiss the share contract and take a picture like you did before. Then select the share contract, select Socalite, write a pithy message and press &#8220;Share in Facebook&#8221;.</p>
<p>That&#8217;s the entire demo! Taking a picture with the webcam, uploading to facebook, calling native WinRT APIs from C# in a natural and familiar way and all in just under 15 lines of code!</p>
<p>With our talk and demos, Jesse and I wanted to communicate just how important C# and VB are in the overall developer story for Windows 8. This demo shows off the hard work our two teams have done in order to make sure the managed developer&#8217;s experience with Windows 8 was the best that it could be.&nbsp;As I said in the talk &#8211; if you&#8217;re a managed developer, <span style="text-decoration: underline;">you already know how to build these Metro style apps</span>.</p>
<p>I know I <a href="http://devhawk.net/2011/09/15/the-windows-runtime/">said it before</a>, but I really can&#8217;t wait to see what you guys build with Windows 8!</p>
