<p></p>
<p>As I wrote earlier, I&#8217;m really impressed with <a href="http://msdn.microsoft.com/practices">p&amp;p</a>&#8216;s latest release &#8211; the <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnpag2/html/cabctp.asp">Composite UI Application Block</a>. I had to fly to Atlanta for a customer meeting last week and I spent most of my spare time (flying, in hotel, etc) digging thru CAB. Well, digging through CAB and reading <a href="http://www.crichton-official.com/fear/index.html">State of Fear</a> by <a href="http://www.crichton-official.com/">Michael Crichton</a>. IMO, it&#8217;s his best book in quite a while, perhaps second best he&#8217;s ever written after Jurassic Park.</p>
<p>Back to CAB. First off, I want more information about ObjectBuilder. p&amp;p&#8217;s dependency injection framework is very impressive. However, with the exception of the code, the code reference in the help files, the unit tests, and a single article on how it was designed there just isn&#8217;t much info on it. For example, I <i>know</i> I can use it to inject a concrete type where a class is expecting an abstract type. But I couldn&#8217;t figure out how so I went and asked <a href="http://www.peterprovost.org/">Peter</a> and <a href="http://www.agileprogrammer.com/dotnetguy/">Brad</a>. (Short answer &#8211; use TypeMappingPolicy). Do me a favor, go contact <a href="http://www.peterprovost.org/contact.aspx">Peter</a> and <a href="http://www.agileprogrammer.com/dotnetguy/contact.aspx">David</a> and tell them you want more info on ObjectBuilder. Sample code especially. Go on, drop them a line right now while you&#8217;re thinking about it. I&#8217;ll wait.</p>
<p>Back already? Cool. One thing you can&#8217;t help but notice about CAB (and OB for that matter) is the heavy use of attributes, which I feel is an extremely elegant solution. Remember the first time you looked at <a href="http://www.nunit.org/">NUnit</a>? How <i>sensible </i>it seemed to use attributes like [TestFixture], [Test] and [ExpectedException] compared to what other xUnit frameworks provide? Get ready to experience that all over again when you look at OB and CAB. Now you&#8217;re looking at attributes like [CreateNew], [EventPublication] and [CommandHandler]. There&#8217;s a reason why Sun <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html">cloned attributes</a> for J2SE 5.0 &#8211; it&#8217;s powerful (in the right hands). The attributes both drive human readability &#8211; when you&#8217;re looking at a property adorned with [CreateNew] or [Dependency] it&#8217;s obvious that these are injected &#8211; as well as the implementation. Win-win as far as I&#8217;m concerned.</p>
<p>CAB does a great job of codifying standard patterns in smart client design, such as events, commands and controllers, as well as implementing completely new ideas such as workspaces, work items and smart parts. And they&#8217;ve done it with an eye on the future. I love the isolation between the windows forms specific parts of CAB and the underlying infrastructure of CAB. Check out <a class="grouped_elements" href="http://msdn.microsoft.com/library/en-us/dnpag2/html/cabcbt_02.png" rel="tc-fancybox-group658">this picture</a> of the layers of CAB. By isolating all the WinForms specific stuff in a separate assembly, they are well set up to support <a href="http://msdn.microsoft.com/windowsvista/building/presentation/">WPF</a> while minimizing redundant effort. I can&#8217;t wait to see a Microsoft.Practices.CompositeUI.Avalon project (because Microsoft.Practices.CompositeUI.WindowsPresentationFoundation is just to long a namespace).</p>
<p>However, I can&#8217;t shake the feeling of how complex this stuff is. Yeah, you use CAB for solving complex problems, but there is a significant learning curve here. I imagine debugging a CAB app will be significantly non-trivial. Take a look at the final step of the walkthru app. Here&#8217;s the sequence that gets &#8220;hello world&#8221; painted on the screen:</p>
<ol>
<li>Main entrypoint creates and runs the ShellApplication.</li>
<li>ShellApplication creates a ShellForm window, which in turn contains the tabWorkspace1 workspace.</li>
<li>ShellApplication dynamically loads MyModule because it&#8217;s listed in the ProfileCatalog.xml file.</li>
<li>CAB creates an instance of the MyModuleInit class from the MyModule assembly.</li>
<li>MyModuleInit creates and runs an instance of MyWorkItem.</li>
<li>MyWorkItem creates a MyView and MyPresenter.</li>
<li>MyWorkItem adds the MyView instance to the tabWorkspace1 workspace, hosted in the ShellForm</li>
<li>MyPresenter handles the MyView load event and sets the message property of MyView to &#8220;Hello, World&#8221;</li>
</ol>
<p>Of course, the point of a demo app like the walkthru is comprehension. You would never use CAB to build this Hello World app. But I worry that the level of complexity will put CAB beyond the reach or inclination on many potential users. I imagine this single line of code will scare off many would-be CAB developers:</p>
<p style="FONT-FAMILY: courier new"><span style="COLOR: #008080">MyWorkItem</span> myWorkItem = parentWorkItem.WorkItems.AddNew&lt;<span style="COLOR: #008080">MyWorkItem</span>&gt;();</p>
<p>Given that most people are used to writing &#8220;<span style="FONT-FAMILY: courier new"><span style="COLOR: blue">new</span><span style="COLOR: #008080">MyWorkItem</span>()</span>&#8220;, the line above represents a significantly rise in complexity. Of course, CAB is trying to solve a complex problem. I&#8217;m sure CAB&#8217;s designers would rather the solution wasn&#8217;t so complex, but that&#8217;s the reality of the problem space their dealing with. </p>
<p>If you can&#8217;t lower the complexity of your framework, it&#8217;s time to raise the abstraction of your tools. </p>
<p>I wonder what CAB specific tooling would look like? At a minimum, it would like built in support for the primary concepts in CAB &#8211; WorkItem, SmartPart, Workspace and Service to name a few. Another opportunity would be to move from embedded strings, used to identify events, commands, UIExtensionSites and the like to true variable-style names that could be validated at compile time, sort of like how LINQ is extending C# to get rid of embedded database query commands. There&#8217;s lots of possibilities and the more I work w/ CAB the better idea I&#8217;ll have about them.</p>
