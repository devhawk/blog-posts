<p>The first thing I need for my F# parser is a type to represent the buffer of characters being parsed. For now, I&#8217;m using the <a href="http://www.artima.com/intv/simplest.html">simplest thing that could possibly work</a>: an intrinsic F# character list. Lists are heavily used in functional languages, so they tend to have very efficient native list types. F# is no exception. Along with a native list type, F# has a native operation for retrieving the head of a list. For example, If you execute the following code, head will be bound to &#8217;1&#8242; and tail will be bound to the list ['2';'3';'4']</p>
<pre class="brush: fsharp">let head :: tail = ['1';'2';'3';'4']</pre>
<p>The problem using the native list head operator is that my parsing code will be explicitly bound to work on character lists only. However, I&#8217;m not sure an in-memory character list is the best way to read long files of text off the disk for processing, so I&#8217;d rather not limit future options like this. So instead, I&#8217;ll define my own function to retrieve the head of the parsing buffer.</p>
<pre class="brush: fsharp">let NC input =
    match input with
    | head :: tail -&gt; Some(head, tail)
    | _ -&gt; None</pre>
<p>Note, in all my F# code I use the <a href="http://blogs.msdn.com/dsyme/archive/2006/08/24/715626.aspx">#light syntax</a> which means code blocks are indicated by significant whitespace indentation similar to Python.</p>
<p>NC stands for Next Character, though I gave it a short name since it&#8217;s used often. It&#8217;s basically wraps the native list head operator. If there&#8217;s at least one element in the list, the first clause matches and the function returns Some(head,tail). If the list is empty, the second clause matches and the function returns None. The use of Some and None means this function returns an F# option type, which is similar to .NET&#8217;s <a href="http://msdn2.microsoft.com/en-us/library/system.nullable.aspx" target="_blank">Nullable</a> type. (head,tail) is a tuple &#8211; in this case, combining the head and the tail of the list together. Finally, the underscore in the second match clause is a wildcard, so that clause matches anything. I&#8217;m using it here like the default clause of a switch statement in C#.</p>
<p>The F# type for this function is &#8216;a list -&gt; (&#8216;a * &#8216;a list) option. The &#8216;a is a generic type parameter and the asterisk indicates a tuple. So NC takes a generic list, and returns an option tuple with a single generic element and a generic list. Even though the function is named Next Character, it would work with a list of any type.</p>
<p>Now that I have my own list head function, the rest of my parsing code can it. If I later decide to change the type of the parse buffer, I can change the implementation of NC &#8211; including the input and return types &#8211; without having to change the parsing functions that use NC. For example, here&#8217;s a different implementation where the input parameter is a .NET string instead of a char list.</p>
<pre class="brush: fsharp">let NC (input : string) =
    if input.Length &gt; 0
        then Some(input.Chars(0), input.Substring(1))
        else None</pre>
<p>Since I&#8217;m calling methods on the input parameter, I need to explicitly tell F# what type it is. The F# type for this function is string -&gt; (char * string) option, which is obviously different from the type definition of the original NC version. But F#&#8217;s <a href="http://devhawk.net/2007/11/29/F+Hawkeye+Type+Inference.aspx">type inference</a> automatically adjusts to handle the change in the type so functions that call NC don&#8217;t have to change. FP languages like F# handle list operations extremely efficiently, so this version of NC is probably a step in the wrong direction. However, it&#8217;s good to know I can easily encapsulate the details our the parse buffer type away from the rest of my parsing code.</p>
<p>Here&#8217;s another function I&#8217;ll use in parsing, defined entirely in terms of NC.</p>
<pre class="brush:fsharp">let TOKEN token input =
    let rec ParseToken token input =
        match token, NC input with
        | t :: [], Some(i, input) when i = t -&gt;
            Some(input)
        | t :: token, Some(i, input) when i = t -&gt;
            ParseToken token input
        | _ -&gt; None
    ParseToken (List.of_seq token) input</pre>
<p>The TOKEN function checks to see if the token string is at the front of the input parse buffer. If so, it returns the remainder of the buffer after the token. If not, it returns None. It&#8217;s defined entirely in terms of NC, so it works the same with both the versions of NC I&#8217;ve written so far. However, depending on the implementation of NC, I might rewrite TOKEN. For example, if I was using the string version of NC, I&#8217;d probably rewrite this function to use <a href="http://msdn2.microsoft.com/en-us/library/system.string.startswith.aspx" target="_blank">String.StartsWith</a> instead of recursion.</p>
<p>TOKEN defines a local recursive function called ParseToken. It&#8217;s very common to see local functions defined inside other functions in FP, similar to how classes can define local classes in OO languages like C#. ParseToken recursively compares the characters in the token string with the characters in the input buffer, finishing when either it reaches the end of the token string or there&#8217;s a mismatch. By default, functions in F# can&#8217;t call themselves recursively by default, so ParseToken is declared to be recursive by using &#8220;let rec&#8221; instead of simply &#8220;let&#8221;.</p>
<p>ParseToken shows off something interesting about the way symbols are used in F#. Remember that F# values are immutable by default. Yet, the symbols &#8220;token&#8221; and &#8220;input&#8221; appear to change. In the match statement, token and input represent the values passed into the function. However, in the match clauses, token and input represent the tail of those two lists. Technically, the values didn&#8217;t change, F# allows you to reuse the symbols. If I wanted to avoid reusing symbols, I could define ParseToken this way (though I find this much less readable):</p>
<pre class="brush:fsharp">let rec ParseToken token input =
    match token, NC input with
    | t :: [], Some(i, itail) when i = t -&gt;
        Some(itail)
    | t :: ttail, Some(i, itail) when i = t -&gt;
        ParseToken ttail itail
    | _ -&gt; None</pre>
<p>Other than declaring ParseToken, the TOKEN function is a single line of code. It simply calls ParseToken, converting the token parameter into a char list along the way. While lists are very efficient, which would you rather type?</p>
<pre class="brush: fsharp">let token = TOKEN ['f';'o';'o'] input
let token = TOKEN &quot;foo&quot; input</pre>
<p>Personally, I like the second version. I&#8217;m sure there&#8217;s a slight perf hit to convert from a string to a list, but frankly I value readability over performance so I used strings for tokens. TOKEN uses the List.of_seq function to do the conversion. Seq is F#&#8217;s name for IEnumerable. Technically, TOKEN would work with any IEnumerable type. However, in my source code, it&#8217;s always going to be a string.</p>
<p>I also used List.of_seq to define a helper function String to Parse Buffer (aka S2PB) that converts a string into a character list. I use function often in the test code.</p>
<pre class="brush:fsharp">let S2PB input = List.of_seq input</pre>
<p>If I were to change the input type of NC, I&#8217;d also change the implementation of S2PB so that it still took in a string but returned whatever the correct input type for NC.</p>
<p>The one problem with S2PB function is that you have to use it with parentheses almost all the time. If I write NC S2PB &#8220;foo&#8221;, F# can&#8217;t tell if I&#8217;m calling NC with two parameters or passing the result of S2PB &#8220;foo&#8221; to NC. Since NC is strongly typed to have only one input parameter, you might have thought it could automatically determine the calling order, but it doesn&#8217;t.</p>
<p>I could make the function calls explicit with parenthesis by writing NC (S2PB &#8220;foo&#8221;). F# also provides a pipe operator, so I could pipe the result of S2PB into NC by writing S2PB &#8220;foo&#8221; |&gt; NC. I didn&#8217;t like either of those solutions, so instead I defined a custom unary operator !! as an alias. The parameter binding rules are different for custom operators because I can write NC !! &#8220;foo&#8221; without piping or parenthesis.</p>
<pre class="brush: fsharp">let (!!) input = S2PB input</pre>
<p>So now I&#8217;ve got three functions and a custom operator that completely abstract away the parse buffer type. As long a my parsing functions only uses these functions to access the parse buffer, I&#8217;ll be able to later change the buffer type without affecting my parsing code at all.</p>
