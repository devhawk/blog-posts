<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>IronPython and WPF Part 5: Interactive Console</title>
  <link>http://devhawk.net/2008/11/24/ironpython-and-wpf-part-5-interactive-console/</link>
  <pubDate>Mon, 24 Nov 2008 10:45:35 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://92f9770d-1f99-4aa4-914a-b28e1445c22f</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>One of the hallmarks of dynamic language programming is the use of the interactive prompt, otherwise known as the <a href="http://en.wikipedia.org/wiki/REPL">Read-Eval-Print-Loop</a> or REPL. Even though I’m building a WPF client application, I’d still like to have the ability to poke around and even modify the app as it’s running from the command prompt, REPL style. </p><p>If you work thru the IronPython <a href="http://www.codeplex.com/IronPython/SourceControl/changeset/file/view/43829/649827">Tutorial</a>, there are exercises for interactively building both a WinForms and a WPF application. In both scenarios, you create a dedicated thread to service the UI so it can run while the interactive prompt thread is blocked waiting for user input. However, as we saw in the <a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">last part of this series</a>, UI elements in both WinForms and WPF can only be accessed from the thread they are created on. We already know how to marshal calls to the correct UI thread – <a href="http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcher.invoke.aspx">Dispatcher.Invoke</a>. However, what we need is a way to intercept commands entered on the interactive prompt so we can marshal them to the correct thread before they execute. </p><p>Luckily, IronPython provides just such a mechanism: <a href="http://www.codeplex.com/IronPython/SourceControl/changeset/file/view/43829/649872">clr module’s</a> SetCommandDispatcher. A command dispatcher is a function hook that gets called for every command the user enters. It receives a single parameter, a delegate representing the command the user entered. In the WPF and WinForms tutorials, you use this function hook to marshal the commands to the right thread to be executed. Here’s the command dispatcher from the WPF tutorial:</p><pre class="brush: python">
def DispatchConsoleCommand(consoleCommand):     
    if consoleCommand:     
        dispatcher.Invoke(DispatcherPriority.Normal, consoleCommand)
</pre><p>The dispatcher.Invoke call looks kinda like the UIThread decorator from the <a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">Background Processing</a> part of this series, doesn’t it?</p><p>Quick aside: I looked at using SyncContext here instead of Dispatcher, since I don’t care about propagating a return value back to the interactive console thread. However, SyncContext expects a <a href="http://msdn.microsoft.com/en-us/library/system.threading.sendorpostcallback.aspx">SendOrPostDelegate</a>, which expects a single object parameter. The delegate passed to the console hook function is an <a href="http://msdn.microsoft.com/en-us/library/system.action.aspx">Action</a> with no parameters. I could have built a wrapper function that took a single parameter which it would ignore, but I decided it wasn’t worth it. The more I look at it, the more I believe SyncContext is a good idea with a bad design. </p><p>I wrapped all the thread creation and command dispatching into a reusable helper class called InteractiveApp.</p><pre class="brush: python">
class InteractiveApp(object):     
  def __init__(self):     
    self.evt = AutoResetEvent(False)     
     
    thrd = Thread(ThreadStart(self.thread_start))     
    thrd.ApartmentState = ApartmentState.STA     
    thrd.IsBackground = True
    thrd.Start()     
     
    self.evt.WaitOne()     
    clr.SetCommandDispatcher(self.DispatchConsoleCommand)     
     
  def thread_start(self):     
    try:     
      self.app = Application()     
      self.app.Startup += self.on_startup     
      self.app.Run()     
    finally:     
      clr.SetCommandDispatcher(None)     

  def on_startup(self, *args):     
    self.dispatcher = Threading.Dispatcher.FromThread(Thread.CurrentThread)     
    self.evt.Set()     
     
  def DispatchConsoleCommand(self, consoleCommand):     
    if consoleCommand:     
        self.dispatcher.Invoke(consoleCommand)     
     
  def __getattr__(self, name):     
    return getattr(self.app, name)
</pre><p>The code is pretty self explanatory. The constructor (__init__) creates the UI thread, starts it, waits for it to signal that it’s ready via an AutoResetEvent and then finally sets the command dispatcher. The UI thread creates and runs the WPF application, saves the dispatcher object as a field on the object, then signals that it’s ready. DispatchConsoleCommand is nearly identical to the earlier version, I’ve just made it an instance method instead of a stand-alone function. Finally, I define __getattr__ so that any operations invoked on InteractiveApp are passed thru to the contained WPF Application instance. </p><p>In my app.py file, I look to see if the module has been started directly or if it’s been imported into another module. If the module is run directly (aka ‘ipy app.py’) then the global __name__ variable will be ‘__main__’. In that case, we start the application up normally (i.e. without the interactive prompt) by just creating an Application then running it with a Window instance. Otherwise, we are importing this app into another module (typically, the interactive console), so we create an InteractiveApp instance and we create an easy to use run method that can create the instance of the main window.</p><pre class="brush: python">
if __name__ == '__main__':     
  app = wpf.Application()     
  window1 = MainWin.MainWindow()     
  app.Run(window1.root)     
   
else:  
  app = wpf.InteractiveApp()     

  def run():     
    global mainwin     
    mainwin = MainWin.MainWindow()     
    mainwin.root.Show()
</pre><p>If you want to run the app interactively, you simply import the app module and call run. Here’s a sample session where I iterate thru the items bound to the first list box. Of course, I can do a variety of other operations I can do such as manipulate the data or create new UI elements. </p><pre class="brush: text">
IronPython 2.0 (2.0.0.0) on .NET 2.0.50727.3053   
&gt;&gt;&gt; import app   
&gt;&gt;&gt; app.run()   
#at this point the app window launches 
&gt;&gt;&gt; for i in app.mainwin.allAlbumsListBox.Items:   
...     print i.title   
...   
Harvest Festivals   
Mrs. Gardner's Art   
Riley's Playdate   
August 13   
Camp Days   
July 14   
May Photo Shoot   
Summer Play 2006   
Lake Washington With The Gellers   
Camp Pierson '06   
January 28
</pre><p>One small thing to keep in mind: if you exit the command prompt, the UI thread will also exit since it’s marked as a background thread. Also, it looks like you could shut the client down then call run again to restart it, but you can’t. If you shut the client down, the Run method in InteractiveApp.thread_start exits, resets the Command Dispatcher to nothing and the thread terminates. I could fix it so that you could run the app multiple times, but I find I typically only run the app once for a given session anyway. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1196</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2008-11-24 10:45:35</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2008-11-24 10:45:35</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">ironpython-and-wpf-part-5-interactive-console</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="wpf"><![CDATA[WPF]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[92f9770d-1f99-4aa4-914a-b28e1445c22f]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[IronPython+And+WPF+Part+5+Interactive+Console]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2008/11/24/IronPython+And+WPF+Part+5+Interactive+Console]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2145</wp:comment_id>
    <wp:comment_author><![CDATA[Lukas Cenovsky]]></wp:comment_author>
    <wp:comment_author_email>cenovsky@bakalari.cz</wp:comment_author_email>
    <wp:comment_author_url>http://gui-at.blogspot.com/</wp:comment_author_url>
    <wp:comment_author_IP>195.250.144.226</wp:comment_author_IP>
    <wp:comment_date>2008-11-25 05:58:36</wp:comment_date>
    <wp:comment_date_gmt>2008-11-25 13:58:36</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Hi,
what about using ThreadPool? See my post: http://gui-at.blogspot.com/2008/06/exploring-test-application-ironpython-2.html
I don't see any functional difference and you don't need to care about Invoke.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2146</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>71.231.42.80</wp:comment_author_IP>
    <wp:comment_date>2008-11-26 21:50:48</wp:comment_date>
    <wp:comment_date_gmt>2008-11-27 05:50:48</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[@lukas, I tried using the ThreadPool instead of manually spinning up a thread and it crashed. At least for WPF, the UI objects must be created on an STA thread and the ThreadPool threads are all MTA. 

As for not caring about Invoke, this code does not work without the command dispatcher calling Invoke. Just for kicks, I tried commenting it out and I get a "The calling thread cannot access this object because a different thread owns it." if I try to interact with the WPF objects in any way. 

I see from your blog entry that you're using WinForms not WPF, but I'm 99% sure the rules are the same. From http://msdn.microsoft.com/en-us/library/system.windows.forms.control.invokerequired.aspx: "Controls in Windows Forms are bound to a specific thread and are not thread safe. Therefore, if you are calling a control's method from a different thread, you must use one of the control's invoke methods to marshal the call to the proper thread."]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2147</wp:comment_id>
    <wp:comment_author><![CDATA[Lukas Cenovsky]]></wp:comment_author>
    <wp:comment_author_email>cenovsky@bakalari.cz</wp:comment_author_email>
    <wp:comment_author_url>http://gui-at.blogspot.com/</wp:comment_author_url>
    <wp:comment_author_IP>195.250.144.226</wp:comment_author_IP>
    <wp:comment_date>2008-11-27 09:37:30</wp:comment_date>
    <wp:comment_date_gmt>2008-11-27 17:37:30</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[The threading is still kind of mystery for me. Especially when something works for me which shouldn't according to others.

Your first point is correct - I use WinForms instead of WPF. I also use IronPython 1.1.1 on .NET 2.0.50727.3053.

I do not call methods on WinForms. I only read properties because I simulate all methods via Win32 API calls. For example, when I want to click button, I send mouse click event to the position of the button. 

Interestingly, when I directly call OnClick method of a button, the method runs OK and the button is clicked. For example, using http://gui-at.cendaweb.cz/GUIAT_PoC.exe run:

IronPython 1.1.1 (1.1.1) on .NET 2.0.50727.3053
Copyright (c) Microsoft Corporation. All rights reserved.
>>> import clr
>>> clr.AddReference('System')
>>> clr.AddReference("System.Windows.Forms")
>>> from System import *
>>> from System.Reflection import *
>>> from System.Threading import *
>>> from System.Windows.Forms import Application
>>> from time import sleep
>>>
>>> def RunMeCallBack(var):
...     global App
...     asm = Assembly.LoadFrom('GUIAT_PoC.exe')
...     asm_type = asm.GetType('GUIAT_PoC.frmGUIAT')
...     App = Activator.CreateInstance(asm_type)
...     Application.Run(App)
...
>>> App = None
>>> ThreadPool.QueueUserWorkItem(WaitCallback(RunMeCallBack))

Wait a moment until the app is loaded and run:
>>> App.Controls[2].Text = 'text'
>>> App.Controls[0].OnClick(None)

The 'text' is added to the listbox. Is this just a lucky chance I have or is it correct behavior? I do not know...

PS: I tried it on IronPython 20 RC2 (IronPython 2.0 (2.0.0.0) on .NET 2.0.50727.3053) now and it behaves the same.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>