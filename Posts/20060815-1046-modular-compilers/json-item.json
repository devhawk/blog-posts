{"status":"ok","post":{"id":781,"type":"post","slug":"modular-compilers","url":"http:\/\/devhawk.net\/2006\/08\/15\/modular-compilers\/","status":"publish","title":"Modular Compilers","title_plain":"Modular Compilers","content":"<p>During Lang.NET, I ended up sitting next to Hua Ming, who&#8217;s been working on the <a href=\"http:\/\/www.cs.iastate.edu\/~lumpe\/CBs\/\">.NET Classbox project<\/a> I <a href=\"http:\/\/devhawk.net\/2006\/08\/02\/LangNET+Is+Helping+Game+Developers.aspx\">wrote about previously<\/a>. .NET Classbox introduces a new syntax for &#8220;using&#8221; to C# &#8211; basically, you can use individual classes as well as whole namespaces, and you can extend the individual classes you use. Obviously, that meant having a custom compiler that was 99% vanilla C# + the extra classbox syntax. Rather than building a C# compiler from scratch, the Classbox project extended the <a href=\"http:\/\/www.mono-project.com\/\">Mono Project<\/a> C# compiler. Hua described the process as taking a &#8220;huge amount of time&#8221; and he described the compiler as &#8220;a monster&#8221;. Now, I&#8217;m not trying to knock Mono here, I imagine our C# compiler is just as hard to work with. <a href=\"http:\/\/msdn.microsoft.com\/net\/sscli\">SSCLI&#8217;s<\/a> C# compiler directory is 5.5MB of source code alone spread across 126 .h and 68 .cpp files.<\/p>\n<p>Is it just me, or does it seem crazy to have to muck about with such a large code base in order to add a relatively simple language feature? What I&#8217;d like to see is a more modular way of building compilers, so that integrating a small language feature like classbox would be a small amount of effort. <\/p>\n<p>Of course, there is some work that&#8217;s been done in this space. MS Research had a <a href=\"http:\/\/research.microsoft.com\/research\/pubs\/view.aspx?tr_id=658\">Research C# compiler<\/a>\u00a0paper, but it&#8217;s three years old and <a href=\"http:\/\/research.microsoft.com\/%7Etoddpro\/\">one<\/a> of the two authors has moved on to a <a href=\"http:\/\/www.microsoft.com\/windows\/cse\/default.mspx\">cool product group<\/a> job. I also discovered <a href=\"http:\/\/www-suif.stanford.edu\/suif\/NCI\/suif.html\">SUIF<\/a> and the <a href=\"http:\/\/www-suif.stanford.edu\/suif\/NCI\/\">National Compiler Infrastructure Project<\/a>, but these don&#8217;t look like they&#8217;ve been updated in a while.<\/p>\n<p>I like the model that the Research C# compiler proposes. Basically, it looks like this:<\/p>\n<ol>\n<li>Specify the grammar in a modular way. In the paper, the grammar is specified in an Excel file, and you can use multiple files in a modular fashion. i.e. have one file for the core language and another for the extensions.<\/li>\n<li>Late bind a grammar production to an action. Typically, in a lex\/yacc style scenario, you embed the action code for a given production directly into the grammar, which makes it extremely hard to extend the existing syntax. In the paper, each production is linked with an instance of a type, so swapping out a new type would seem to be possible.<\/li>\n<li>Generate an abstract syntax tree, that gets processed by multiple visitors. From the paper, the compiler has broken the &#8220;traditional&#8221; compiler steps &#8211; bind, typecheck, rewrite and generate binary (in this case IL) &#8211; into separate visitors. That makes adding extra steps or chaning existing steps fairly straightforward.<\/li>\n<\/ol>\n<p>The only think I don&#8217;t like about this specific approach is their Excel file based parser generator. It&#8217;s a huge step beyond the LEX\/YACC approach as it is scanner-less (having separate scanner and parser steps kills any chance of modularity) but it still has to deal with ambiguous grammars. Personally, I&#8217;ve been looking at <a href=\"http:\/\/pdos.csail.mit.edu\/~baford\/packrat\/\">Parsing Expression Grammars<\/a> in part because they aren&#8217;t ambiguous. For programming lanugages, support ambiguity in the grammar is a bug, not a feature.<\/p>\n","excerpt":"<p>During Lang.NET, I ended up sitting next to Hua Ming, who&#8217;s been working on the .NET Classbox project I wrote about previously. .NET Classbox introduces a new syntax for &#8220;using&#8221; to C# &#8211; basically, you can use individual classes as well as whole namespaces, and you can extend the individual classes you use. Obviously, that [&hellip;]<\/p>\n","date":"2006-08-15 10:46:37","modified":"2006-08-15 10:46:37","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":229,"slug":"lanugages","title":"Lanugages","description":"","post_count":43}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2398,"name":"Kenny Kerr","url":"http:\/\/weblogs.asp.net\/kennykerr\/","date":"2006-08-15 13:09:44","content":"<p>You should take a look at the Phoenix project. <\/p>\n<p><a href=\"http:\/\/research.microsoft.com\/phoenix\/\" rel=\"nofollow\">http:\/\/research.microsoft.com\/phoenix\/<\/a><\/p>\n","parent":0},{"id":2399,"name":"DevHawk","url":"","date":"2006-08-15 13:51:16","content":"<p>As far as I can tell, Phoenix only includes back end tools &#8211; i.e. no grammar definition and no parser. Sounds like a good choice for my #3 above, but what about the other two capabilities?<\/p>\n","parent":0},{"id":2400,"name":"Kenny Kerr","url":"http:\/\/weblogs.asp.net\/kennykerr\/","date":"2006-08-15 16:01:59","content":"<p>Yep, it\u2019s a long way off but I hope the Phoenix project (or something like it) will one day provide more support for developing the grammar and front-end for compilers.<\/p>\n<p>I\u2019ve typically resorted to rolling my own but that\u2019s obviously not practical in many cases.<\/p>\n","parent":0},{"id":2401,"name":"Max","url":"","date":"2006-09-10 02:10:47","content":"<p>The .NET language Boo actually implements its &#8220;using&#8221; keyword as a short piece of Boo code that does a transformation on the abstract syntax tree at compile time like so (pseudocode):<\/p>\n<p>using object:<br \/>\n  code block<\/p>\n<p>Becomes:<\/p>\n<p>Lock(object)<br \/>\ntry:<br \/>\n  code block<br \/>\nfinally:<br \/>\n  Unlock(object)<\/p>\n<p>You can define these AST transformations in your own program to implement most any construct you like, and they are really easy to write! Neat, eh? <\/p>\n<p><a href=\"http:\/\/boo.codehaus.org\/\" rel=\"nofollow\">http:\/\/boo.codehaus.org\/<\/a><\/p>\n","parent":0}],"attachments":[],"comment_count":4,"comment_status":"closed","custom_fields":{"dasblog_entryid":["59b31575-05b0-49d5-bebe-ffcf2c30bca7"],"dasblog_compressedtitle":["Modular+Compilers"],"dasblog_compressedtitleunique":["2006\/08\/15\/Modular+Compilers"]}},"previous_url":"http:\/\/devhawk.net\/2006\/08\/15\/extending-wl-writer\/","next_url":"http:\/\/devhawk.net\/2006\/08\/16\/business-processes-are-services-too\/"}