<p>During Lang.NET, I ended up sitting next to Hua Ming, who&#8217;s been working on the <a href="http://www.cs.iastate.edu/~lumpe/CBs/">.NET Classbox project</a> I <a href="http://devhawk.net/2006/08/02/LangNET+Is+Helping+Game+Developers.aspx">wrote about previously</a>. .NET Classbox introduces a new syntax for &#8220;using&#8221; to C# &#8211; basically, you can use individual classes as well as whole namespaces, and you can extend the individual classes you use. Obviously, that meant having a custom compiler that was 99% vanilla C# + the extra classbox syntax. Rather than building a C# compiler from scratch, the Classbox project extended the <a href="http://www.mono-project.com/">Mono Project</a> C# compiler. Hua described the process as taking a &#8220;huge amount of time&#8221; and he described the compiler as &#8220;a monster&#8221;. Now, I&#8217;m not trying to knock Mono here, I imagine our C# compiler is just as hard to work with. <a href="http://msdn.microsoft.com/net/sscli">SSCLI&#8217;s</a> C# compiler directory is 5.5MB of source code alone spread across 126 .h and 68 .cpp files.</p>
<p>Is it just me, or does it seem crazy to have to muck about with such a large code base in order to add a relatively simple language feature? What I&#8217;d like to see is a more modular way of building compilers, so that integrating a small language feature like classbox would be a small amount of effort. </p>
<p>Of course, there is some work that&#8217;s been done in this space. MS Research had a <a href="http://research.microsoft.com/research/pubs/view.aspx?tr_id=658">Research C# compiler</a>&nbsp;paper, but it&#8217;s three years old and <a href="http://research.microsoft.com/%7Etoddpro/">one</a> of the two authors has moved on to a <a href="http://www.microsoft.com/windows/cse/default.mspx">cool product group</a> job. I also discovered <a href="http://www-suif.stanford.edu/suif/NCI/suif.html">SUIF</a> and the <a href="http://www-suif.stanford.edu/suif/NCI/">National Compiler Infrastructure Project</a>, but these don&#8217;t look like they&#8217;ve been updated in a while.</p>
<p>I like the model that the Research C# compiler proposes. Basically, it looks like this:</p>
<ol>
<li>Specify the grammar in a modular way. In the paper, the grammar is specified in an Excel file, and you can use multiple files in a modular fashion. i.e. have one file for the core language and another for the extensions.</li>
<li>Late bind a grammar production to an action. Typically, in a lex/yacc style scenario, you embed the action code for a given production directly into the grammar, which makes it extremely hard to extend the existing syntax. In the paper, each production is linked with an instance of a type, so swapping out a new type would seem to be possible.</li>
<li>Generate an abstract syntax tree, that gets processed by multiple visitors. From the paper, the compiler has broken the &#8220;traditional&#8221; compiler steps &#8211; bind, typecheck, rewrite and generate binary (in this case IL) &#8211; into separate visitors. That makes adding extra steps or chaning existing steps fairly straightforward.</li>
</ol>
<p>The only think I don&#8217;t like about this specific approach is their Excel file based parser generator. It&#8217;s a huge step beyond the LEX/YACC approach as it is scanner-less (having separate scanner and parser steps kills any chance of modularity) but it still has to deal with ambiguous grammars. Personally, I&#8217;ve been looking at <a href="http://pdos.csail.mit.edu/~baford/packrat/">Parsing Expression Grammars</a> in part because they aren&#8217;t ambiguous. For programming lanugages, support ambiguity in the grammar is a bug, not a feature.</p>
