<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>More Stuff I Didn't Know About WF</title>
  <link>http://devhawk.net/2006/10/11/more-stuff-i-didnt-know-about-wf/</link>
  <pubDate>Wed, 11 Oct 2006 13:52:35 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://c69099e7-e12f-492b-be38-d8a4e6f42cd7</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>4. All communication from the host to the workflows goes thru the <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.workflow.runtime.workflowqueuingservice.aspx">WorkflowQueuingService</a>. Unlike other WF services, the queuing service <em>is not</em> replaceable. Communication from a workflow activity instance to the host goes thru some other service. There is no "default" activity -&gt; host communication service, though WF ships with the <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.workflow.activities.externaldataexchangeservice.aspx">ExternalDataExchangeService</a>. You have to manually add the ExternalDataExchangeService to your workflow runtime instance. WF also includes the <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms734408.aspx">wca.exe</a> utility which generates strongly typed <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms734592.aspx">HandleExternalEvent</a> and <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms734739.aspx">CallExternalMethod</a> activities for your workflow. And according to <a href="http://www.masteringbiztalk.com/blogs/jon">Jon</a>, the <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms735872.aspx">External Data Exchange system</a> was added specifically for SharePoint. </p><p>5. The built-in sequential and state machine workflows are customizable. So if you wanted to have a custom designer or validation experience for an otherwise standard sequential or state machine workflow, you can inherit from the standard workflow type and add the custom validation and / or designer support. For example, as I <a href="http://devhawk.net/2006/10/09/Things+I+Didnt+Realize+About+WF.aspx">wrote earlier</a>, you can load a workflow from XAML. XAML workflows can't support the Code Activity. So if you wanted to use the standard sequence designer but disallow the use of the Code Activity, you wouldn't have to rewrite the sequence activity from scratch.</p><p>6. You can execute workflows across a farm, similar to how you build a web farm. Workflows that get persisted to the persistence service can be loaded on any node in the farm. Of course, like web servers in a farm, you'd have to have the same bits installed on all the machines in the workflow farm. Sounds like an opportunity for something like <a href="http://www.microsoft.com/applicationcenter/default.mspx">Application Center</a> for WF.</p><p>7. The built in <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.workflow.runtime.hosting.sqlworkflowpersistenceservice.aspx">SQL Persistence Service</a> is a toy. When you start your workflow engine, the SQL Persistence Service will auto-load all the existing persisted workflows into memory, as an "optimization". So if you have thousands of order workflows persisted in your database and you decide to bring another workflow processing node online, that new workflow processing node will happily load <em>ALL</em> of the outstanding orders that it can find in the database. This service should have been included as a sample like the <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms741725.aspx">file based persistence service sample</a> rather than <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.workflow.runtime.hosting.sqlworkflowpersistenceservice.aspx">described</a> as "a fully functional persistence service" in the docs.</p><p>8. WF Web Service integration is also a toy. WF leverages basic ASMX for all it's web service integration, so your only choice for web services - <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms735862.aspx">consuming</a> or <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms733602.aspx">exposing</a> - is atomic request/response style services. You can have a workflow with multiple operations, but the default ASMX hosting infrastructure squirrels the WF Instance ID in the ASP.NET session, which will time out in twenty minutes (by default). Furthermore, the built in ASMX workflow host doesn't provide an option to specify the web service namespace, so it ends up with the default http://tempuri.org namespace. Again, like the SQL Persistence, this should have been included as a sample, not included in the standard activities.</p><p>9. Activities can <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms734652.aspx">generate code</a>. In the previous item, I mentioned there's basic ASMX hosting integration for a workflows. Turns out the WebService Activities generate that hosting code as part of the workflow compilation process. So in other words, if you add a WebService activity to your workflow, the activity will inject the custom ASMX hosting code into your compiled workflow. In this WebService activity case, the injected code isn't very good, but the fact you can do this at all is <em>very </em>cool.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">817</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2006-10-11 13:52:35</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2006-10-11 13:52:35</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">more-stuff-i-didnt-know-about-wf</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="development"><![CDATA[Development]]></category>
  <category domain="post_tag" nicename="wf"><![CDATA[WF]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2006/10/11/More+Stuff+I+Didnt+Know+About+WF]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[More+Stuff+I+Didnt+Know+About+WF]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[c69099e7-e12f-492b-be38-d8a4e6f42cd7]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2416</wp:comment_id>
    <wp:comment_author><![CDATA[Erik Johnson]]></wp:comment_author>
    <wp:comment_author_email>ejohnson@epicor.com</wp:comment_author_email>
    <wp:comment_author_url>http://appside.blogspot.com</wp:comment_author_url>
    <wp:comment_author_IP>70.181.202.20</wp:comment_author_IP>
    <wp:comment_date>2006-10-12 11:24:59</wp:comment_date>
    <wp:comment_date_gmt>2006-10-12 18:24:59</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Transactions are also a toy.  You can't call other flows within a transaction nor can you federate multiple workflow instances within a transaction.  This is understandable because a transaction context is a box threads enter and leave.  You can't -- by default at least -- know what thread(s) will execute your flow and there is no plumbing built into the WF engine to guide threads in or out of Tx contexts.

But you can implement a Manual Workflow Scheduler (I think), which bypasses the WorkflowQueuingService you mention.  But I haven't tried passing a transaction context in this way.  BTW, you can't even use a transaction (or a sleep activity) without attaching a WorkflowPersistenceService because these activities can invoke a dehydration cycle.  The SQLPersistenceService is, I think, a level up from being just a toy.  The SQLTrackingService was well, thought-out, IMO.  But because I was trying to use WF inside a more synchronous scenario, I ended up creating an oxymoronically named "MemoryPersistenceService" so I could use these activities without all the baggage.

I REALLY wished WF was more adept with XML data and XML Schema -- especially WRT the rules engine.  Also, I'm really disappointed that XAML isn't documented (well) and there isn't a schema for XAML.  I'm told on the newsgroups that there is no way to define a normative schema for XAML because you don't know the properties for the contained objects.  Fair enough, but a simple wildcard would work, right?

In fact the whole XAML angle looks like it got put on the back burner, which is a shame.  How cool is it to be able to whip a workflow up using an XMLWriter and then run it? You can do it, but you have to reverse-engineer the format.

Despite these nits, I'm a big fan of WF.  I like the engine design and it's fast (1ms overhead to execute a 10-step no-op sequental workflow.  ]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2417</wp:comment_id>
    <wp:comment_author><![CDATA[Jon Flanders]]></wp:comment_author>
    <wp:comment_author_email>jon.flanders@gmail.com</wp:comment_author_email>
    <wp:comment_author_url>http://www.masteringbiztalk.com/</wp:comment_author_url>
    <wp:comment_author_IP>72.165.51.170</wp:comment_author_IP>
    <wp:comment_date>2006-10-13 17:52:05</wp:comment_date>
    <wp:comment_date_gmt>2006-10-14 00:52:05</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Erik - the scheduler service override has absolutely nothing to do with the QueueingService.  The WorkflowQueueingService is one service you can't replace (well you might be able to replace it - but it will be a no-op since there aren't any virual methods to override).]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2418</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>24.16.94.200</wp:comment_author_IP>
    <wp:comment_date>2006-10-13 22:59:31</wp:comment_date>
    <wp:comment_date_gmt>2006-10-14 05:59:31</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I'm not sure I would call WF's transactions a toy. It certainly could be better - the stuff I'm working on right now I'd like to flow the Tx from outside the workflow (i.e. in a WF Service) into the Workflow, but I don't think there's any way to do that. 

Then again, on the other hand, transactions are really hard and easy to screw up. So maybe having specific boundaries to what you can and can't do in a workflow is a good thing?

A MemoryPersistenceService? That's funny...]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>