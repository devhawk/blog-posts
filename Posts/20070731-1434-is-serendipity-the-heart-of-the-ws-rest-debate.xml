<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Is Serendipity the Heart of the WS-*/REST Debate?</title>
  <link>http://devhawk.net/2007/07/31/is-serendipity-the-heart-of-the-ws-rest-debate/</link>
  <pubDate>Tue, 31 Jul 2007 14:34:08 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://6b4d0d87-7244-4a43-9cae-304a5c8a96d3</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Thanks to Technorati, I found <a href="http://johnheintz.blogspot.com/2007/07/integration-forethought-over.html">this post</a> by John Heintz. He's checking out <a href="http://blogs.msdn.com/jevdemon/archive/2007/07/20/soa-in-the-real-world-now-available.aspx">John Evdemon's</a><a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=cb2a8e49-bb3b-49b6-b296-a2dfbbe042d8&amp;displaylang=en">e-book on SOA</a> and has a problem with this overview:</p><blockquote><p>SOA is an architectural approach to creating systems built from autonomous services. With SOA, integration becomes forethought rather than afterthought. This book introduces a set of architectural capabilities, and explores them in subsequent chapters.</p></blockquote><p>To which John H. responds: </p><blockquote><p>I, for one, would rather build on an architecture that promotes integration as an afterthought, so I don't have to think about it before hand!!!</p></blockquote><p>Yeah, I'd rather not have to think about integration before hand either. On the other hand, I want integration that actually works. It sounds like John H. is suggesting here that REST somehow eliminates the need to consider integration up front. It doesn't. Consider this: if you're building a Web 2.0 site then you are <em>expected </em>to expose everything in your site via <a href="http://en.wikipedia.org/wiki/Atom_Publishing_Protocol">APP</a>, RSS and/or RESTful POX services. In other words, the Web 2.0 community expects you to have the forethought to enable integration. If you don't, Marc Canter <a href="http://blog.broadbandmechanics.com/2006/03/bill-and-tim-rap-it-out-i-ask-the-1st-question">will call you out</a> in front of Bill Gates and Tim O'Reilly.   </p><p>This integration by afterthought approach seems to be big among RESTifarians. John H. links to a <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/8873">REST discussion post</a> by Nick Gall advocating the principle of generality, "unexpected reuse" and "design for serendipity". Money quote:  </p><blockquote><p>The Internet and the Web are paradigms of Serendipity-Oriented Architectures. Why? Largely because of their simple generality. It is my belief that generality is one of the major enablers of serendipity. So here I immodestly offer Gall's General Principle of Serendipity: "Just as generality of knowledge is the key to serendipitous discovery, generality of purpose is the key to serendipitous (re)use."</p></blockquote><p>Serendipity means "<a href="http://encarta.msn.com/dictionary_/serendipity.html">the accidental discovery of something pleasant, valuable, or useful</a>". "Serendipitous reuse" sounds an awful lot like <a href="http://devhawk.net/2007/07/25/Now+How+Much+Would+You+Pay+For+This+Code.aspx">accidental reuse</a>. Most enterprises have been there, done that and have nothing to show for their efforts or $$$ except the team t-shirt. Yet <a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a><a href="http://www.w3.org/2005/Talks/0511-keynote-tbl">believes</a> "Unexpected reuse is the value of the web" and <a href="http://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a><a href="http://tech.groups.yahoo.com/group/rest-discuss/message/8343">tells us to</a> "Engineer for serendipity". What gives?</p><p>First off, enterprises aren't interested in unexpected or serendipitous reuse. They want their reuse to be systematic and predictable. The likelihood of serendipitous reuse is directly related to the number of potential reusers. But the number of potential reusers inside the enterprise is dramatically smaller than out on the public Internet. That brings the chance for serendipitous reuse inside the enterprise to nearly zero. </p><p>Second, enterprise systems aren't exactly known for their "simple generality". If Nick's right that "generality of purpose is the key to serendipitous (re)use", then enterprises might as well give up on serendipitous reuse right now. As I said last year, it's a <a href="http://devhawk.net/2006/09/19/A+Question+Of+Context.aspx">question of context</a>. Context is specifics, the opposite of generality. Different business units have different business practices, different geographies have different laws, different markets have different competitors, etc. If an enterprise operates in multiple contexts - and most do - enterprise solutions have to take them into account. Those different contexts prevent you from building usable - much less reusable - general solutions. </p><p>Finally, I think the amount of serendipitous reuse in REST is overstated. If you build an app on the <a href="http://developers.facebook.com/">Facebook Platform</a>, can you use it on MySpace? Nope. If you build an app that uses the <a href="http://www.flickr.com/services/api/">Flickr services</a>, will it work with <a href="http://code.google.com/apis/picasaweb/overview.html">Picasa Web Albums</a>? Nope. Of course, there are exceptions - pretty much everyone supports the MetaWeblog API - but those exceptions seem few and far between to me. Furthermore, the bits that are getting reused - such as identifier, format and protocol - are infrastructure capabilities more suitable to reuse anyway. Serendipitously reusing infrastructure capabilities is much easier than serendipitously reusing business capabilities, REST or not. </p><p>The problems that stand in the way of reuse aren't technology ones. Furthermore, the reuse problems face by enterprises are very different than ones faced by Web 2.0 companies. REST is a great approach, but it isn't a one-size-fits-all technology solution that magically relegates integration and reuse to "afterthought" status. Serendipity is nice, when it happens. However, <em>by definition</em> it's not something you can depend on. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1015</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-07-31 14:34:08</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-07-31 14:34:08</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">is-serendipity-the-heart-of-the-ws-rest-debate</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="rest"><![CDATA[REST]]></category>
  <category domain="post_tag" nicename="reuse"><![CDATA[Reuse]]></category>
  <category domain="post_tag" nicename="soa"><![CDATA[SOA]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[6b4d0d87-7244-4a43-9cae-304a5c8a96d3]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Is+Serendipity+The+Heart+Of+The+WSREST+Debate]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/07/31/Is+Serendipity+The+Heart+Of+The+WSREST+Debate]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2555</wp:comment_id>
    <wp:comment_author><![CDATA[Mark Baker]]></wp:comment_author>
    <wp:comment_author_email>distobj@acm.org</wp:comment_author_email>
    <wp:comment_author_url>http://www.markbaker.ca</wp:comment_author_url>
    <wp:comment_author_IP>209.161.202.187</wp:comment_author_IP>
    <wp:comment_date>2007-07-31 20:49:09</wp:comment_date>
    <wp:comment_date_gmt>2007-08-01 03:49:09</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Serendipity derives from commonality; the more our components agree upon before they meet, the more they can accomplish without requiring a software change.

You're right about Facebook and Flickr apps, but keep in mind that all it takes to create this problem is the slightest dependency of one component on anything specific to the implementation of the other.  In the cases of Facebook/Flickr, those dependencies are solely on data.  Had those APIs been WS-* APIs, the disagreement would have been far greater.

Look at it this way; one could consider Googlebot as a client of both Facebook and Flickr, but it has no dependency on any specific implementation detail of either.  It also handles other apps, including those yet to be developed, quite well too.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2556</wp:comment_id>
    <wp:comment_author><![CDATA[John Heintz]]></wp:comment_author>
    <wp:comment_author_email>john.heintz@newaspects.com</wp:comment_author_email>
    <wp:comment_author_url>http://johnheintz.blogspot.com/2007/08/rest-serendipity-and-hard</wp:comment_author_url>
    <wp:comment_author_IP>70.112.219.249</wp:comment_author_IP>
    <wp:comment_date>2007-08-01 20:18:59</wp:comment_date>
    <wp:comment_date_gmt>2007-08-02 03:18:59</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I've written a reply to your comments.

My main points are:

1. I want my systems building effort to have the highest leverage possible.

2. REST add uniformity constraints to promote loose-coupling and integration.

3. A few more quotes from the book.
]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2557</wp:comment_id>
    <wp:comment_author><![CDATA[John]]></wp:comment_author>
    <wp:comment_author_email>jevdemon@microsoft.com</wp:comment_author_email>
    <wp:comment_author_url>http://blogs.msdn.com/jevdemon</wp:comment_author_url>
    <wp:comment_author_IP>131.107.0.102</wp:comment_author_IP>
    <wp:comment_date>2007-08-09 16:28:16</wp:comment_date>
    <wp:comment_date_gmt>2007-08-09 23:28:16</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[The book defines SOA as "A loosely-coupled architecture designed to meet the business needs of the organization."  SOA does not necessarily require the use of Web Services or REST – these are, for most organizations, the simplest approach for implementing a loosely coupled solution architecture.   

There is no need for a REST/WS-* debate, simply use the approach best suited to the problem at hand.  The Microsoft Robotics Studio (http://msdn2.microsoft.com/en-us/robotics/default.aspx) illustrates how both can be supported, combining REST with event notifications, relationships between components and more.

"Some architectural styles are often portrayed as 'silver bullet' solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved."  - From Roy Fielding's REST dissertation ("Architectural Styles and
the Design of Network-based Software Architectures" - http://www.ics.uci.edu/~fielding/pubs/dissertation/software_arch.htm#sec_1_5)]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>