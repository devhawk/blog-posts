{"status":"ok","post":{"id":731,"type":"post","slug":"the-dual-schema-problem","url":"http:\/\/devhawk.net\/2006\/03\/28\/the-dual-schema-problem\/","status":"publish","title":"The Dual Schema Problem","title_plain":"The Dual Schema Problem","content":"<p>A few months ago, Ted Neward wrote a <a href=\"http:\/\/msdn.microsoft.com\/library\/en-us\/dndotnet\/html\/linqcomparisons.asp\">great article<\/a> about the history of the Object Relational Impedance Mismatch problem and how <a href=\"http:\/\/msdn.microsoft.com\/netframework\/future\/linq\">LINQ<\/a> is addressing it in a new way. Basically, LINQ is introducing new language abstractions and complementary libraries to enable queries as a first class concept within the language. However, I don&#8217;t believe that O\/R Impedance Mismatch is the whole problem. More specifically, it&#8217;s a follow-on problem to what I would call the Dual Schema problem.<\/p>\n<p>In a nutshell, the Dual Schema problem is that you have to design and implement two separate versions of your persistent entities. There&#8217;s the in memory version, typically written in an OO language like C# or Java. Then there&#8217;s the on disk version, typically written in SQL. Regardless of the difficulties translating between the two versions (i.e. the aforementioned impedance mismatch), you have to first deal with the complexity of keeping the two versions in sync. While LINQ does a great job eliminating much of the friction translating between on disk and in memory formats, it could go much farther by eliminating the need for translation in the first place.<\/p>\n<p>A variety of solutions to the Dual Schema problem have evolved, primarily outside the hallowed halls of enterprise vendors (i.e. MS and others like us). One such solution is <a href=\"http:\/\/www.rubyonrails.com\/\">Ruby on Rails<\/a>. In a Rails environment, I simply declare the existence of a given persistent entity:<\/p>\n<pre class=\"brush:ruby\">class Person &lt; ActiveRecord::Base\r\nend<\/pre>\n<p>The ActiveRecord base class (a standard part of Rails) will dynamically create methods and attributes on the Person object at runtime, based on the schema of the People table in the database. (Rails is smart enough to understand English plurals, hence the automatic connection of Person and People.) So technically there are still two schemas, but the in-memory version is automatically derived of the on-disk version.<\/p>\n<p>(Note, DLinq provides a conceptually similar tool &#8211; SqlMetal &#8211; that can generate the static types from a given database schema. However, as static types they have to be defined at compile time. So while SqlMetal reduces the effort to keep schemas in sync, it doesn&#8217;t eliminate it the way Rails does.)<\/p>\n<p>By slaving the object schema to the database schema, Rails essentially solves the Dual Schema problem. The problem with the Rails approach is that defining a database schema requires a significant amount of skill and effort. Defining classes is typically trivial in comparison.The fact Rails allows you to implement a persistent entity with almost no code doesn\u2019t help you much if you have to write and maintain a ton of SQL code to define your database schema.<\/p>\n<p>I believe the Rails model is actually backwards. It would be much better for the developer if they could define their persistent entity in code and slave the database schema to the object model instead of the other way around.<\/p>\n<p>Of course, this approach isn&#8217;t exactly news. In his article, Ted writes of the rise and fall of OO database management systems, which were supposed to solve the Dual Schema and Impedance Mismatch problems. I&#8217;m certainly not suggesting a return to the heyday of OODBMS. However, one of the reasons Ted points out OODBMS failed was because big companies were already wedded to RDBMS. But those big companies are the short head. As you move down the <a href=\"http:\/\/bnoopy.typepad.com\/bnoopy\/2005\/03\/the_long_tail_o.html\">long tail of software<\/a>, relational database as the primary storage paradigm makes less and less sense. For the vast majority of applications, relational databases are overkill.<\/p>\n<p>Ted&#8217;s other point about OODBMS is that loose coupling between the data store and the in memory representation is a feature, not a flaw. He&#8217;s totally right. But can&#8217;t we advance the state of the art in database typing to the level of modern day OO languages? How about eliminating anachronisms like fixed length strings? What if we derive the database schema from the object model &#8211; Rails in reverse if you will &#8211; but is still loosely coupled enough to allow for schema evolution?<\/p>\n<p>An example of this code-centric model for data storage is <a href=\"http:\/\/www.garret.ru\/~knizhnik\/consus.html\">Consus<\/a>. It\u2019s written by Konstantin Knizhnik, who has written a bunch of <a href=\"http:\/\/www.garret.ru\/~knizhnik\/databases.html\">open source, object-oriented and object-relational databases<\/a> across a wide variety of languages and execution environments, including CLR. Consus is actually written in Java, but he provides version compiled for .NET using <a href=\"http:\/\/msdn.microsoft.com\/vjsharp\/\">Visual J#<\/a>. Consus lets you to define your data either as tables or objects. So you can do this:<\/p>\n<pre class=\"brush:java\">Statement st = db.createStatement();\r\nst.executeUpdate(\"create table Person (name string, address string, salary bigint)\");\r\nst.executeUpdate(\"insert into Person values ('John Smith', '1 Guildhall St.', 75000)\");\r\nResultSet rs = st.executeQuery(\"select name, address, salary from Person where salary &gt; 100000\");<\/pre>\n<p>Or you can do this:<\/p>\n<p style=\"font-family: 'Courier New';\"><span style=\"font-family: Georgia, 'Bitstream Charter', serif;\"><\/p>\n<pre class=\"brush:java\">class Person {\r\n    String name;\r\n    String address;\r\n    long salary;\r\n    Person(String aName, long aSalary, String aAddress) {\r\n        name = aName;\r\n        salary = aSalary;\r\n        address = aAddress;\r\n    }\r\n};\r\n\r\nPerson p = new Person(\"John Smith\", 75000, \"1 Guildhall St.\");\r\nConsusStatement st = db.createStatement();\r\nstmt.insert(p);\r\nConsusResultSet cursor = (ConsusResultSet)st.executeQuery(\r\n    \"select from Person where salary &gt; 100000\");\r\n<\/pre>\n<p>Consus also handles OO concepts like derivation and containment. Of course, the embedded queries are ugly, but you could imagine DLinq style support for Consus. In fact, one of the primary issues with Consus is that it supports both object and tuple style queries. When you explicitly request tables (i.e. &#8220;select name, address salary from Person&#8221;), you\u2019ve got a tuple style query. When you don\u2019t (i.e. &#8220;select from Person\u201d) you\u2019ve got an object style query. Of course, the issues with tuple style queries are well documented in Ted\u2019s article and is exactly the problem that LINQ is designed to solve.<\/span><\/p>\n<p>(Konstantin, if you\u2019re reading this, <a href=\"mailto:harry.pierson@microsoft.com\">drop me a line<\/a> and I\u2019ll look into getting you hooked up with the LINQ folks if you\u2019re interested in adding LINQ support to Consus.NET.)<\/p>\n<p>The tradeoff between the Rails approach and the Consus approach is one of performance. I have a ton of respect for Konstantin and the work he\u2019s done on Consus and other OO and OR databases available from his site. However, I sure the combined developer forces at major database vendors like Microsoft (and other DB companies) means SQL Server (and the like) will out perform Consus by a significant margin, especially on large scale databases. So if execution performance is your primary criteria, the Ruby on Rails approach is better (leaving aside discussion of the Ruby runtime itself). However, in the long run execution performance is much less important than developer productivity. So I believe that &nbsp;for all the current interest in Rails, I think a Consus-style model will become dominant.<\/p>\n","excerpt":"<p>A few months ago, Ted Neward wrote a great article about the history of the Object Relational Impedance Mismatch problem and how LINQ is addressing it in a new way. Basically, LINQ is introducing new language abstractions and complementary libraries to enable queries as a first class concept within the language. However, I don&#8217;t believe [&hellip;]<\/p>\n","date":"2006-03-28 15:35:03","modified":"2011-04-16 23:54:34","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":214,"slug":"database","title":"Database","description":"","post_count":13},{"id":298,"slug":"scripting","title":"Scripting","description":"","post_count":4},{"id":188,"slug":"web-2-0","title":"Web 2.0","description":"","post_count":67}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2343,"name":"David","url":"http:\/\/www.from9till2.com","date":"2006-03-29 04:49:58","content":"<p>>So I believe that  for all the current interest in Rails, I think a Consus-style model will become dominant.<\/p>\n<p>Hmm, I&#8217;m not so sure, in the long run the Rails &#8216;model by convention&#8217; is the simplest form of solution, and we&#8217;ve seen how powerful\/persuasive the &#8216;simplest&#8217; can be in getting the mass adoption going, i.e. say RSS vs ATOM, RDBMS vs OODBMS, POX vs SOAP. So, not being a zealot but just pointing out that I&#8217;ve seen a lot of great ideas\/tech fall away due to not being the &#8216;shortest\/simplest path&#8217;.<\/p>\n<p>Also, just for thoughts, the &#8216;Dual Schema&#8217; is often more than just 2 views on the same thing. If you think CLR -> XML, CLR -> RDB, myXML -> yourXML, then you end up with a few combinations. The &#8216;canonical schema&#8217; could be defined in the code-first way, but that has always led to compromises for other non-OO representations. Hence the constant mapping issues. A model is needed, but getting the model accepted as part of a decent\/productive dev process is the trick.<\/p>\n<p>The impedance you talk about can refer to web services\/xsd\/messages just as much as it can mean RDB mapping. <\/p>\n<p>Also (since I&#8217;m typing), databases are, I agree, an overkill for a lot of apps, but they aren&#8217;t just used for storage &#8211; aspects like concurrency (awkward in mainstream programming) and transactions come along for the ride and make it worth the while. Also, an app that doesnt require a full RDBMS at the beginning of its life tends to convert over badly when it does need it, hence the convention of just using the &#8216;littlest RDBMS&#8217; you can find rather than changing paradigm when you get bigger.<\/p>\n<p>PS See you at TechEd Harry.<\/p>\n<p>- David<\/p>\n","parent":0},{"id":2344,"name":"Alex","url":"http:\/\/www.base4.net","date":"2006-03-29 22:28:59","content":"<p>One thing that I think is vital going forward is to provide the ability to create Schemas that reference other Schemas. This becomes particularly valuable when talking to existing Legacy databases. The process is this:<br \/>\n1) Make a schema for the legacy database<br \/>\n2) Make a new schema to support new functionality that references (1).<br \/>\nThis is the approach taken by WinFS, and indeed my own open source product Base4. <\/p>\n<p>PS: I&#8217;m not sure if I understand you correctly but by my reckoning WinFS slaves both the Database and the CLR objects to the WinFS schema, does that mean you have just one schema?<\/p>\n","parent":0}],"attachments":[],"comment_count":2,"comment_status":"closed","custom_fields":{"dasblog_entryid":["3e4f284e-9be2-491c-aee3-dd427ced2020"],"dasblog_compressedtitle":["The+Dual+Schema+Problem"],"dasblog_compressedtitleunique":["2006\/03\/28\/The+Dual+Schema+Problem"]}},"previous_url":"http:\/\/devhawk.net\/2006\/03\/24\/identity-woman\/","next_url":"http:\/\/devhawk.net\/2006\/04\/06\/rubynet-project\/"}