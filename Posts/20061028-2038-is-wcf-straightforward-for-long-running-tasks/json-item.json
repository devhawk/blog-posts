{"status":"ok","post":{"id":824,"type":"post","slug":"is-wcf-straightforward-for-long-running-tasks","url":"http:\/\/devhawk.net\/2006\/10\/28\/is-wcf-straightforward-for-long-running-tasks\/","status":"publish","title":"Is WCF &#8220;Straightforward&#8221; for Long Running Tasks?","title_plain":"Is WCF &#8220;Straightforward&#8221; for Long Running Tasks?","content":"<p>My father sent me a link to <a href=\"http:\/\/ddj.com\/dept\/webservices\/193104809\">this article on SOA scalability<\/a>. He thought it was pretty good until he got to <a href=\"http:\/\/ddj.com\/dept\/webservices\/193104809?pgno=6\">this paragraph<\/a>:<\/p>\n<blockquote><p>Long-running tasks become more complex. You cannot assume that your client can maintain a consistent connection to your web service throughout the life of a task that takes 15 minutes, much less one hour or two days. In this case, you need to implement a solution that follows a full-duplex pattern (where your client is also a service and gets notified when the task is completed) or a polling scheme (where your client checks back later to get the results). Both of these solutions require stateful services. This full-duplex pattern becomes straightforward to implement using the Windows Communications Foundation (Indigo) included with .NET 3.0.<\/p>\n<\/blockquote>\n<p>When I first saw duplex channels in WCF, I figured you can use them for long running tasks also. Turns out that of the nine <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/ms730879.aspx\">standard WCF bindings<\/a>, only four support duplex contracts. Of those four, one is designed for <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.netpeertcpbinding.aspx\">peer-to-peer scenarios<\/a> and one uses <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.netnamedpipebinding.aspx\">named pipes<\/a> so it doesn&#8217;t work across the network, so they&#8217;re obviously not usable in the article&#8217;s scenario. <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.nettcpbinding.aspx\">NetTcp<\/a> can only provide duplex contracts within the scope of a consistent connection, which the author has already ruled out as a solution. That leaves <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.wsdualhttpbinding.aspx\">wsDualHttp<\/a>, which is implemented much as the author describes, where\u00a0both client and the service are listening on the network for messages. There&#8217;s even a standard binding element &#8211; <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.channels.compositeduplexbindingelement.aspx\">Composite Duplex<\/a> &#8211; which ties two one-way messaging channels into a duplex channel.<\/p>\n<p>Alas, the wsDualHttp solution has a few flaws that render it &#8211; in my opinion at least &#8211; unusable for exactly these sorts of long running scenarios. On the client side, while you can specify the <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.channels.compositeduplexbindingelement.clientbaseaddress.aspx\">ClientBaseAddress<\/a>, you can&#8217;t specify the entire <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/system.servicemodel.description.serviceendpoint.listenuri.aspx\">ListenUri<\/a>. Instead, wsDualHttp generates a random guid and tacks it on the end of your ClientBaseAddress, effectively creating a random url every time you run the client app. So if you shut down and restart your client app, you&#8217;re now listening on a different url than the one the service is going to send messages to and the connection is broken. Oops.<\/p>\n<p>The issues don&#8217;t end there. On the <a href=\"http:\/\/windowssdk.msdn.microsoft.com\/en-us\/library\/ms731184.aspx\">service side of a duplex contract<\/a>, you get an object you can use to call back to the client via OperationContext.Current.GetCallbackChannel. This works fine, as long as you don&#8217;t have to shut down your service. There&#8217;s no way to persist the callback channel information to disk and later recreate it. So if you shut down and restart your service, there&#8217;s no way to reconnect with the client, even if they haven&#8217;t changed the url they&#8217;re listening on. Oops.<\/p>\n<p>So in other words, WCF can do long running services using the wsDualHttp binding, as long as you don&#8217;t restart the client or service during the conversation. Because that would never ever happen, right?<\/p>\n<p>This is part of the reason <a href=\"http:\/\/devhawk.net\/2006\/10\/23\/The+Other+Foundation+Technology.aspx\">why I&#8217;m sold on Service Broker<\/a>. From where I sit, it looks like WCF can&#8217;t handle long running operations <u><em>at all<\/em><\/u> &#8211; at least, not with any of the built in transports and bindings. You may be able to build something custom that would work for long running services, I&#8217;m not a deep enough expert on WCF to know. From reading what Nicholas Allen <a href=\"http:\/\/blogs.msdn.com\/drnick\/archive\/2006\/08\/29\/729208.aspx\">has to say about CompositeDuplex<\/a>, I&#8217;m fairly sure you could work around the client url issue if you built a custom binding element to set the ListenUriBaseAddress. But I have no idea how to deal with the service callback channel issue. It doesn&#8217;t appear that the<em>\u00a0<\/em>necessary plumbing is there at all to persist and rehydrate the callback channel. If you can&#8217;t do that, I don&#8217;t see how you can reliably support long running services.<\/p>\n","excerpt":"<p>My father sent me a link to this article on SOA scalability. He thought it was pretty good until he got to this paragraph: Long-running tasks become more complex. You cannot assume that your client can maintain a consistent connection to your web service throughout the life of a task that takes 15 minutes, much [&hellip;]<\/p>\n","date":"2006-10-28 20:38:30","modified":"2006-10-28 20:38:30","categories":[{"id":177,"slug":"architecture","title":"Architecture","description":"","parent":0,"post_count":296}],"tags":[{"id":313,"slug":"wcf","title":"WCF","description":"","post_count":31},{"id":290,"slug":"web-services","title":"Web Services","description":"","post_count":12}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2422,"name":"Robert W. Anderson","url":"http:\/\/et.cairene.net","date":"2006-11-01 07:45:11","content":"<p>You (or your dad? ) make a good point about WCF&#8217;s full-duplex capability.  I didn&#8217;t mean to give the impression that full-duplex patterns in WCF are perfect&#8211;just that it is easier to expose Web Service functionality from a client application using WCF.   <\/p>\n<p>It sounds like you have gone further down the WCF road than we have (currently we are architecting the next major version of our Digipede network which will include replacing our current WSE2 Web Services with WCF).  Our plan to support full-duplex is to build on top of two half-duplex channels.  Of course, that puts the burden on us to deal with restart issues, but as you pointed out, we would have that burden with full-duplex channels anyway.  <\/p>\n<p>For various reasons we haven\u2019t looked seriously at Service Broker for our product, though it looks like it handles these issues in a more straightforward manner.<\/p>\n<p>Thanks for taking the time to comment,<\/p>\n<p>Robert<\/p>\n","parent":0}],"attachments":[],"comment_count":1,"comment_status":"closed","custom_fields":{"dasblog_entryid":["cdc11975-d7a3-4114-9efb-6964486b3b46"],"dasblog_compressedtitle":["Is+WCF+QuotStraightforwardquot+For+Long+Running+Tasks"],"dasblog_compressedtitleunique":["2006\/10\/29\/Is+WCF+QuotStraightforwardquot+For+Long+Running+Tasks"]}},"previous_url":"http:\/\/devhawk.net\/2006\/10\/27\/custom-authentication-with-wcf-is-top-shelf\/","next_url":"http:\/\/devhawk.net\/2006\/11\/01\/essential-windows-workflow-foundation\/"}