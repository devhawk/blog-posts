<p>Robert Bauman left the following <a href="http://blogs.msdn.com/devhawk/archive/2005/02/24/379473.aspx#379697">comment</a> on my <a href="http://devhawk.net/MDA+And+Software+Factories++Separated+At+Birth.aspx">Separated at Birth</a> post?</p><blockquote><p>The nice thing about using a general purpose modeler is that you can house all of your requirements, use cases, etc. in the same model. Rational provides the 4+1 view, Sparx Systems Enterprise Architect provides several views out of the box that you can easily navigate around... It means that everyone is working off of the same set of rules.</p><p>As soon as you start putting those rules into Visual Studio, they change and deviate from the model. It's true that the AndroMDA does require you to remember to use certain stereotypes, but that's all part of the game anyhow. <br /><br />That's like saying, "well, the GoF patterns are nice, but then you have to remember what it means to have an Observer pattern". Furthermore, UML tools let you customize the list of stereotypes that show in the dropdown, and even the picture that should be associated with those stereotypes. Why mess with some other modeling standard when you can do it all with a proper UML tool</p></blockquote><p>The point I was making is that when you start using the class model to design something other than classes, you're using a domain specific language - even if you're using a general purpose modeling tool.Â  Take a look at this <a href="http://www.andromda.org/modeling.html">example</a> from the AndroMDA website. Their example reads:</p><blockquote><p>You tag a CustomerService class with a &lt;&lt;Service&gt;&gt; stereotype. AndroMDA sees this stereotype, looks into its internal dictionary of available code generation components (called "cartridges") and finds the EJB cartridge. In the EJB cartridge, two templates correspond to the &lt;&lt;Service&gt;&gt; stereotype: SessionBean.vsl and SessionBeanImpl.vsl. AndroMDA uses the internal representation of CustomerService loaded from the model, calls the processing engine twice, and two output files are generated: CustomerServiceBean.java and CustomerServiceBeanImpl.java. </p></blockquote><p>In this example, classes with the &lt;&lt;Service&gt;&gt; stereotype actually generate two code classes - the Bean and the BeanImpl. But if we were using the class diagram <i>as it was intended</i>, wouldn't there be a one-to-one mapping between a class in the model and a class in the code? As soon as you break that one-to-one mapping, you're no longer modeling classes. A &lt;&lt;Service&gt;&gt; is something at a higher level of abstraction than a class - otherwise it wouldn't take two classes to implement it.</p><p>BTW, I'm not saying that there is anything wrong with this approach at all! I'm just pointing out the similarities between an approach that many people are using to achieve practical results with UML today and what you can do with the modeling tools that Microsoft is building. </p><p>The key difference comes down to tools. Yes, you can use the class diagram and stereotypes to model stuff at a higher level of abstraction like Services and Entities. But putting a square peg in a round hole like that has problems. Since you're not using the tools as they were designed, you have to manually enforce rules that the tool doesn't know about. Sure, you can add some semantics via stereotypes, but you can't take anything away. How easy is it to build a valid class model that isn't a valid service model? Pretty easy. For example, do services support inheritance? Classes do. My EJB is a little rusty, but I don't think beans do. It certainly doesn't make sense for a service to inherit from an entity or vis-versa. Yet, the class modeler will happily let you do this, even though it makes no sense in the domain you're actually trying to model.</p><p>The value of domain specific languages is that have a tool that is specifically designed to model the domain you're working in. If you're designing classes, of course you'd want to use a class model. We have a <a href="http://msdn.com/library/en-us/dv_vstechart/html/clssdsgnr.asp">great one</a> coming in VS2005. But if you're designing services or entities or page flows or whatever else, why wouldn't you want a tool that's specific to the problem at hand?</p>