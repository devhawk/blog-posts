<p>I&#8217;ve been investigating the new WCF/WF integration in .NET Framework 3.5. I want to understand how the new context features work. Unfortunately, there&#8217;s not much info out there (that I could find at any rate). You&#8217;re pretty much stuck with the <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=2611a6ff-fd2d-4f5b-a672-c002f1c09ccd&DisplayLang=en" target="_blank">samples</a> and Jesus Rodriguez&#8217;s <a href="http://weblogs.asp.net/gsusx/archive/2007/06/14/orcas-durable-services.aspx" target="_blank">overview of durable services</a>. So I sat down to dig a little deeper.</p>
<blockquote><p>Note, since there are no docs on this stuff as I write this, many of the links below are <a href="http://www.aisto.com/roeder/dotnet" target="_blank">Reflector</a> code links. </p>
</blockquote>
<p>I started by lifting the <a href="http://msdn2.microsoft.com/en-us/library/bb410782(VS.90).aspx" target="_blank">DurableCalculator sample</a> contract and service implementation and dumping it into a new WCF Service Library project. I did this for two reasons. First, VS08 has added a WCF Service Host much like VS05 added the ASP.NET Development Server. Very cool. But the existing sample is still written to be hosted in IIS, so I wanted to change that. Second, and much more important, I wanted to start with a vanilla config file. I knew it wouldn&#8217;t work out of the box, but the point of this exercise was to learn how this works under the covers. </p>
<p>When you fire up the durable service with the vanilla config file, you get an error (as expected). Services marked with the DurableServiceAttribute require a binding that supports the context protocol. WsHttpBinding, the default binding when you create a new service, doesn&#8217;t. However, it&#8217;s easy to fix by switching to <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.WSHttpContextBinding" target="_blank">wsHttpContextBinding</a> instead. Via Reflector, we see that wsHttpContextBinding inherits from wsHttpBinding and <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.WSHttpContextBinding/CreateBindingElements():System.ServiceModel.Channels.BindingElementCollection" target="_blank">adds a ContextBindingElement to the binding element collection</a> created by the base class. <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.BasicHttpContextBinding" target="_blank">BasicHttpContextBinding</a> and <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.NetTcpContextBinding" target="_blank">netTcpContextBinding</a> work the same way.</p>
<p>Even after changing to wsHttpContextBinding, we&#8217;re still getting an error on service start. But it&#8217;s a new error, so we&#8217;re making progress. Now, we&#8217;re told that services marked with DurableServiceAttribute need a persistence provider to be specified. If we look in the original sample&#8217;s web.config file, we find a persistenceProvider element in the service behavior. This element references the <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.SqlPersistenceProviderFactory" target="_blank">SqlPersistenceProviderFactory</a> type. Obviously, the point here is to persist durable service instances to the database between calls, much as WF can do.</p>
<p>However, merely configuring the existing SQL persistence provider doesn&#8217;t really tell you what&#8217;s going on under the hood. Besides, often when you&#8217;re experimenting, you don&#8217;t really want to go thru the headache of setting up a SQL store for persisting instances to. Somewhere along the line, I implemented a fake persistence service for WF that stored the serialized instances in memory. So I decided to do the same for WCF durable services.</p>
<p>Building a WCF Persistence Provider requires building two classes: a factory and the provider itself. Factories inherit from <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.PersistenceProviderFactory" target="_blank">PersistenceProviderFactory</a>, which exposes only one non-<a href="http://msdn2.microsoft.com/en-us/library/system.servicemodel.channels.communicationobject.aspx" target="_blank">CommunicationObject</a> method: <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.PersistenceProviderFactory/CreateProvider(System.Guid):System.ServiceModel.Persistence.PersistenceProvider" target="_blank">CreateProvider</a>. It appears that the service host creates a single persistence provider factory and calls CreateProvider whenever it needs a persistence provider. Providers themselves inherit from <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.PersistenceProvider" target="_blank">PersistenceProvider</a>, which exposes methods to <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.PersistenceProvider/Load(System.TimeSpan):Object" target="_blank">Load</a>, <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.PersistenceProvider/Save(Object,System.TimeSpan):Object" target="_blank">Save</a> and <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.PersistenceProvider/Delete(Object,System.TimeSpan)" target="_blank">Delete</a> durable service instances. </p>
<p>My FakePersistenceProvider (and factory) are brain dead simple, though the ratio of &#8220;real&#8221; code to factory and CommunicationObject scaffolding is quite low (about 40 lines out of 258). The factory keeps a dictionary of serialized service instances, keyed by guid. When providers are created, this key guid is passed as a parameter to CreateProvider. The provider instances delegate Load, Save and Delete back to internal methods on the factory class. The methods themselves use the <a href="http://msdn2.microsoft.com/en-us/library/system.runtime.serialization.netdatacontractserializer.aspx" target="_blank">NetDataContractSerializer</a> to serialize the service instance out to a byte array and deserializing it back again. I chose NetDataContractSerializer because that&#8217;s what the SQL persistence provider uses under the hood. </p>
<p>PersistenceProvider supports async versions of Load, Save and Delete but I didn&#8217;t implement them. Also, there&#8217;s a <a href="code://System.WorkflowServices:3.5.0.0:31bf3856ad364e35/System.ServiceModel.Persistence.LockingPersistenceProvider" target="_blank">LockingPersistenceProvider</a> abstract class which adds (you guessed it) instance locking semantics. However, my fake provider doesn&#8217;t span machines, much less require locking semantics so I skipped it.</p>
<p>So it looks like DurableServiceAttribute, context-supporting bindings and persistence providers are all inter-related. Certainly, you can&#8217;t use the attribute with out the binding and persistence provider. As I continue to dig, I&#8217;m want to see how context inter-relates with WF as well as it&#8217;s possible usage outside of DurableServiceAttribute based scenarios. </p>
<p>If you&#8217;re interested in the code, I&#8217;ve <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/Public/Code/FakePersistenceProvider.zip" target="_blank">stuck it up on my SkyDrive</a>. In addition to the FakePersistenceProvider implementation and the simple Durable Calculator service, it includes a simple client to test the service and persistence provider. The WCF Service Host includes a test client, but it doesn&#8217;t appear to support the context protocol, so I had to build a simple test app instead. Enjoy.</p>
