<p align="left">I&#8217;ve been following the ongoing discussion about typing systems in programming languages between <a href="http://blogs.tedneward.com/">Ted Neward</a> and <a href="http://relevancellc.com/blogs/index.php">Stu Halloway</a> with great interest. Given that I believe <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a>, I&#8217;m eager to mine knowledge from successful tools to apply at higher levels of abstraction. And as an employee of a language vendor, I&#8217;m also very interested in what Stu describes as vendor-oriented vs. developer-oriented languages.</p>
<blockquote><p align="left">So why has the static/dynamic debate staggered on for so long? I think we could get closer to some answers with better choice of terms. &#8220;Static&#8221; vs. &#8220;dynamic&#8221; is highly misleading. I propose we use a new set of names: vendor-oriented vs. developer-oriented programming&#8230;So who do you trust most: vendors or developers?<br>[<a href="http://www.relevancellc.com/blogs/?p=65">What&#8217;s new in C#, or who do you trust most?</a>]</p>
<p align="left">With a vendor-oriented language like C#, core abstractions are much more firmly controlled by the language vendor. Conversely, developer-oriented languages like Python leave more of these choices to the developer (although they tend to provide reasonable defaults)&#8230;Competency and trustworthiness are sprinkled all over our industry, both among language vendors and application developers. My concern is who controls the abstractions. Developer-oriented languages (like Scheme) give a lot of control (and responsibility) to developers. Vendor-oriented languages (like Java) leave that control more firmly in the hands of the vendor.<br>[<a title="Permanent Link to Developer oriented languages" href="http://www.relevancellc.com/blogs/?p=69" rel="bookmark">Developer oriented languages</a>]</p>
</blockquote>
<p align="left">Personally, I think calling them static and dynamic language is far less misleading than vendor and developer oriented languages. Further, I think Stu is making somewhat absurd statements to garner attention. However, I believe he&#8217;s certainly onto something with regard to the language abstractions. The abstractions I and my team care about on our project are almost assuredly going to be different from the abstractions you and your team care about on your project. Having a programming environment that enables the abstractions you need on a given project is very very important. </p>
<p align="left">The problem with Stu&#8217;s argument is that he&#8217;s focused on low level language abstractions. Abstractions like &#8220;inheritance, encapsulation, delegation, how symbols are interpreted, etc.&#8221; Are you kidding me? Projects don&#8217;t fail because developers can&#8217;t change the language&#8217;s concept of inheritance. They fail because the gap between the abstractions provided by the language and the abstractions needed by the solution are enormous. Modern software development is like building skyscrapers with Lego blocks. Furthermore, projects fail because business and IT don&#8217;t speak the same language. Business people don&#8217;t care about concepts like encapsulation and symbol interpretation. They care about concepts like ROI, business plans and regulatory compliance. Geeks may not feel comfortable talking about those concepts, but they are what keep a business in business </p>
<p align="left">Imagine your CFO listening to Stu and Ted discuss these language abstractions. They would be thinking &#8220;What the hell are they talking about?&#8221; To Ted&#8217;s credit, he bluntly states that he <a href="http://blogs.tedneward.com/PermaLink,guid,eb41bdd9-decc-44ba-916c-9346a959fff6.aspx">doesn&#8217;t trust developers</a> which would likely put him in well with the CFO:</p>
<blockquote><p align="left">I see the same concern every time a developer starts talking about doing bytecode manipulation at load-time&#8211;just because you <em>can</em> doesn&#8217;t mean you <em>should</em>. In this respect, I trust the guys who&#8217;ve been down this road before much more so than developers who are just coming to this and are starting to flex their new-found freedom and will (undoubtedly) start building systems that exercise this power. <br>[<a href="http://blogs.tedneward.com/PermaLink,guid,eb41bdd9-decc-44ba-916c-9346a959fff6.aspx">Dynamic languages, type systems and self-modifying systems</a>]</p>
</blockquote>
<p align="left">I wouldn&#8217;t go so far as to say I don&#8217;t trust developers, but Ted&#8217;s point about <i>can</i> and <i>should</i> is spot on. I&#8217;m sure there are scenarios where bytecode manipulation is critical to the success of the project. Hell, in the project I&#8217;m currently heads down on (hence the lack o&#8217; posts in the past two weeks) I&#8217;m using much more reflection and late-binding than I ever have before. Not because I can &#8211; frankly, I like static typing &#8211; but because that&#8217;s the best way to solve the problem at hand. </p>
<p align="left">It&#8217;s important to keep the big picture in mind when discussing minutia such as a given programming language&#8217;s core abstractions. IT exists to serve the business, not the other way around.</p>
