{"status":"ok","post":{"id":1252,"type":"post","slug":"__clrtype__-metaclasses-customizing-the-type-name","url":"http:\/\/devhawk.net\/2009\/04\/22\/__clrtype__-metaclasses-customizing-the-type-name\/","status":"publish","title":"__clrtype__ Metaclasses: Customizing the Type Name","title_plain":"__clrtype__ Metaclasses: Customizing the Type Name","content":"<p>Now that we know a <a href=\"http:\/\/devhawk.net\/2009\/04\/21\/clrtype+Metaclasses+IronPython+Classes+Under+The+Hood.aspx\">little about how IronPython uses CLR types under the hood<\/a>, let\u2019s start customizing those types. In a nutshell, __clrtype__ metaclasses are metaclasses that implement a function named __clrtype__ that takes the Python class definition as a parameter and returns a <a href=\"http:\/\/msdn.microsoft.com\/library\/system.type.aspx\">System.Type<\/a>. IronPython will then use the returned Type\u00a0 as the underlying CLR type whenever you create an instance of the Python class. <\/p>\n<p>Technically, you could emit whatever custom CLR Type you want to in the __clrtype__, but typically you\u2019ll want to emit a class that both implements whatever static CLR metadata you need as well as the dynamic binding infrastructure that IronPython expects. The easiest way to do this is to ask IronPython emit a type that handles all the dynamic typing and then inherit from that type to add the custom CLR metadata you want.<\/p>\n<p>Let\u2019s start simple and hello-worldly by just customizing the name of the generated CLR type that\u2019s associated with the Python class. There\u2019s a fair amount of boilerplate code that is needed even for this simple scenario, and I can build on that as we add features that actually do stuff. If you want to follow along at home, you\u2019ll need <a href=\"http:\/\/ironpython.codeplex.com\/Release\/ProjectReleases.aspx?ReleaseId=22982\">IronPython 2.6 Alpha 1<\/a> (or later) and you can get this code <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/browse.aspx\/DevHawk%20Content\/IronPython%20Stuff\/%7C_%7C_clrtype%7C_%7C_\">from my SkyDrive<\/a>. <\/p>\n<pre class=\"brush: python\">\nclass ClrTypeMetaclass(type):\n  def __clrtype__(cls):\n    baseType = super(ClrTypeMetaclass, cls).__clrtype__()\n    typename = cls._clrnamespace + \".\" + cls.__name__ \n                 if hasattr(cls, \"_clrnamespace\") \n                 else cls.__name__\n                 \n    typegen = Snippets.Shared.DefineType(typename, baseType, True, False)\n    typebld = typegen.TypeBuilder\n\n    for ctor in baseType.GetConstructors(): \n      ctorparams = ctor.GetParameters()\n      ctorbld = typebld.DefineConstructor(\n                  ctor.Attributes,\n                  ctor.CallingConvention,\n                  tuple([p.ParameterType for p in ctorparams]))\n      ilgen = ctorbld.GetILGenerator()\n      ilgen.Emit(OpCodes.Ldarg, 0)\n      for index in range(len(ctorparams)):\n        ilgen.Emit(OpCodes.Ldarg, index + 1)\n      ilgen.Emit(OpCodes.Call, ctor)\n      ilgen.Emit(OpCodes.Ret)\n\n    return typebld.CreateType()\n<\/pre>\n<p>Like all Python metaclasses, ClrTypeMetaclass inherits from the <a href=\"http:\/\/docs.python.org\/library\/stdtypes.html#type-objects\">built-in Python type object<\/a>. If I wanted to <a href=\"http:\/\/docs.python.org\/reference\/datamodel.html#customizing-class-creation\">customize the Python class<\/a> as well, I could implement __new__ on ClrTypeMetaclass , but I only care about customizing the CLR type so it only implements __clrtype__. If you want to know more about what you can do with Python metaclasses, check out Michael Foord\u2019s <a href=\"http:\/\/www.voidspace.org.uk\/python\/articles\/five-minutes.shtml\">Metaclasses in Five Minutes<\/a>.<\/p>\n<p>First off, I want to get IronPython to generate the base class that will implement all the typical Pythonic stuff like name resolution and dynamic method dispatch. To do that, I call __clrtype__ on the <a href=\"http:\/\/docs.python.org\/library\/functions.html#super\">supertype<\/a> of ClrTypeMetaclass \u2013 aka the built-in type object. That function returns the System.Type that IronPython would have used as the underlying CLR type for the Python class if we weren\u2019t using __clrtype__ metaclasses.<\/p>\n<p>Once I have the base class, next I figure out what the name of the generated CLR type will be. This is pretty simple, I just use the name of the Python class. To make this logic a little more interesting, I added support for a custom namespace. If the Python class has a _clrnamespace field, I append that as the custom namespace for the name. I should probably be using a double underscore \u2013 i.e. __clrnamespace \u2013 but I didn\u2019t want to wrestle with <a href=\"http:\/\/docs.python.org\/tutorial\/classes.html#private-variables\">name mangling<\/a> in this prototype code.<\/p>\n<p>Now that I have a name and a base class, I can generate the class I\u2019m going to use. I\u2019m using the DefineType method in <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/49291#760277\">Microsoft.Scripting.Generation.Snippets<\/a> DLR class for three reasons. First, there\u2019s a <a href=\"http:\/\/www.mail-archive.com\/users@lists.ironpython.com\/msg08702.html\">CLR bug<\/a> that doesn\u2019t let you create a dynamic assembly from a dynamic method. Second, reusing the snippets assembly avoids the overhead of generating a new assembly. Finally, the types in Snippets.Shared get saved to disk if you run with the -X:SaveAssemblies flag, so you can inspect custom CLR type that gets generated. The DefineType function takes four parameters, the type name, the base class, a preserve name flag and a generate debug symbols flag. If you pass false for preserve name, you get a name like foobar$1 instead of just foobar. As for debug symbols, since I don\u2019t have any source code that I\u2019m generating IL from, emitting debug symbols doesn\u2019t make a lot of sense. DefineType returns a <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/49291#760661\">TypeGen<\/a>, but I only need the <a href=\"http:\/\/msdn.microsoft.com\/library\/system.reflection.emit.typebuilder.aspx\">TypeBuilder<\/a>.<\/p>\n<p>The last thing I need to do is implement the custom CLR type constructor(s). IronPython CLR types will always have at least one parameter \u2013 the <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/49291#384570\">PythonType<\/a> (PythonType == IronPython\u2019s implementation of Python\u2019s built-in type object) that\u2019s used for dynamic name resolution. I don\u2019t want to add any custom functionality in my custom CLR type constructors, so I simply iterate thru the list of constructors on the base class and generate a constructor on the custom CLR type with a matching parameter list and that calls the base class constructor.\u00a0 <\/p>\n<p>Generating the IL to emit the constructor and the base class is straightforward, if tedious. I define the constructor with the same attributes, calling convention and parameters as the base class constructor. Then I emit IL to load the local instance (i.e. ldarg 0) and all the parameters onto the stack, call the base constructor and finally return. Once all the constructors are defined, I can create the type and return.<\/p>\n<p>Using the ClrTypeMetaclass is very easy &#8211; simply specify the __metaclass__ field in a class. If you want to customize the namespace, specify the _clrnamespace field as well. Here\u2019s an example:<\/p>\n<pre class=\"brush: python\">\nclass Product(object):\n  __metaclass__ = ClrTypeMetaclass\n  _clrnamespace = \"DevHawk.IronPython.ClrTypeSeries\"   \n  \n  def __init__(self, name, cost, quantity):\n    self.name = name\n    self.cost = cost\n    self.quantity = quantity\n  \n  def calc_total(self):\n    return self.cost * self.quantity\n<\/pre>\n<p>You can verify this code has custom CLR metadata by calling GetType on a Product instance and inspecting the result via standard reflection techniques.<\/p>\n<\/p>\n<pre class=\"brush: text\">\n&gt;&gt;&gt; m = Product('Crunchy Frog', 10, 20)\n&gt;&gt;&gt; m.GetType().Name\n'Product'\n&gt;&gt;&gt; m.GetType().FullName\n'DevHawk.IronPython.ClrTypeSeries.Product'\n<\/pre>\n<p>Great, so now I have a custom CLR type for my Python class. Unfortunately, at this point it\u2019s pretty useless. Next, I\u2019m going to add instance fields to the CLR type.<\/p>\n","excerpt":"<p>Now that we know a little about how IronPython uses CLR types under the hood, let\u2019s start customizing those types. In a nutshell, __clrtype__ metaclasses are metaclasses that implement a function named __clrtype__ that takes the Python class definition as a parameter and returns a System.Type. IronPython will then use the returned Type\u00a0 as the [&hellip;]<\/p>\n","date":"2009-04-22 12:51:03","modified":"2009-04-22 12:51:03","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":281,"slug":"__clrtype__","title":"__clrtype__","description":"","post_count":9}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["ef846228-b0b7-4130-aac8-54dd631f4e89"],"dasblog_compressedtitle":["clrtype+Metaclasses+Customizing+The+Type+Name"],"dasblog_compressedtitleunique":["2009\/04\/22\/clrtype+Metaclasses+Customizing+The+Type+Name"]}},"previous_url":"http:\/\/devhawk.net\/2009\/04\/21\/__clrtype__-metaclasses-ironpython-classes-under-the-hood\/","next_url":"http:\/\/devhawk.net\/2009\/04\/23\/__clrtype__-metaclasses-adding-clr-fields\/"}