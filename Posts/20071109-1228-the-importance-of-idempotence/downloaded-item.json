{"status":"ok","post":{"id":1050,"type":"post","slug":"the-importance-of-idempotence","url":"http:\/\/devhawk.net\/2007\/11\/09\/the-importance-of-idempotence\/","status":"publish","title":"The Importance of Idempotence","title_plain":"The Importance of Idempotence","content":"<p>Every organization has some operations or processes that have to happen Exactly Once. Your employer needs to make sure they issue your paycheck exactly once. Your bank needs to make sure that paycheck is deposited in your account exactly once. Exactly Once isn&#8217;t something that just &#8220;traditional&#8221; enterprises like banks care about. Google needs to make sure your AdSense check is issued exactly once. Amazon needs to make sure your credit card is charged exactly once. Especially when there&#8217;s money involved, the company wants to make sure it gets handled correctly &#8211; Exactly Once.<\/p>\n<p>In application (aka siloed) development, transactions are often used to ensure stuff happens Exactly Once, to good effect. But how do we guarantee Exactly Once now that we&#8217;re connecting systems together? Given how well transactions work inside applications, it&#8217;s not surprising that early attempts to guarantee Exactly Once between systems relied on distributed transactions, this time to not-so-good effect. Pat Helland summarized the problems with distributed transactions this way:<\/p>\n<blockquote><p>&#8220;The two-phase commit protocol will ensure perfect consistency given infinite time.\u00a0 I say that because it will wait and wait and wait until the transaction is resolved and then provide perfect consistency.\u00a0\u00a0 Of course, while partitioned and waiting, arbitrary swaths of the application&#8217;s database may be locked up rendering the application unusable.\u00a0 For this reason, I&#8217;ve frequently referred to the two phase commit protocol as the &#8220;Anti-Availability Protocol&#8221;. &#8220;<br \/>Pat Helland, <a href=\"http:\/\/blogs.msdn.com\/pathelland\/archive\/2007\/05\/20\/soa-and-newton-s-universe.aspx\" target=\"_blank\">SOA and Newton&#8217;s Universe<\/a><\/p>\n<\/blockquote>\n<p>So now we&#8217;re faced with a dilemma. Transactions are, for all practical purposes, unusable to ensure Exactly Once processing between connected systems. And yet, the business requirement to ensure Exactly Once hasn&#8217;t gone away. We need another way.<\/p>\n<p>The first <a href=\"http:\/\/en.wikipedia.org\/wiki\/Fallacies_of_Distributed_Computing\" target=\"_blank\">fallacy of distributed computing<\/a> is that the network is reliable. It&#8217;s usually works, but usually isn&#8217;t a guarantee. If I send a message to a remote system but don&#8217;t get an acknowledgement, which got lost: the original message or the ack? There&#8217;s no way to know, so I have to send the message again. But if I send it again and it&#8217;s the ack that got lost, then the target system will receive the message multiple times. <\/p>\n<p>Since the network is not reliable, there&#8217;s no way to guarantee that a message will be delivered exactly once. The best we can go is ensure a message will be delivered at least once. However, that implies the target system will receive some messages multiple times. If we need to ensure Exactly Once, we need to make sure the target system won&#8217;t duplicate the work if it receives duplicate messages. In other words, we need the target system to be <a href=\"http:\/\/en.wikipedia.org\/wiki\/Idempotence\" target=\"_blank\">idempotent<\/a>.\u00a0 <\/p>\n<blockquote><p>&#8220;In <a href=\"http:\/\/en.wikipedia.org\/wiki\/Computer_science\">computer science<\/a>, the term idempotent is used to describe <a href=\"http:\/\/en.wikipedia.org\/wiki\/Method_%28computer_science%29\">method<\/a> or <a href=\"http:\/\/en.wikipedia.org\/wiki\/Subroutine\">subroutine<\/a> calls which can safely be called multiple times, as invoking the procedure a single time or multiple times results in the system maintaining the same state i.e. after the method call all variables have the same value as they did before.<\/p>\n<\/blockquote>\n<blockquote><p>Example: Looking up some customer&#8217;s name and address are typically idempotent, since the system will not change state based on this. However, placing an order for a car for the customer is not, since running the method\/call several times will lead to several orders being placed, and therefore the state of the system being changed to reflect this.&#8221;<br \/>Wikipedia, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Idempotence#Computer_Science\" target=\"_blank\">Idempotence (Computer Science)<\/a><\/p>\n<\/blockquote>\n<p>Or more succinctly:<\/p>\n<blockquote><p>&#8220;Idempotent Means It\u2019s OK to Arrive Multiple Times&#8221; <br \/>Pat Helland (again)<\/p>\n<\/blockquote>\n<p>I can&#8217;t overstate the importance of designing your cross-system communication to be idempotent. If you care about ensuring Exactly Once, each step of your process has to be either transactional or idempotent, or you&#8217;ll be screwed. It&#8217;s interesting to note that you have to be transactional <em>*OR*<\/em> idempotent, but not both. You can chain together multiple steps in long business process, across multiple disparate systems, but as long as each step is either transactional or idempotent, you can guarantee Exactly Once across the entire process. In other words:<\/p>\n<blockquote><p>Transactional\/Exactly Once == Idempotent\/At Least Once<\/p>\n<\/blockquote>\n<p>This implies that you can substitute an idempotent operation for a transactional operation, and still ensure Exactly Once. <\/p>\n<p>Let&#8217;s look at an example. Typically you ensure Exactly Once processing with MSMQ by receiving messages within the scope of a transaction along with whatever other work you&#8217;re doing. But what if you can&#8217;t use a transactional receive, say because it&#8217;s a remote queue? What would an idempotent equivalent for transactional receive look like? <\/p>\n<p>How about:<\/p>\n<ol>\n<li><a href=\"http:\/\/msdn2.microsoft.com\/library\/system.messaging.messagequeue.peek\" target=\"_blank\">Peek<\/a> a message from the remote queue<\/li>\n<li>Insert the message into the target system database, using the <a href=\"http:\/\/msdn2.microsoft.com\/en-us\/library\/system.messaging.message.id.aspx\" target=\"_blank\">unique MSMQ Message ID<\/a> as the primary key<\/li>\n<li><a href=\"http:\/\/msdn2.microsoft.com\/library\/system.messaging.messagequeue.receivebyid.aspx\" target=\"_blank\">Remove the message<\/a> from the queue by ID<\/li>\n<\/ol>\n<p>Each of those steps is idempotent. Peek is a read, which is naturally idempotent. Inserting the message into the database is idempotent, since we use the message ID as the primary key. As long as that ID is unique, we can never insert it into the database more than once. Finally, removing a message based on it&#8217;s unique ID is also naturally idempotent. Once the message is in the target system database, we can use traditional transactions to ensure it gets processed Exactly Once. <\/p>\n<p>So we took a single transactional operation and turned it into a series of idempotent steps. Both ensure each message is processed Exactly Once. Given the choice, I&#8217;d rather write the transactional operation &#8211; it&#8217;s much less code since we&#8217;re we can use existing infrastructure &#8211; aka the distributed transaction coordinator. But if the transactional infrastructure isn&#8217;t available, I&#8217;d rather write multiple idempotent steps and ensure Exactly Once rather than risk losing or duplicating messages.<\/p>\n<p>I&#8217;ve got more on this topic, but in the meantime think about this: How do you think durable messaging infrastructure like MSMQ ensures exactly once delivery? You can use that pattern, even if you&#8217;re not using durable messaging infrastructure. <\/p>\n","excerpt":"<p>Every organization has some operations or processes that have to happen Exactly Once. Your employer needs to make sure they issue your paycheck exactly once. Your bank needs to make sure that paycheck is deposited in your account exactly once. Exactly Once isn&#8217;t something that just &#8220;traditional&#8221; enterprises like banks care about. Google needs to [&hellip;]<\/p>\n","date":"2007-11-09 12:28:48","modified":"2007-11-09 12:28:48","categories":[{"id":177,"slug":"architecture","title":"Architecture","description":"","parent":0,"post_count":296}],"tags":[{"id":201,"slug":"durable-messaging","title":"Durable Messaging","description":"","post_count":5},{"id":210,"slug":"idempotence","title":"Idempotence","description":"","post_count":3},{"id":183,"slug":"soa","title":"SOA","description":"","post_count":94}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["e0aad463-d046-4638-8877-3960e099ee98"],"dasblog_compressedtitle":["The+Importance+Of+Idempotence"],"dasblog_compressedtitleunique":["2007\/11\/09\/The+Importance+Of+Idempotence"]}},"previous_url":"http:\/\/devhawk.net\/2007\/11\/09\/morning-coffee-122\/","next_url":"http:\/\/devhawk.net\/2007\/11\/16\/the-hawk-flies-again\/"}