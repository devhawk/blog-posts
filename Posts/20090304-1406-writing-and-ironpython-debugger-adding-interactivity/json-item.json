{"status":"ok","post":{"id":1223,"type":"post","slug":"writing-and-ironpython-debugger-adding-interactivity","url":"http:\/\/devhawk.net\/2009\/03\/04\/writing-and-ironpython-debugger-adding-interactivity\/","status":"publish","title":"Writing and IronPython Debugger: Adding Interactivity","title_plain":"Writing and IronPython Debugger: Adding Interactivity","content":"<p>Now that ipydbg can <a href=\"http:\/\/devhawk.net\/2009\/03\/02\/Writing+An+IronPython+Debugger+Setting+A+Breakpoint.aspx\">set a breakpoint<\/a>, it\u2019s time to add some interactivity to the app. MDbg supports <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms229861.aspx\">dozens of commands<\/a> and currently ipydbg supports none. I\u2019d love for ipydbg to support a wide range of commands like MDbg does, but for now let\u2019s keep it simple and start with two: Continue and Quit. These aren\u2019t very interesting as commands go, but that lets me focus this blog post on adding basic interactivity and future posts on specific commands. <\/p>\n<p>First off, we have to understand how the CorDebug managed API supports interactivity. <a href=\"http:\/\/devhawk.net\/2009\/02\/28\/Writing+An+IronPython+Debugger+Hello+Debugger.aspx\">As we\u2019ve seen<\/a>, callbacks into the debugger are surfaced as managed events. If we look at the <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/blob\/5858695ff85ed4740ad06466d4f54394e7f00f9b\/CorDebug\/CorDebug\/Debugger.cs#L524\">base class<\/a> for all the debugger event arguments, we see that it exposes a <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/blob\/5858695ff85ed4740ad06466d4f54394e7f00f9b\/CorDebug\/CorDebug\/Debugger.cs#L561\">Continue property<\/a>. If you want the debugger to automatically continue after the event handler finishes running, you set the Continue property to true (which is the default). If you want the debugger to stay paused while you provide the developer a chance to poke around, you set Continue to false. In that case, the debugger stays paused until call process.Continue explicitly.<\/p>\n<p>Once we set the Continue property to false, we need a mechanism to signal the main thread of execution that it\u2019s time to wake up and ask the user what they want to do next. Of course, that\u2019s what <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.waithandle.aspx\">WaitHandle<\/a> and it\u2019s descendents are for. In fact, <a href=\"http:\/\/devhawk.net\/2009\/02\/28\/Writing+An+IronPython+Debugger+Hello+Debugger.aspx\">we\u2019re already using<\/a> an AutoResetEvent in OnProcessExit to signal that the debugged app has exited so we should exit the debugger. However, now we have two different signals that we want to send: exit the debugger or enter the input loop. I decided to differentiate by using two separate AutoResetEvents:<\/p>\n<pre class=\"brush: python\">\nterminate_event = AutoResetEvent(False)  \nbreak_event = AutoResetEvent(False)  \n\ndef OnProcessExit(s,e):  \n  print \"OnProcessExit\"  \n  terminate_event.Set()  \n\ndef OnBreakpoint(s,e):  \n  print \"OnBreakpoint\", get_location(  \n    symbol_readers[e.Thread.ActiveFrame.Function.Module], e.Thread)  \n  e.Continue = False  \n  break_event.Set()  \n\n#code to create debugger and process omitted for clarity\n\nhandles = Array.CreateInstance(WaitHandle, 2)  \nhandles[0] = terminate_event  \nhandles[1] = break_event  \n\nwhile True:  \n  process.Continue(False)  \n\n  i = WaitHandle.WaitAny(handles)  \n  if i == 0:  \n    break  \n\n  input()\n<\/pre>\n<p>Instead of a single call to process.Continue I had before, I\u2019ve created an infinite \u201cwhile True\u201d loop that calls Continue, waits for one of the events to signal, then either exits the loop of enters the input loop (via the input function). Since there are two AutoResetEvents, I need to use the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/tdykks7z.aspx\">WaitAny method<\/a> to wait for one of them to signal. WaitAny takes an array, which is kind of clunky to use from IronPython since the array has to be strongly typed. It would be much more pythonic if I could call WaitHandle.WaitAny([terminate_event, break_event]). WaitAny then returns an index into the array indicating which one received the signal. If it was the terminate_event that signaled, I exit the loop (and the application). Otherwise, I enter the input loop. Notice, by the way, in OnBreakpoint that I\u2019m both setting Continue to false and signaling the break_event. <\/p>\n<p>The \u201cinput loop\u201d needs to be a loop because the user may want to type in multiple commands before letting the debugged app continue to execute. This means that the input function is implemented as another \u201cwhile True\u201d loop. When the user does chooses a command that implies the process should continue, I simply exit out of the input function and the outer \u201cwhile True\u201d loop above executes the continue and waits for a signal. <\/p>\n<p>Here\u2019s what the input function looks like right now with our two basic commands:<\/p>\n<pre class=\"brush: python\">\ndef input():     \n  while True:     \n    Console.Write(\"\u00bb \")     \n    k = Console.ReadKey()     \n     \n    if k.Key == ConsoleKey.Spacebar:     \n      Console.WriteLine(\"nContinuing\")     \n      return  \n    elif k.Key == ConsoleKey.Q:     \n      Console.WriteLine(\"nQuitting\")     \n      process.Stop(0)     \n      process.Terminate(255)     \n      return\n    else:     \n      Console.WriteLine(\"n Please enter a valid command\")\n<\/pre>\n<p>I\u2019ve mapped \u201cq\u201d to quit the debugger and spacebar to continue. Since I\u2019m using Console ReadKey, you only have to type the key in question \u2013 no return needed. For continue, we don\u2019t do anything but exit the input loop by returning. Continue gets called as part of the other loop and since we haven\u2019t\/can\u2019t add additional breakpoints the debugged app will run until it ends. For quit, I call the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms230796.aspx\">Terminate method<\/a> on process, hard coding the return value to 255. However, Terminate implicitly continues the debugged process. Since you can\u2019t continue a running process, the call to Continue in the outer loop throws an exception. I avoid this exception by adding the call to Stop before Terminate. As per the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms232533.aspx\">Stop docs<\/a>, the debugger maintains a \u201cstop counter\u201d and only resumes the debugged process when the counter reaches zero.\u00a0 Calling Stop increases the stop counter by one, calling Terminate decreases it by one, then the outer loop Continue\u00a0 call decreases it to zero and the process continues, terminates and fires the OnProcessExit event handler as usual.<\/p>\n<p>Now that we have a basic interactive loop, I\u2019ll be able to add more interesting commands. I\u2019m guessing at some point, I\u2019ll need to refactor input a bit \u2013 I\u2019m guessing a huge if\/elif\/else statement is going to get ugly fast, but I\u2019ll worry about that when it gets out of hand. As usual, the <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/tree\/112c3acdcf726c3ad89ce2def8258ecc2fb55513\">latest ipydbg source<\/a> is up on GitHub.<\/p>\n","excerpt":"<p>Now that ipydbg can set a breakpoint, it\u2019s time to add some interactivity to the app. MDbg supports dozens of commands and currently ipydbg supports none. I\u2019d love for ipydbg to support a wide range of commands like MDbg does, but for now let\u2019s keep it simple and start with two: Continue and Quit. These [&hellip;]<\/p>\n","date":"2009-03-04 14:06:27","modified":"2009-03-04 14:06:27","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["69b55d54-3aed-4ec4-bb36-09eb7e9ec02d"],"dasblog_compressedtitle":["Writing+And+IronPython+Debugger+Adding+Interactivity"],"dasblog_compressedtitleunique":["2009\/03\/04\/Writing+And+IronPython+Debugger+Adding+Interactivity"]}},"previous_url":"http:\/\/devhawk.net\/2009\/03\/02\/writing-an-ironpython-debugger-setting-a-breakpoint\/","next_url":"http:\/\/devhawk.net\/2009\/03\/09\/writing-an-ironpython-debugger-dynamic-stack-trace\/"}