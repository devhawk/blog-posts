<p>I haven&#8217;t seen much in the way of response to my <a href="http://devhawk.net/2006/01/03/HiFi+Models.aspx">Hi-Fi Models</a> post, but I did come across this <a href="http://msdn.microsoft.com/netframework/default.aspx?pull=/library/en-us/dndotnet/html/linqcomparisons.asp">great article</a> by <a href="http://blogs.tedneward.com/">Ted Neward</a> on the history of the tumultuous marriage of objects and relational databases, primarily in the context of <a href="http://msdn.microsoft.com/netframework/future/linq/default.aspx">LINQ</a>. In the context of <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a>, the following passage from the summary was the most interesting:</p>
<blockquote><p>While Project LINQ doesn&#8217;t purport to be the &#8220;final answer&#8221; to all of the world&#8217;s object-relational mismatch problems, it does represent a significant shift in direction to solving the problem; instead of taking an approach that centers around code generation, or automated mapping based around metadata and type inference, both of which are exercises in slaving the relational model to an object-oriented one, Project LINQ instead chooses to elevate relations and queries as a first-class concept within language semantics and library-based extensions.<br>[<a href="http://msdn.microsoft.com/netframework/default.aspx?pull=/library/en-us/dndotnet/html/linqcomparisons.asp">Comparing LINQ and Its Contemporaries</a> - <a href="http://blogs.tedneward.com/">Ted Neward</a>]</p>
</blockquote>
<p>When Ted says relations and queries are elevated to &#8220;first class concepts&#8221; within the language, it makes me think of <a href="http://blogs.msdn.com/stuart_kent/">Stuart&#8217;s</a><a href="http://blogs.msdn.com/stuart_kent/archive/2005/12/22/506687.aspx">comment</a> about language fidelity. I&#8217;m not sure I would say C# 3.0 is at a higher level of abstraction than 2.0, but I would say that the inclusion of these new abstractions does improve the language&#8217;s fidelity. This fidelity improvement does come at the cost of complexity (<a href="http://en.wikipedia.org/wiki/TANSTAAFL">TANSTAAFL</a>) but compared to the current alternatives, I&#8217;m willing to pay that price.</p>
<p>The problem with increasing the language fidelity like this is dealing with the outdated code it leaves behind. You see this today with the addition of generics in the 2.0 CLR. How many hand-coded or <a href="http://www.sellsbrothers.com/tools/#collectionGen">generated</a> strongly typed collections are floating around out there from the 1.x days? Lots. (As if 1.x was so long ago!) How much database access code is floating around out there today? An astronomical amount. Every app that touches a database or processes XML will be outdated with the arrival of C# 3.0 and VB 9.0. But the price of converting this outdated code to use the new abstractions probably won&#8217;t be worth the time or risk. That means you&#8217;re left with maintaining the outdated code while also writing any new functionality with the new language features. </p>
<p>I wonder how DSLs will be impacted by this evolving language fidelity issue? On the one hand, the nature of DSLs is that they have much narrower usage (i.e. one domain) than something like generics or LINQ. On the other hand, I expect DSLs to evolve faster than general mainstream languages like C# can. So I&#8217;m thinking the impact will be about the same. </p>
