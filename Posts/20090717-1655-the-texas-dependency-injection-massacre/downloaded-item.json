{"status":"ok","post":{"id":1274,"type":"post","slug":"the-texas-dependency-injection-massacre","url":"http:\/\/devhawk.net\/2009\/07\/17\/the-texas-dependency-injection-massacre\/","status":"publish","title":"The Texas Dependency Injection Massacre","title_plain":"The Texas Dependency Injection Massacre","content":"<p>Since I think I\u2019ve beaten the \u201cI think what most people call architecture is really engineering\u201d meme to death, let\u2019s move on to something else. Eric Smith of <a href=\"http:\/\/thelimberlambda.com\/\">The Limber Lambda<\/a> blog (love that name!) <a href=\"http:\/\/www.lyricsdepot.com\/david-lee-roth\/experience.html\">commented<\/a>:<\/p>\n<blockquote><p>I&#8217;m a little concerned with the intimation that use of interfaces, respect for visibility of type members and use of dependency injection equates to &#8220;over-engineering&#8221;. As with everything, it depends on what you&#8217;re trying to achieve, and generalisations in this regard, especially when junior people who may not understand what&#8217;s at stake are reading, can be damaging.<\/p>\n<p>I find it an uphill battle to engender a constructive mindset in developers who have established bad habits and whose pride lies in the way of addressing those habits.<\/p>\n<p>Anti-&#8221;process&#8221; talk by Joel Spolsky and the &#8220;pragmatism brigade&#8221; makes it harder. A while ago I had a new developer refuse to write unit tests despite it being an established practice in our team because &#8220;&#8230; Jeff and Joel said they were bad in the StackOverflow podcast &#8230;&#8221;. Yikes.<\/p>\n<\/blockquote>\n<p>Let me be very clear. I <em>never <\/em>suggested that techniques such as interfaces and dependency injection are over engineering. These are good engineering practices, and every software engineer should understand them. And if Joel and Jeff really said unit tests were bad, well that would be about the dumbest thing I\u2019d have every heard either of those two say. Yikes indeed.<\/p>\n<p>But as Eric writes, \u201cit depends on what you&#8217;re trying to achieve\u201d. Engineering techniques like dependency injection, polymorphism, encapsulation are tools, and there are many good reasons to use them. But like many tools, they can also be used <a href=\"http:\/\/en.wikipedia.org\/wiki\/The_Texas_Chain_Saw_Massacre\">for evil<\/a>.<\/p>\n<p>In other words, the tools themselves are always innocent \u2013 you have to look at how and why they are being used by the people who are using them.<\/p>\n<p>Let\u2019s take <a href=\"http:\/\/en.wikipedia.org\/wiki\/Dependency_injection\">dependency injection<\/a> as an example. Externalizing a software component\u2019s dependencies enables you to test it isolation from the rest of your system. For example, it\u2019s very common to inject a dependency that writes to a durable store, such as a logger or a data access component. In your unit tests, you inject a mock durable store instead of the real dependency. The mock will be faster (no need to actually write to disk), cleaner (no need to clean up the files on disk between test runs) and will behave exactly to the spec (bugs in the dependency component won\u2019t create false failures in the component you\u2019re testing). Those are all good engineering arguments for using DI, full stop.<\/p>\n<p>Furthermore, DI helps insulate a software component against changes in its dependencies. I may not be able to predict specific changes with any precision, but it\u2019s probably safe to assume that there a given component\u2019s dependencies aren\u2019t going to remain completely static. DI doesn\u2019t insulate you 100% from possible changes \u2013 in particular, it doesn\u2019t help if the dependency\u2019s interface changes.<\/p>\n<p>But I would argue that you can go too far with DI. Let\u2019s go back to the logger component example I described above. Maybe, the over engineer thinks, we\u2019ll want the logger to write to the database instead of the file system in the future. Or maybe we\u2019ll want the logger to write to a different database. And if it\u2019s supporting a different database, then maybe the logger should support different back end databases. Or maybe, Or Maybe, OR MAYBE.. <\/p>\n<p>We\u2019ve gone from a simple component that logs to the file system and turned it into a engineering monstrosity with multiple points of variability and extensibility. When you start saying \u201cmaybe we should\u201d or \u201cthis could change in the future\u201d or stuff like that, that\u2019s when you start over engineering something.<\/p>\n<p>Unfortunately, there\u2019s only one way to know when you\u2019ve started over-engineering: Experience. Sorry Eric, I can\u2019t help you with your junior engineers. As David Lee Roth <a href=\"http:\/\/www.lyricsdepot.com\/david-lee-roth\/experience.html\">once sang<\/a>, Experience is the \u201cworst teacher goin\u2019\u201d. But if there\u2019s a better way to learn, I don\u2019t know it. In the meantime, I suggest code reviews and pair programming.<\/p>\n","excerpt":"<p>Since I think I\u2019ve beaten the \u201cI think what most people call architecture is really engineering\u201d meme to death, let\u2019s move on to something else. Eric Smith of The Limber Lambda blog (love that name!) commented: I&#8217;m a little concerned with the intimation that use of interfaces, respect for visibility of type members and use [&hellip;]<\/p>\n","date":"2009-07-17 16:55:40","modified":"2009-07-17 16:55:40","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":269,"slug":"software-design","title":"Software Design","description":"","post_count":2},{"id":284,"slug":"software-engineering","title":"Software Engineering","description":"","post_count":1}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2242,"name":"Sam Gentile","url":"http:\/\/samgentile.com\/Web","date":"2009-07-17 18:16:36","content":"<p>The commented link also goes to the David Lee Roth lyrics<\/p>\n","parent":0},{"id":2243,"name":"John","url":"","date":"2009-07-17 21:57:58","content":"<p><a href=\"http:\/\/www.globalnerdy.com\/wordpress\/wp-content\/uploads\/2008\/12\/yagni-development-assistant-3.gif\" rel=\"nofollow\">http:\/\/www.globalnerdy.com\/wordpress\/wp-content\/uploads\/2008\/12\/yagni-development-assistant-3.gif<\/a><\/p>\n","parent":0},{"id":2244,"name":"PhilM","url":"","date":"2009-08-05 18:45:30","content":"<p>Most programmers\/software engineers\/developers that I have worked with for a few decades now, are pretty stupid. Given the fact that we are human beings, that is quite natural that most of us are stupid. We go periodically to our chosen place of worship and get our dose of dogmatism from people blessed with glib tongues. Usually, the dogmas are reasonable sounding and seem worth adopting for life.<\/p>\n<p>So it is with programming. The priests of programming come in the guise of methodology gurus, architects, framework designers, testers, you name it and they are there. They usually have something to sell. The sheepish lot of programmers, who usually have an inflated sense of self-importance, absorb these dogmas and practice it as every new convert to any faith is wont to do.<\/p>\n<p>I have suffered and continue to suffer working with people who so foolishly and feverishly follow the prescribed rituals that the rituals become the end. Meeting the end of goal building a useful system is not the driver at all. Our systems are so finely architected at the micro level, right down to the patterns from GoF book, but they are miserable failures when it comes to the real world requirements of performance, security, scalability, robustness, extensibility, maintainability and usability. No need to mention that they are forever late. If your software is not full of interfaces, abstract classes and implementation classes or if it doesn&#8217;t have a boat load of managers, DAOs, it is considered unworthy and you are considered ignorant of modern ways of building software. The soul of design, which is all about trade offs, is hardly ever practiced. Everything is gold plated. Every turd gets french polished <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" alt=\":)\" class=\"wp-smiley\" \/>  <\/p>\n<p>Every practice has its place. But those who follow practices in total faith are, let me repeat, stupid. The bad news is that, there are a lot people of faith.<\/p>\n<p>Sorry, just have to get this off my chest somewhere. I liked your blog and had to comment.<\/p>\n","parent":0}],"attachments":[],"comment_count":3,"comment_status":"closed","custom_fields":{"dasblog_entryid":["d425eb36-8a14-4877-ba44-cfb9aa87a4ef"],"dasblog_compressedtitle":["The+Texas+Dependency+Injection+Massacre"],"dasblog_compressedtitleunique":["2009\/07\/17\/The+Texas+Dependency+Injection+Massacre"]}},"previous_url":"http:\/\/devhawk.net\/2009\/07\/15\/architecture-astronauts-and-over-engineers\/","next_url":"http:\/\/devhawk.net\/2009\/07\/28\/functions-that-create-functions-in-powershell\/"}