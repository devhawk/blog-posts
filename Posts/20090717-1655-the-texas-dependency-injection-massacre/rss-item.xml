<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>The Texas Dependency Injection Massacre</title>
  <link>http://devhawk.net/2009/07/17/the-texas-dependency-injection-massacre/</link>
  <pubDate>Fri, 17 Jul 2009 16:55:40 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://d425eb36-8a14-4877-ba44-cfb9aa87a4ef</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Since I think I’ve beaten the “I think what most people call architecture is really engineering” meme to death, let’s move on to something else. Eric Smith of <a href="http://thelimberlambda.com/">The Limber Lambda</a> blog (love that name!) <a href="http://www.lyricsdepot.com/david-lee-roth/experience.html">commented</a>:</p><blockquote><p>I'm a little concerned with the intimation that use of interfaces, respect for visibility of type members and use of dependency injection equates to "over-engineering". As with everything, it depends on what you're trying to achieve, and generalisations in this regard, especially when junior people who may not understand what's at stake are reading, can be damaging.</p><p>I find it an uphill battle to engender a constructive mindset in developers who have established bad habits and whose pride lies in the way of addressing those habits.</p><p>Anti-"process" talk by Joel Spolsky and the "pragmatism brigade" makes it harder. A while ago I had a new developer refuse to write unit tests despite it being an established practice in our team because "... Jeff and Joel said they were bad in the StackOverflow podcast ...". Yikes.</p></blockquote><p>Let me be very clear. I <em>never </em>suggested that techniques such as interfaces and dependency injection are over engineering. These are good engineering practices, and every software engineer should understand them. And if Joel and Jeff really said unit tests were bad, well that would be about the dumbest thing I’d have every heard either of those two say. Yikes indeed.</p><p>But as Eric writes, “it depends on what you're trying to achieve”. Engineering techniques like dependency injection, polymorphism, encapsulation are tools, and there are many good reasons to use them. But like many tools, they can also be used <a href="http://en.wikipedia.org/wiki/The_Texas_Chain_Saw_Massacre">for evil</a>.</p><p>In other words, the tools themselves are always innocent – you have to look at how and why they are being used by the people who are using them.</p><p>Let’s take <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> as an example. Externalizing a software component’s dependencies enables you to test it isolation from the rest of your system. For example, it’s very common to inject a dependency that writes to a durable store, such as a logger or a data access component. In your unit tests, you inject a mock durable store instead of the real dependency. The mock will be faster (no need to actually write to disk), cleaner (no need to clean up the files on disk between test runs) and will behave exactly to the spec (bugs in the dependency component won’t create false failures in the component you’re testing). Those are all good engineering arguments for using DI, full stop.</p><p>Furthermore, DI helps insulate a software component against changes in its dependencies. I may not be able to predict specific changes with any precision, but it’s probably safe to assume that there a given component’s dependencies aren’t going to remain completely static. DI doesn’t insulate you 100% from possible changes – in particular, it doesn’t help if the dependency’s interface changes.</p><p>But I would argue that you can go too far with DI. Let’s go back to the logger component example I described above. Maybe, the over engineer thinks, we’ll want the logger to write to the database instead of the file system in the future. Or maybe we’ll want the logger to write to a different database. And if it’s supporting a different database, then maybe the logger should support different back end databases. Or maybe, Or Maybe, OR MAYBE.. </p><p>We’ve gone from a simple component that logs to the file system and turned it into a engineering monstrosity with multiple points of variability and extensibility. When you start saying “maybe we should” or “this could change in the future” or stuff like that, that’s when you start over engineering something.</p><p>Unfortunately, there’s only one way to know when you’ve started over-engineering: Experience. Sorry Eric, I can’t help you with your junior engineers. As David Lee Roth <a href="http://www.lyricsdepot.com/david-lee-roth/experience.html">once sang</a>, Experience is the “worst teacher goin’”. But if there’s a better way to learn, I don’t know it. In the meantime, I suggest code reviews and pair programming.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1274</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-07-17 16:55:40</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-07-17 16:55:40</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">the-texas-dependency-injection-massacre</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="development"><![CDATA[Development]]></category>
  <category domain="post_tag" nicename="software-design"><![CDATA[Software Design]]></category>
  <category domain="post_tag" nicename="software-engineering"><![CDATA[Software Engineering]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[d425eb36-8a14-4877-ba44-cfb9aa87a4ef]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[The+Texas+Dependency+Injection+Massacre]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/07/17/The+Texas+Dependency+Injection+Massacre]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2242</wp:comment_id>
    <wp:comment_author><![CDATA[Sam Gentile]]></wp:comment_author>
    <wp:comment_author_email>managedcode44@hotmail.com</wp:comment_author_email>
    <wp:comment_author_url>http://samgentile.com/Web</wp:comment_author_url>
    <wp:comment_author_IP>98.110.111.205</wp:comment_author_IP>
    <wp:comment_date>2009-07-17 18:16:36</wp:comment_date>
    <wp:comment_date_gmt>2009-07-18 01:16:36</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[The commented link also goes to the David Lee Roth lyrics]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2243</wp:comment_id>
    <wp:comment_author><![CDATA[John]]></wp:comment_author>
    <wp:comment_author_email>jevdemon@acm.org</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>71.217.31.151</wp:comment_author_IP>
    <wp:comment_date>2009-07-17 21:57:58</wp:comment_date>
    <wp:comment_date_gmt>2009-07-18 04:57:58</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[http://www.globalnerdy.com/wordpress/wp-content/uploads/2008/12/yagni-development-assistant-3.gif]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2244</wp:comment_id>
    <wp:comment_author><![CDATA[PhilM]]></wp:comment_author>
    <wp:comment_author_email>philm@ymail.com</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>69.226.219.51</wp:comment_author_IP>
    <wp:comment_date>2009-08-05 18:45:30</wp:comment_date>
    <wp:comment_date_gmt>2009-08-06 01:45:30</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Most programmers/software engineers/developers that I have worked with for a few decades now, are pretty stupid. Given the fact that we are human beings, that is quite natural that most of us are stupid. We go periodically to our chosen place of worship and get our dose of dogmatism from people blessed with glib tongues. Usually, the dogmas are reasonable sounding and seem worth adopting for life.

So it is with programming. The priests of programming come in the guise of methodology gurus, architects, framework designers, testers, you name it and they are there. They usually have something to sell. The sheepish lot of programmers, who usually have an inflated sense of self-importance, absorb these dogmas and practice it as every new convert to any faith is wont to do.

I have suffered and continue to suffer working with people who so foolishly and feverishly follow the prescribed rituals that the rituals become the end. Meeting the end of goal building a useful system is not the driver at all. Our systems are so finely architected at the micro level, right down to the patterns from GoF book, but they are miserable failures when it comes to the real world requirements of performance, security, scalability, robustness, extensibility, maintainability and usability. No need to mention that they are forever late. If your software is not full of interfaces, abstract classes and implementation classes or if it doesn't have a boat load of managers, DAOs, it is considered unworthy and you are considered ignorant of modern ways of building software. The soul of design, which is all about trade offs, is hardly ever practiced. Everything is gold plated. Every turd gets french polished :) 

Every practice has its place. But those who follow practices in total faith are, let me repeat, stupid. The bad news is that, there are a lot people of faith.

Sorry, just have to get this off my chest somewhere. I liked your blog and had to comment.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>