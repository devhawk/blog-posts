<p>Since I think I&#8217;ve beaten the &#8220;I think what most people call architecture is really engineering&#8221; meme to death, let&#8217;s move on to something else. Eric Smith of <a href="http://thelimberlambda.com/">The Limber Lambda</a> blog (love that name!) <a href="http://www.lyricsdepot.com/david-lee-roth/experience.html">commented</a>:</p>
<blockquote><p>I&#8217;m a little concerned with the intimation that use of interfaces, respect for visibility of type members and use of dependency injection equates to &#8220;over-engineering&#8221;. As with everything, it depends on what you&#8217;re trying to achieve, and generalisations in this regard, especially when junior people who may not understand what&#8217;s at stake are reading, can be damaging.</p>
<p>I find it an uphill battle to engender a constructive mindset in developers who have established bad habits and whose pride lies in the way of addressing those habits.</p>
<p>Anti-&#8221;process&#8221; talk by Joel Spolsky and the &#8220;pragmatism brigade&#8221; makes it harder. A while ago I had a new developer refuse to write unit tests despite it being an established practice in our team because &#8220;&#8230; Jeff and Joel said they were bad in the StackOverflow podcast &#8230;&#8221;. Yikes.</p>
</blockquote>
<p>Let me be very clear. I <em>never </em>suggested that techniques such as interfaces and dependency injection are over engineering. These are good engineering practices, and every software engineer should understand them. And if Joel and Jeff really said unit tests were bad, well that would be about the dumbest thing I&#8217;d have every heard either of those two say. Yikes indeed.</p>
<p>But as Eric writes, &#8220;it depends on what you&#8217;re trying to achieve&#8221;. Engineering techniques like dependency injection, polymorphism, encapsulation are tools, and there are many good reasons to use them. But like many tools, they can also be used <a href="http://en.wikipedia.org/wiki/The_Texas_Chain_Saw_Massacre">for evil</a>.</p>
<p>In other words, the tools themselves are always innocent &#8211; you have to look at how and why they are being used by the people who are using them.</p>
<p>Let&#8217;s take <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> as an example. Externalizing a software component&#8217;s dependencies enables you to test it isolation from the rest of your system. For example, it&#8217;s very common to inject a dependency that writes to a durable store, such as a logger or a data access component. In your unit tests, you inject a mock durable store instead of the real dependency. The mock will be faster (no need to actually write to disk), cleaner (no need to clean up the files on disk between test runs) and will behave exactly to the spec (bugs in the dependency component won&#8217;t create false failures in the component you&#8217;re testing). Those are all good engineering arguments for using DI, full stop.</p>
<p>Furthermore, DI helps insulate a software component against changes in its dependencies. I may not be able to predict specific changes with any precision, but it&#8217;s probably safe to assume that there a given component&#8217;s dependencies aren&#8217;t going to remain completely static. DI doesn&#8217;t insulate you 100% from possible changes &#8211; in particular, it doesn&#8217;t help if the dependency&#8217;s interface changes.</p>
<p>But I would argue that you can go too far with DI. Let&#8217;s go back to the logger component example I described above. Maybe, the over engineer thinks, we&#8217;ll want the logger to write to the database instead of the file system in the future. Or maybe we&#8217;ll want the logger to write to a different database. And if it&#8217;s supporting a different database, then maybe the logger should support different back end databases. Or maybe, Or Maybe, OR MAYBE.. </p>
<p>We&#8217;ve gone from a simple component that logs to the file system and turned it into a engineering monstrosity with multiple points of variability and extensibility. When you start saying &#8220;maybe we should&#8221; or &#8220;this could change in the future&#8221; or stuff like that, that&#8217;s when you start over engineering something.</p>
<p>Unfortunately, there&#8217;s only one way to know when you&#8217;ve started over-engineering: Experience. Sorry Eric, I can&#8217;t help you with your junior engineers. As David Lee Roth <a href="http://www.lyricsdepot.com/david-lee-roth/experience.html">once sang</a>, Experience is the &#8220;worst teacher goin&#8217;&#8221;. But if there&#8217;s a better way to learn, I don&#8217;t know it. In the meantime, I suggest code reviews and pair programming.</p>
