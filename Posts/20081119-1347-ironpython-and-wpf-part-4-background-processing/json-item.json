{"status":"ok","post":{"id":1191,"type":"post","slug":"ironpython-and-wpf-part-4-background-processing","url":"http:\/\/devhawk.net\/2008\/11\/19\/ironpython-and-wpf-part-4-background-processing\/","status":"publish","title":"IronPython and WPF Part 4: Background Processing","title_plain":"IronPython and WPF Part 4: Background Processing","content":"<p>Like many apps today, my <a href=\"http:\/\/devhawk.net\/2008\/11\/13\/IronPython+And+WPF+Part+1+Introduction.aspx\">WL Spaces photo viewer<\/a> is a connected app. The various WL Spaces RSS feeds that drive the app can take a several seconds to download. Unless you like annoying your users, it\u2019s a bad idea to lock up your user interface while you make you make synchronous network calls on your UI thread. Typically, this long running processing gets farmed out to a background thread which keeps the UI thread free to service the user events.<\/p>\n<p>.NET provides a variety of mechanisms for doing long running processing on a background thread. For example you can create a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.thread.aspx\">new thread<\/a>, you can <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.threadpool.queueuserworkitem.aspx\">queue a work item<\/a> to the ThreadPoool or use the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.componentmodel.backgroundworker.aspx\">BackgroundWorker component<\/a>. However, none of these are particularly pythonic, so I set out to see if I could leverage any of Python\u2019s unique capabilities to make background processing as easy as possible. This is what I ended up with:<\/p>\n<pre class=\"brush: python\">\ndef OnClick(self, sender, args):  \n    self.DLButton.IsEnabled = False  \n    self.BackgroundTask(self._url.Text)  \n\n@BGThread    \ndef BackgroundTask(self, url):  \n    wc = WebClient()     \n    data = wc.DownloadString(Uri(url))    \n    self.Completed(data)  \n      \n@UIThread  \ndef Completed(self, data):  \n    self.DLButton.IsEnabled = True\n    self._text.Text = data\n<\/pre>\n<p>By using the cool <a href=\"http:\/\/www.python.org\/dev\/peps\/pep-0318\/\">decorators feature<\/a> of Python, I\u2019m able to declaratively indicate whether I want a given method to be executed on the UI thread or on a background thread. Doesn\u2019t get much easier than that. Even better, the implementations of BGThread and UIThread are only about twenty lines of Python code combined!<\/p>\n<p>Decorators kinda look like custom .NET attributes. However, where .NET attributes are passive (you have to <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.memberinfo.getcustomattributes.aspx\">ask for them explicitly<\/a>), decorators act as an active modifier to the functions they are attached to. In that respect, they\u2019re kind of like <a href=\"http:\/\/en.wikipedia.org\/wiki\/Aspect-oriented_programming\">aspects<\/a>. Certainly, I would consider which thread a given method executes on to be a cross-cutting concern. <\/p>\n<p>The Completed function above is exactly the same as if I had written the following:<\/p>\n<pre class=\"brush: python\">\ndef Completed(self, data):  \n    self.DLButton.IsEnabled = True  \n    self._text.Text = data  \nCompleted = UIThread(Completed)\n<\/pre>\n<p>In C#, you can\u2019t pass a function as a parameter to another function \u2013 you have to first wrap that function in a delegate. Python, like F#, directly supports <a href=\"http:\/\/en.wikipedia.org\/wiki\/First_order_functions\">higher-order functions<\/a>. This lets you easily factor common aspectual code out into reusable functions then compose them with your business logic. The decorators have no knowledge of the functions they are attached to and the code that calls those functions are written in complete ignorance of the decorators. Python goes the extra mile beyond even F# by providing the \u2018@\u2019 syntax.<\/p>\n<p>Here are the implementations of my the UIThread and BGThread decorators:<\/p>\n<pre class=\"brush: python\">\ndef BGThread(fun):  \n  def argUnpacker(args):  \n    fun(*args)     \n   \n  def wrapper(*args):  \n    ThreadPool.QueueUserWorkItem(WaitCallback(argUnpacker), args)     \n   \n  return wrapper     \n\ndef UIThread(fun):     \n  def wrapper(self, *args):     \n    if len(args) == 0:     \n      actiontype = Action1[object]     \n    else:     \n      actiontype = Action[tuple(object for x in range(len(args)+1))]     \n\n    action = actiontype(fun)     \n    self.dispatcher.Invoke(action, self, *args)     \n     \n  return wrapper\n<\/pre>\n<p>BGThread defines a wrapper function that queues a call to the decorated function to the .NET thread pool.\u00a0 UIThread defines a wrapper that marshals the call to the UI thread by using a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.windows.threading.dispatcher.aspx\">WPF Dispatcher<\/a>. I\u2019m thinking there might be a way to use <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.synchronizationcontext.aspx\">SynchronizationContext<\/a> to marshal it automatically, but I haven\u2019t tried to figure that out yet. The above approach does require a dispatcher property hanging off the class, but that\u2019s fairly trivial to implement and seems like a small price to pay to get declarative background thread processing. <\/p>\n<p>A couple of quick implementation notes: <\/p>\n<ul>\n<li>The \u2018*args\u2019 syntax used in those methods above means \u201cgiven me the rest of the positional arguments in a tuple\u201d. Kinda like the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/w5zay9db.aspx\">C# params keyword<\/a>. But that syntax also lets you pass a tuple of parameters to a function, and have them broken out into individual parameters. QueueUserWorkItem only supports passing a single object into the queued function, so I pass the tupled arguments to the argUnpacker method, which in turn untuples the arguments and calls the decorated function.<\/li>\n<li>The System assembly includes the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/018hxwa8.aspx\">single parameter Action&lt;T&gt; delegate<\/a>. The current DLR <a href=\"http:\/\/www.codeplex.com\/IronPython\/SourceControl\/FileView.aspx?itemId=649845&amp;changeSetId=43712\">provides Action delegates<\/a> with zero, two and up to sixteen parameters. However, those are in a separate namespace (<a href=\"http:\/\/devhawk.net\/2008\/09\/17\/DLR+Namespace+Change+Fire+Drill.aspx\">remember?<\/a>) and IPy seems to have an issue with importing overloaded type names into the current scope. I could have used their namespace scoped name, but instead I redefined the version from System to be called Action1.<\/li>\n<li>To interop with .NET generic types, IPy uses the legal but rarely used Python syntax type[typeparam]. For example, to create a List of strings, you would say \u201cList[str]()\u201d. The type parameter is a tuple, so in UIThread I build a tuple of objects based on the number of arguments passed into wrapper (with the special case of a single type parameter using Action1 instead of Action). <\/li>\n<\/ul>\n<p>I haven\u2019t uploaded my WL Spaces Photo Viewer app because I keep making changes to it as I write this blog post series. However, for this post I built a simple demo app so I could focus on just the threading scenario. I\u2019ve stuck the code for that demo <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/self.aspx\/DevHawk%20Content\/IronPython%20Stuff\/WpfThreadDemo.zip\">up on my SkyDrive<\/a>, so feel free to leverage it as you need. <\/p>\n","excerpt":"<p>Like many apps today, my WL Spaces photo viewer is a connected app. The various WL Spaces RSS feeds that drive the app can take a several seconds to download. Unless you like annoying your users, it\u2019s a bad idea to lock up your user interface while you make you make synchronous network calls on [&hellip;]<\/p>\n","date":"2008-11-19 13:47:57","modified":"2008-11-19 13:47:57","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":272,"slug":"parallel-programming","title":"Parallel Programming","description":"","post_count":3},{"id":271,"slug":"wpf","title":"WPF","description":"","post_count":8}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["304749a7-3483-4f00-9b09-3ddc9f33b783"],"dasblog_compressedtitle":["IronPython+And+WPF+Part+4+Background+Processing"],"dasblog_compressedtitleunique":["2008\/11\/19\/IronPython+And+WPF+Part+4+Background+Processing"]}},"previous_url":"http:\/\/devhawk.net\/2008\/11\/17\/ironpython-and-wpf-part-3-data-binding\/","next_url":"http:\/\/devhawk.net\/2008\/11\/20\/ironpython-and-wpf-background-processing-revisited\/"}