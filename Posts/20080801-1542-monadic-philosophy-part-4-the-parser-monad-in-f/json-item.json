{"status":"ok","post":{"id":1166,"type":"post","slug":"monadic-philosophy-part-4-the-parser-monad-in-f","url":"http:\/\/devhawk.net\/2008\/08\/01\/monadic-philosophy-part-4-the-parser-monad-in-f\/","status":"publish","title":"Monadic Philosophy Part 4 &#8211; The Parser Monad in F#","title_plain":"Monadic Philosophy Part 4 &#8211; The Parser Monad in F#","content":"<p>In the <a href=\"http:\/\/devhawk.net\/2008\/08\/01\/Monadic+Philosophy+Part+3+The+Parser+Monad+In+C.aspx\">last post<\/a>, I built out a basic parser monad in C#. While the approach worked OK, the syntax is still a little foreign to your typical .NET programmer, what with it&#8217;s nested anonymous functions and all. Now, I&#8217;m going to translate that code to F# and take a look at the special monadic syntax F# supports that makes using monads as easy any sequential code.<\/p>\n<p>First, let&#8217;s translate our Parser delegate, Bind, Result and Item functions over to F#. Just for kicks, let&#8217;s also port over the final version of TwoItems too.<\/p>\n<pre class=\"brush: fsharp\">\ntype Parser&lt;'input, 'result&gt; = 'input-&gt; ('result * 'input) option \n\n\/\/ the Bind function, defined as a custom operator\nlet (&gt;&gt;=) p f : Parser&lt;'i,'r&gt; =  \n    fun input -&gt;\n        match p input with\n        | Some(value, input) -&gt; (f value) input \n        | None -&gt; None \n\nlet Result v : Parser&lt;'i,'r&gt; = fun input -&gt; Some(v, input)\n\nlet Item : Parser&lt;string, char&gt; =  \n    fun input -&gt;\n        if string.IsNullOrEmpty(input)  \n            then None \n            else Some(input.[0], input.Substring(1))\n\nlet BestTwoItems =  \n    Item &gt;&gt;= (fun v1 -&gt;  \n    Item &gt;&gt;= (fun v2 -&gt;  \n    Result (sprintf \"%c%c\" v1 v2)))\n<\/pre>\n<p>First, we start with the declaration of the Parser type. Unlike C#, F# has built in support for tuples, so I didn&#8217;t bother to define a Result type (just the Result function). A Parser is declared to be a function that takes in some generic input type and returns an optional tuple pairing the result with the remaining input to be parsed. As I&#8217;ve blogged before, F#&#8217;s option type is kinda like C#&#8217;s Nullable type, so a parser that returns None is considered to have failed to parse the input.<\/p>\n<p>Next up is are the monad functions Bind and Result. The only significant change from the C# version is that I used the custom operator &gt;&gt;= for the Bind function. So instead of calling &#8220;Item().Bind(some_function)&#8221;, we can call &#8220;Item &gt;&gt;= some_function&#8221;. F# functions aren&#8217;t attached to a type like C# extension methods are, so this is the only way to get the more readable infix notation. I&#8217;m using &gt;&gt;= as the bind operator because that&#8217;s the operator <a href=\"http:\/\/www.haskell.org\/haskellwiki\/Monad\">Haskell uses<\/a> for their monad function. Other than the custom operator name, Bind and Result work identically to their C# counterparts. Note, I explicitly specified the return type of Bind, Result and Item, but I didn&#8217;t have to. F# can infer the types of all the parameters from usage just fine. I added the type specifications for the reader, in case you&#8217;re not familiar with F#&#8217;s syntax. <\/p>\n<p>Likewise, Item is identical to the C# version including using strings as the parse input, except for than the F# syntax. Typically, in a real parsing app you would use an intrinsic list of chars instead of strings, since F#s list is a much more efficient data structure than strings for operations that strip characters off the head of the list (like parsers are wont to do). However, I wanted to make this code as similar to the previous code, so I stuck with strings.<\/p>\n<p>Finally, we have BestTwoItems. Again, syntax aside, it&#8217;s exactly like it&#8217;s C# cousin though I did use the slightly more compact sprintf function instead of string.Format. Again, while BestTwoItems it works well, it uses the same nested anonymous function syntax from the C# version. Maybe I shouldn&#8217;t have called it &#8220;BestTwoItems&#8221;!<\/p>\n<p>However, in F# it&#8217;s possible to define a custom syntax for your monad that let&#8217;s you write the function this way:<\/p>\n<pre class=\"brush: fsharp\">\nlet VeryBestTwoItems = \n    parse {\n        let! v1 = Item \n        let! v2 = Item \n        return sprintf \"%c%c\" v1 v2 }\n<\/pre>\n<p>With this monadic syntax, we&#8217;ve now completely eliminated not only the Parser delegate and the input string, but also the nested anonymous functions needed by the Bind function, making the code appear completely sequential. <\/p>\n<p>The secret to making this work is the parse monad object. It the code above, the word parse almost feels like a language keyword, but it&#8217;s not. It&#8217;s actually an instance of an parse monad object with a specific signature. F# knows how to take the syntax above and combine it with the parse monad object to produce the right code. Here&#8217;s the parse monad:<\/p>\n<pre class=\"brush: fsharp\">\ntype ParseMonad() = \n    member w.Delay(f) = fun input -&gt; f () input  \n    member w.Return(v) = Result v  \n    member w.Bind(p, f) = p &gt;&gt;= f \n     \nlet parse = ParseMonad()\n<\/pre>\n<p>As you can see, there&#8217;s an obvious direct correlation of Result and Bind functions we defined last time and the Return and Bind methods in the ParseMonad. The only thing we haven&#8217;t seen before is the Delay method. Monads are one of of F#&#8217;s many <a href=\"http:\/\/research.microsoft.com\/projects\/fsharp\/manual\/spec2.aspx#_Toc202383770\">delayed expressions<\/a>. F# wraps the entire monad in a call to Delay to ensure the monad isn&#8217;t executed prematurely. <\/p>\n<p>As per the <a href=\"http:\/\/research.microsoft.com\/projects\/fsharp\/manual\/spec2.aspx#_Toc202383771\">F# grammar spec<\/a>, there are several other functions you can define on your monad if you so choose. My &#8220;real&#8221; parser monad also implements Zero and Combine. Zero returns a parser that unconditionally fails. By defining Zero on my monad object, I can write ifs without elses, the parser monad will implicitly inject Zero clause as your else statement. Combine combines results (I know, a shocker!). I use it as a prioritized choice. In other words, when you Combine two parsers, you only call the second parser if calling the first parsers fails. Prioritized Choice is used very often in PEGs, which is why I chose to define it this way.<\/p>\n<p>F# monadic syntax also support For, Let, While, Using, TryFinally and TryWith. Frankly, I haven&#8217;t spent much time thinking about scenarios where you&#8217;d use these other syntax elements. The only one that&#8217;s obvious to me is Using for deterministic finalization, which you could see using anywhere you access IDispoasble objects. Here&#8217;s hoping the F# folks document in detail how to use this powerful syntax.<\/p>\n<p>So that&#8217;s it for basic monads in F#. I&#8217;ve gotten some great comments (and one less than great comments) as I&#8217;ve written this series. In my last post on monads (in this series at least) I&#8217;ll repost some of those comments as well as provide some concluding thoughts. <\/p>\n","excerpt":"<p>In the last post, I built out a basic parser monad in C#. While the approach worked OK, the syntax is still a little foreign to your typical .NET programmer, what with it&#8217;s nested anonymous functions and all. Now, I&#8217;m going to translate that code to F# and take a look at the special monadic [&hellip;]<\/p>\n","date":"2008-08-01 15:42:57","modified":"2011-04-16 22:14:37","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":202,"slug":"functional-programming","title":"Functional Programming","description":"","post_count":18},{"id":267,"slug":"monads","title":"Monads","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["9b8f0a29-ba33-46a2-a34d-ab470fa5e59a"],"dasblog_compressedtitle":["Monadic+Philosophy+Part+4+The+Parser+Monad+In+F"],"dasblog_compressedtitleunique":["2008\/08\/01\/Monadic+Philosophy+Part+4+The+Parser+Monad+In+F"]}},"previous_url":"http:\/\/devhawk.net\/2008\/08\/01\/mccains-dick-move-of-the-week\/","next_url":"http:\/\/devhawk.net\/2008\/08\/06\/including-the-batteries-in-ironpython\/"}