<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Practical F# Parsing: Semantic Productions (2)</title>
  <link>http://devhawk.net/2007/12/20/practical-f-parsing-semantic-productions-2/</link>
  <pubDate>Thu, 20 Dec 2007 18:00:50 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://01f3a3c9-30ce-4a3c-81fa-f495e8dccab0</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Now that I've <a href="http://devhawk.net/2007/12/19/Practical+F+Parsing+The+Abstract+Syntax+Tree.aspx" target="_blank">explained the AST</a>, there are several more semantic productions to go. I'm not going to describe them all in detail, just hit a few important highlights. </p><p>Many of the semantic productions return lists of other productions. Class returns a list of Ranges, Literal and Identifier returns lists of characters, etc. As you would expect, these multiples are encoded in the grammar. For example, here's the implementation of Literal:</p><pre class="brush: fsharp">
///Literal &lt;- ['] (!['] Char)* ['] Spacing
///         / ["] (!["] Char)* ["] Spacing
let (|Literal|_|) input = 

    let rec (|LitChars|_|) delimiter chars input = 
        match input with
        | TOKEN delimiter (_) -&gt; Some(L2S chars, input)
        | Char (c, input) -&gt;  
            (|LitChars|_|) delimiter (chars @ [c]) input 
        | _ -&gt; None 
     
    match input with
    | TOKEN "'"  (LitChars "'"  [] (lit, TOKEN "'"  (Spacing(input)))) -&gt;  
        Some(lit, input)
    | TOKEN """ (LitChars """ [] (lit, TOKEN """ (Spacing(input)))) -&gt;  
        Some(lit, input)
    | _ -&gt; None
</pre><p>I'm using a local recursive function LitChars to retrieve the characters between the quote delimiters. The quote parameter - i.e. single or double quote - is passed in as a parameter. I also pass in an empty list of chars as a parameter. Remember that functional programs keep their data on the stack, a list parameter is a common way to keep state in a recursive function. When I match a single non-delimiter character, I add it to the list with the chars @ [c] expression. [c] converts a single value c into a list of one element while the @ operator concatenates to lists. I'm not sure adding the value to he end like that is a good idea perf wise. <a href="http://www.pragprog.com/titles/jaerlang/" target="_blank">Programming Erlang</a> recommends only adding items to the head then reversing the list when you're done matching. But F# isn't Erlang, so I'm not sure what the guidance is here.</p><p>Another thing you find in productions is the backtracking syntactic predicates. We saw an example of them in the <a href="http://devhawk.net/2007/12/17/Practical+F+Parsing+Syntactical+Productions+2.aspx" target="_blank">implementation of Comment</a>. Often, their used to indicate the end of a list of other productions, such as Literal, above. However, sometimes, they're used to ensure the correct production is matched. For example, a Primary can be an Identifier, as long as it's not followed by a left arrow. An identifier followed by a left arrow indicates a Definition. </p><pre class="brush: fsharp">
///Primary &lt;- Identifier !LEFTARROW
///         / OPEN Expression CLOSE
///         / Literal / Class / DOT
let rec (|Primary|_|) input = 

    let (|NotLEFTARROW|_|) input = 
        match input with
        | LEFTARROW (_) -&gt; None 
        | _ -&gt; Some(input)

    match input with
    | Identifier (id, NotLEFTARROW (input)) -&gt;  
        Some(Primary.Identifier(id), input)
    | OPEN ( Expression (exp, CLOSE (input))) -&gt; 
        Some(Primary.Expression(exp), input)
    | Literal (lit, input) -&gt; Some(Primary.Literal(lit), input)
    | Class (cls, input) -&gt; Some(Primary.Class(cls), input)
    | DOT (input) -&gt; Some(Primary.Dot, input)
    | _ -&gt; None
</pre><p>Here, I need a way to match the absence of LEFTARROW, so I've build a simple local function called NotLEFTARROW. This isn't very clean IMO - I'd rather have a used a custom operator like !!! and &amp;&amp;&amp; for my backtracking predicates. But I haven't figured out how to use custom operators as Active Patterns. I was able to write a standard non-operator AP function, but then I have to use the full AP function name. Here's a version of Primary written that way:</p><pre class="brush: fsharp">
///Backtracking failure predicate
let (|NotPred|_|) f input = 
    match f input with
    | Some (_) -&gt; None 
    | _ -&gt; Some(input) 
     
let rec (|Primary|_|) input = 
    match input with
    | Identifier (id, NotPred (|LEFTARROW|_|) (input)) -&gt;  
        Some(Primary.Identifier(id), input) 
    //Other matches omited
</pre><p>Frankly, I don't think that's very readable, so I didn't implement it that way. If I can figure out how to use custom operators and pass around AP functions without using their full ugly name, I'll change it.</p><p>Finally, there are a few things about F#'s scoping rules that you need to understand. F# uses linear scoping, which is to say there's no way to use a type or function that hasn't been declared, sort of like C/C++. The difference is that while C/C++ have a way to declare a type or function separately from its implementation, F# has no such capacity. This becomes an issue when you have circular references. For example, Primary can be an Expression, which is a list of SequenceItems, each of which is a Primary with an optional prefix and suffix. In order to declare those in F#, you have to use a special "and" syntax to link the types/functions together.</p><pre class="brush: fsharp">
//ToString and Exp2Str omitted for clarity
type Primary = 
| Identifier of string
| Expression of Expression 
| Literal of string
| Class of Range list 
| Dot  

//ToString omitted for clarity
and SequenceItem = 
    {  
        primaryItem: Primary; 
        itemPrefix: Prefix option;      
        itemSuffix: Suffix option; 
    }

and Sequence = SequenceItem list 

and Expression = Sequence list
</pre><p>Likewise, the AP functions to recognize Primary, SequenceItem, Sequence and Expression are anded together. For me, this is one of the hardest things to get used to about F#. But as you can see from the expressiveness of the code, it's well worth the trouble</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1083</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-12-20 10:00:50</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-12-20 18:00:50</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">practical-f-parsing-semantic-productions-2</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="development"><![CDATA[Development]]></category>
  <category domain="post_tag" nicename="f-sharp"><![CDATA[F#]]></category>
  <category domain="post_tag" nicename="parsing-expression-grammar"><![CDATA[Parsing Expression Grammar]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[01f3a3c9-30ce-4a3c-81fa-f495e8dccab0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Practical+F+Parsing+Semantic+Productions+2]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/12/20/Practical+F+Parsing+Semantic+Productions+2]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>