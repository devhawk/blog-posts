<p>Now that I&#8217;ve <a href="http://devhawk.net/2007/12/19/Practical+F+Parsing+The+Abstract+Syntax+Tree.aspx" target="_blank">explained the AST</a>, there are several more semantic productions to go. I&#8217;m not going to describe them all in detail, just hit a few important highlights. </p>
<p>Many of the semantic productions return lists of other productions. Class returns a list of Ranges, Literal and Identifier returns lists of characters, etc. As you would expect, these multiples are encoded in the grammar. For example, here&#8217;s the implementation of Literal:</p>
<pre class="brush: fsharp">///Literal &lt;- ['] (!['] Char)* ['] Spacing
///         / [&quot;] (![&quot;] Char)* [&quot;] Spacing
let (|Literal|_|) input = 

    let rec (|LitChars|_|) delimiter chars input = 
        match input with
        | TOKEN delimiter (_) -&gt; Some(L2S chars, input)
        | Char (c, input) -&gt;  
            (|LitChars|_|) delimiter (chars @ [c]) input 
        | _ -&gt; None 
     
    match input with
    | TOKEN &quot;'&quot;  (LitChars &quot;'&quot;  [] (lit, TOKEN &quot;'&quot;  (Spacing(input)))) -&gt;  
        Some(lit, input)
    | TOKEN &quot;&quot;&quot; (LitChars &quot;&quot;&quot; [] (lit, TOKEN &quot;&quot;&quot; (Spacing(input)))) -&gt;  
        Some(lit, input)
    | _ -&gt; None
</pre>
<p>I&#8217;m using a local recursive function LitChars to retrieve the characters between the quote delimiters. The quote parameter &#8211; i.e. single or double quote &#8211; is passed in as a parameter. I also pass in an empty list of chars as a parameter. Remember that functional programs keep their data on the stack, a list parameter is a common way to keep state in a recursive function. When I match a single non-delimiter character, I add it to the list with the chars @ [c] expression. [c] converts a single value c into a list of one element while the @ operator concatenates to lists. I&#8217;m not sure adding the value to he end like that is a good idea perf wise. <a href="http://www.pragprog.com/titles/jaerlang/" target="_blank">Programming Erlang</a> recommends only adding items to the head then reversing the list when you&#8217;re done matching. But F# isn&#8217;t Erlang, so I&#8217;m not sure what the guidance is here.</p>
<p>Another thing you find in productions is the backtracking syntactic predicates. We saw an example of them in the <a href="http://devhawk.net/2007/12/17/Practical+F+Parsing+Syntactical+Productions+2.aspx" target="_blank">implementation of Comment</a>. Often, their used to indicate the end of a list of other productions, such as Literal, above. However, sometimes, they&#8217;re used to ensure the correct production is matched. For example, a Primary can be an Identifier, as long as it&#8217;s not followed by a left arrow. An identifier followed by a left arrow indicates a Definition. </p>
<pre class="brush: fsharp">///Primary &lt;- Identifier !LEFTARROW
///         / OPEN Expression CLOSE
///         / Literal / Class / DOT
let rec (|Primary|_|) input = 

    let (|NotLEFTARROW|_|) input = 
        match input with
        | LEFTARROW (_) -&gt; None 
        | _ -&gt; Some(input)

    match input with
    | Identifier (id, NotLEFTARROW (input)) -&gt;  
        Some(Primary.Identifier(id), input)
    | OPEN ( Expression (exp, CLOSE (input))) -&gt; 
        Some(Primary.Expression(exp), input)
    | Literal (lit, input) -&gt; Some(Primary.Literal(lit), input)
    | Class (cls, input) -&gt; Some(Primary.Class(cls), input)
    | DOT (input) -&gt; Some(Primary.Dot, input)
    | _ -&gt; None
</pre>
<p>Here, I need a way to match the absence of LEFTARROW, so I&#8217;ve build a simple local function called NotLEFTARROW. This isn&#8217;t very clean IMO &#8211; I&#8217;d rather have a used a custom operator like !!! and &amp;&amp;&amp; for my backtracking predicates. But I haven&#8217;t figured out how to use custom operators as Active Patterns. I was able to write a standard non-operator AP function, but then I have to use the full AP function name. Here&#8217;s a version of Primary written that way:</p>
<pre class="brush: fsharp">///Backtracking failure predicate
let (|NotPred|_|) f input = 
    match f input with
    | Some (_) -&gt; None 
    | _ -&gt; Some(input) 
     
let rec (|Primary|_|) input = 
    match input with
    | Identifier (id, NotPred (|LEFTARROW|_|) (input)) -&gt;  
        Some(Primary.Identifier(id), input) 
    //Other matches omited
</pre>
<p>Frankly, I don&#8217;t think that&#8217;s very readable, so I didn&#8217;t implement it that way. If I can figure out how to use custom operators and pass around AP functions without using their full ugly name, I&#8217;ll change it.</p>
<p>Finally, there are a few things about F#&#8217;s scoping rules that you need to understand. F# uses linear scoping, which is to say there&#8217;s no way to use a type or function that hasn&#8217;t been declared, sort of like C/C++. The difference is that while C/C++ have a way to declare a type or function separately from its implementation, F# has no such capacity. This becomes an issue when you have circular references. For example, Primary can be an Expression, which is a list of SequenceItems, each of which is a Primary with an optional prefix and suffix. In order to declare those in F#, you have to use a special &#8220;and&#8221; syntax to link the types/functions together.</p>
<pre class="brush: fsharp">//ToString and Exp2Str omitted for clarity
type Primary = 
| Identifier of string
| Expression of Expression 
| Literal of string
| Class of Range list 
| Dot  

//ToString omitted for clarity
and SequenceItem = 
    {  
        primaryItem: Primary; 
        itemPrefix: Prefix option;      
        itemSuffix: Suffix option; 
    }

and Sequence = SequenceItem list 

and Expression = Sequence list
</pre>
<p>Likewise, the AP functions to recognize Primary, SequenceItem, Sequence and Expression are anded together. For me, this is one of the hardest things to get used to about F#. But as you can see from the expressiveness of the code, it&#8217;s well worth the trouble</p>
