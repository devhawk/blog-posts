{"status":"ok","post":{"id":1083,"type":"post","slug":"practical-f-parsing-semantic-productions-2","url":"http:\/\/devhawk.net\/2007\/12\/20\/practical-f-parsing-semantic-productions-2\/","status":"publish","title":"Practical F# Parsing: Semantic Productions (2)","title_plain":"Practical F# Parsing: Semantic Productions (2)","content":"<p>Now that I&#8217;ve <a href=\"http:\/\/devhawk.net\/2007\/12\/19\/Practical+F+Parsing+The+Abstract+Syntax+Tree.aspx\" target=\"_blank\">explained the AST<\/a>, there are several more semantic productions to go. I&#8217;m not going to describe them all in detail, just hit a few important highlights. <\/p>\n<p>Many of the semantic productions return lists of other productions. Class returns a list of Ranges, Literal and Identifier returns lists of characters, etc. As you would expect, these multiples are encoded in the grammar. For example, here&#8217;s the implementation of Literal:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Literal &lt;- ['] (!['] Char)* ['] Spacing\n\/\/\/         \/ [\"] (![\"] Char)* [\"] Spacing\nlet (|Literal|_|) input = \n\n    let rec (|LitChars|_|) delimiter chars input = \n        match input with\n        | TOKEN delimiter (_) -&gt; Some(L2S chars, input)\n        | Char (c, input) -&gt;  \n            (|LitChars|_|) delimiter (chars @ [c]) input \n        | _ -&gt; None \n     \n    match input with\n    | TOKEN \"'\"  (LitChars \"'\"  [] (lit, TOKEN \"'\"  (Spacing(input)))) -&gt;  \n        Some(lit, input)\n    | TOKEN \"\"\" (LitChars \"\"\" [] (lit, TOKEN \"\"\" (Spacing(input)))) -&gt;  \n        Some(lit, input)\n    | _ -&gt; None\n<\/pre>\n<p>I&#8217;m using a local recursive function LitChars to retrieve the characters between the quote delimiters. The quote parameter &#8211; i.e. single or double quote &#8211; is passed in as a parameter. I also pass in an empty list of chars as a parameter. Remember that functional programs keep their data on the stack, a list parameter is a common way to keep state in a recursive function. When I match a single non-delimiter character, I add it to the list with the chars @ [c] expression. [c] converts a single value c into a list of one element while the @ operator concatenates to lists. I&#8217;m not sure adding the value to he end like that is a good idea perf wise. <a href=\"http:\/\/www.pragprog.com\/titles\/jaerlang\/\" target=\"_blank\">Programming Erlang<\/a> recommends only adding items to the head then reversing the list when you&#8217;re done matching. But F# isn&#8217;t Erlang, so I&#8217;m not sure what the guidance is here.<\/p>\n<p>Another thing you find in productions is the backtracking syntactic predicates. We saw an example of them in the <a href=\"http:\/\/devhawk.net\/2007\/12\/17\/Practical+F+Parsing+Syntactical+Productions+2.aspx\" target=\"_blank\">implementation of Comment<\/a>. Often, their used to indicate the end of a list of other productions, such as Literal, above. However, sometimes, they&#8217;re used to ensure the correct production is matched. For example, a Primary can be an Identifier, as long as it&#8217;s not followed by a left arrow. An identifier followed by a left arrow indicates a Definition. <\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Primary &lt;- Identifier !LEFTARROW\n\/\/\/         \/ OPEN Expression CLOSE\n\/\/\/         \/ Literal \/ Class \/ DOT\nlet rec (|Primary|_|) input = \n\n    let (|NotLEFTARROW|_|) input = \n        match input with\n        | LEFTARROW (_) -&gt; None \n        | _ -&gt; Some(input)\n\n    match input with\n    | Identifier (id, NotLEFTARROW (input)) -&gt;  \n        Some(Primary.Identifier(id), input)\n    | OPEN ( Expression (exp, CLOSE (input))) -&gt; \n        Some(Primary.Expression(exp), input)\n    | Literal (lit, input) -&gt; Some(Primary.Literal(lit), input)\n    | Class (cls, input) -&gt; Some(Primary.Class(cls), input)\n    | DOT (input) -&gt; Some(Primary.Dot, input)\n    | _ -&gt; None\n<\/pre>\n<p>Here, I need a way to match the absence of LEFTARROW, so I&#8217;ve build a simple local function called NotLEFTARROW. This isn&#8217;t very clean IMO &#8211; I&#8217;d rather have a used a custom operator like !!! and &amp;&amp;&amp; for my backtracking predicates. But I haven&#8217;t figured out how to use custom operators as Active Patterns. I was able to write a standard non-operator AP function, but then I have to use the full AP function name. Here&#8217;s a version of Primary written that way:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Backtracking failure predicate\nlet (|NotPred|_|) f input = \n    match f input with\n    | Some (_) -&gt; None \n    | _ -&gt; Some(input) \n     \nlet rec (|Primary|_|) input = \n    match input with\n    | Identifier (id, NotPred (|LEFTARROW|_|) (input)) -&gt;  \n        Some(Primary.Identifier(id), input) \n    \/\/Other matches omited\n<\/pre>\n<p>Frankly, I don&#8217;t think that&#8217;s very readable, so I didn&#8217;t implement it that way. If I can figure out how to use custom operators and pass around AP functions without using their full ugly name, I&#8217;ll change it.<\/p>\n<p>Finally, there are a few things about F#&#8217;s scoping rules that you need to understand. F# uses linear scoping, which is to say there&#8217;s no way to use a type or function that hasn&#8217;t been declared, sort of like C\/C++. The difference is that while C\/C++ have a way to declare a type or function separately from its implementation, F# has no such capacity. This becomes an issue when you have circular references. For example, Primary can be an Expression, which is a list of SequenceItems, each of which is a Primary with an optional prefix and suffix. In order to declare those in F#, you have to use a special &#8220;and&#8221; syntax to link the types\/functions together.<\/p>\n<pre class=\"brush: fsharp\">\n\/\/ToString and Exp2Str omitted for clarity\ntype Primary = \n| Identifier of string\n| Expression of Expression \n| Literal of string\n| Class of Range list \n| Dot  \n\n\/\/ToString omitted for clarity\nand SequenceItem = \n    {  \n        primaryItem: Primary; \n        itemPrefix: Prefix option;      \n        itemSuffix: Suffix option; \n    }\n\nand Sequence = SequenceItem list \n\nand Expression = Sequence list\n<\/pre>\n<p>Likewise, the AP functions to recognize Primary, SequenceItem, Sequence and Expression are anded together. For me, this is one of the hardest things to get used to about F#. But as you can see from the expressiveness of the code, it&#8217;s well worth the trouble<\/p>\n","excerpt":"<p>Now that I&#8217;ve explained the AST, there are several more semantic productions to go. I&#8217;m not going to describe them all in detail, just hit a few important highlights. Many of the semantic productions return lists of other productions. Class returns a list of Ranges, Literal and Identifier returns lists of characters, etc. As you [&hellip;]<\/p>\n","date":"2007-12-20 10:00:50","modified":"2011-04-17 16:02:26","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":209,"slug":"parsing-expression-grammar","title":"Parsing Expression Grammar","description":"","post_count":16}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["01f3a3c9-30ce-4a3c-81fa-f495e8dccab0"],"dasblog_compressedtitle":["Practical+F+Parsing+Semantic+Productions+2"],"dasblog_compressedtitleunique":["2007\/12\/20\/Practical+F+Parsing+Semantic+Productions+2"]}},"previous_url":"http:\/\/devhawk.net\/2007\/12\/19\/practical-f-parsing-the-abstract-syntax-tree\/","next_url":"http:\/\/devhawk.net\/2007\/12\/20\/f-peg-parser-next-steps\/"}