<p>If you don&#8217;t come from a <a href="http://en.wikipedia.org/wiki/Monad_%28category_theory%29">math</a> or <a href="http://en.wikipedia.org/wiki/Monad_%28symbol%29">philosophy</a> background (and I don&#8217;t) &#8220;monad&#8221; sounds like a made-up word. Of course, understanding OO&#8217;s use of terms like &#8220;class&#8221; and &#8220;object&#8221; can be hard to grok at first too. But at least those terms have some grounding in real-world concepts that non-math geeks come across. Because I couldn&#8217;t draw an analogy of monads to anything at first, it made grasping the concept of monads very hard for me.</p>
<p>It&#8217;s such a unfamiliar word that the F# team doesn&#8217;t like it either:</p>
<blockquote><p>&#8220;[W]hen the designers of F# talked with the designers of Haskell about this, they agreed that the word <em>monad</em> is a bit obscure and sounds a little daunting and that using other names might be wise.&#8221;<br>
[F# Workflows and Haskell Monads, <a href="http://www.expert-fsharp.com/default.aspx">Expert F#</a>, p232]</p></blockquote>
<p>The F# team thought about calling them workflows, but settled on <em><a href="http://research.microsoft.com/fsharp/manual/spec2.aspx#_Toc202383771">computation expression</a></em>. Frankly, I don&#8217;t like these names much better. Workflow is too easily confused with <a href="http://msdn2.microsoft.com/en-us/library/bb628617.aspx">WF</a> and if the term computation expression is way to generic. Isn&#8217;t everything in programming a computation expression? I think I&#8217;ll just stick with monad.</p>
<p>Of course, if there was a short, pithy way of describing a monad, I&#8217;m sure <em>that&#8217;s what we&#8217;d call them</em>. It&#8217;s a kinda complicated idea, so there&#8217;s no simple two or three word phrase that accurately describes it. &#8220;Sequential computation with context flow&#8221; is the best I could come up with. It&#8217;s a crappy description, but here&#8217;s an elegant example that most .NET programmers are probably already familiar with.</p>
<pre class="brush: csharp">var Orders = new List&lt;Order&gt;()

//code to populate orders omitted

var q = Orders
    .Where(x =&gt; x.OrderDate &lt; DateTime.Now)
    .OrderBy(x =&gt; x.OrderDate)
    .Select(x =&gt; new {ID = x.OrderID, Date = x.OrderDate})</pre>
<p>Yes it&#8217;s true: LINQ is a monad. The two basic concepts about a monad from my description above is that it&#8217;s a) a sequence of operations and b) there&#8217;s a context that flows from operation to operation. We see both here in this simple LINQ query. I realize I&#8217;m using what looks like a LINQ to SQL query here, but for the sake of argument let&#8217;s assume that this is all happening in memory.</p>
<p>The query is a sequence of three operations: Where, OrderBy and Select. LINQ has a set of standard query operators that you can mix and match in whatever order you need to. Part of the monad&#8217;s job is to enforce the sequence of actions. For C#, that&#8217;s not really a big deal, since it has explicit sequencing already. However, other languages like Haskell use lazy evaluation, meaning there is no explicit order of execution. Many lazy evaluation languages use monads in areas, such as I/O, where order of execution matters.</p>
<p>While C# doesn&#8217;t need any help to enforce execution order, monads are very useful in the way they flow context between the operations. In the case of LINQ, all the standard query operators take an IEnumerable&lt;T&gt; as their first parameter and return an IEnumerable&lt;T&gt;. Since they have the same inputs and outputs, they can be plugged together in whatever order is required. Yet, you don&#8217;t see any reference to GetEnumerator or the enumerator objects they return in the LINQ code above. All that code is hidden inside the LINQ query operators so the LINQ developer doesn&#8217;t have to look at it.</p>
<p>If you squint hard enough, IEnumerable kinda looks like a functional construct. It exposes a single method (GetEnumerator) and can be passed around much the same way functional languages like F# pass around first-order functions. Furthermore, the result of calling GetEnumerator is an IEnumerator object that likewise exposes one main function (MoveNext). In other words, you can think of IEnumerable sort of like a function that returns a function that you call to iterate the collection.</p>
<p>So to sum up, a monad is a sequence of operations in a specific order that automatically flows context from one operation to the next. In the LINQ example, C# has built-in constructs &#8211; IEnumerable&lt;T&gt;, foreach and yield return &#8211; that makes the monad seem less foreign (which is why I used it as my first example!) However, as we&#8217;ll see, the concepts of sequence and context flow in a monad still hold even if we&#8217;re not using built in features of C# to implement them.</p>
