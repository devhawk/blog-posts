{"status":"ok","post":{"id":1161,"type":"post","slug":"monadic-philosophy-part-2-the-linq-monad","url":"http:\/\/devhawk.net\/2008\/07\/30\/monadic-philosophy-part-2-the-linq-monad\/","status":"publish","title":"Monadic Philosophy Part 2 &#8211; The LINQ Monad","title_plain":"Monadic Philosophy Part 2 &#8211; The LINQ Monad","content":"<p>If you don&#8217;t come from a <a href=\"http:\/\/en.wikipedia.org\/wiki\/Monad_%28category_theory%29\">math<\/a> or <a href=\"http:\/\/en.wikipedia.org\/wiki\/Monad_%28symbol%29\">philosophy<\/a> background (and I don&#8217;t) &#8220;monad&#8221; sounds like a made-up word. Of course, understanding OO&#8217;s use of terms like &#8220;class&#8221; and &#8220;object&#8221; can be hard to grok at first too. But at least those terms have some grounding in real-world concepts that non-math geeks come across. Because I couldn&#8217;t draw an analogy of monads to anything at first, it made grasping the concept of monads very hard for me.<\/p>\n<p>It&#8217;s such a unfamiliar word that the F# team doesn&#8217;t like it either:<\/p>\n<blockquote><p>&#8220;[W]hen the designers of F# talked with the designers of Haskell about this, they agreed that the word <em>monad<\/em> is a bit obscure and sounds a little daunting and that using other names might be wise.&#8221;<br \/>\n[F# Workflows and Haskell Monads, <a href=\"http:\/\/www.expert-fsharp.com\/default.aspx\">Expert F#<\/a>, p232]<\/p><\/blockquote>\n<p>The F# team thought about calling them workflows, but settled on <em><a href=\"http:\/\/research.microsoft.com\/fsharp\/manual\/spec2.aspx#_Toc202383771\">computation expression<\/a><\/em>. Frankly, I don&#8217;t like these names much better. Workflow is too easily confused with <a href=\"http:\/\/msdn2.microsoft.com\/en-us\/library\/bb628617.aspx\">WF<\/a> and if the term computation expression is way to generic. Isn&#8217;t everything in programming a computation expression? I think I&#8217;ll just stick with monad.<\/p>\n<p>Of course, if there was a short, pithy way of describing a monad, I&#8217;m sure <em>that&#8217;s what we&#8217;d call them<\/em>. It&#8217;s a kinda complicated idea, so there&#8217;s no simple two or three word phrase that accurately describes it. &#8220;Sequential computation with context flow&#8221; is the best I could come up with. It&#8217;s a crappy description, but here&#8217;s an elegant example that most .NET programmers are probably already familiar with.<\/p>\n<pre class=\"brush: csharp\">var Orders = new List&lt;Order&gt;()\r\n\r\n\/\/code to populate orders omitted\r\n\r\nvar q = Orders\r\n    .Where(x =&gt; x.OrderDate &lt; DateTime.Now)\r\n    .OrderBy(x =&gt; x.OrderDate)\r\n    .Select(x =&gt; new {ID = x.OrderID, Date = x.OrderDate})<\/pre>\n<p>Yes it&#8217;s true: LINQ is a monad. The two basic concepts about a monad from my description above is that it&#8217;s a) a sequence of operations and b) there&#8217;s a context that flows from operation to operation. We see both here in this simple LINQ query. I realize I&#8217;m using what looks like a LINQ to SQL query here, but for the sake of argument let&#8217;s assume that this is all happening in memory.<\/p>\n<p>The query is a sequence of three operations: Where, OrderBy and Select. LINQ has a set of standard query operators that you can mix and match in whatever order you need to. Part of the monad&#8217;s job is to enforce the sequence of actions. For C#, that&#8217;s not really a big deal, since it has explicit sequencing already. However, other languages like Haskell use lazy evaluation, meaning there is no explicit order of execution. Many lazy evaluation languages use monads in areas, such as I\/O, where order of execution matters.<\/p>\n<p>While C# doesn&#8217;t need any help to enforce execution order, monads are very useful in the way they flow context between the operations. In the case of LINQ, all the standard query operators take an IEnumerable&lt;T&gt; as their first parameter and return an IEnumerable&lt;T&gt;. Since they have the same inputs and outputs, they can be plugged together in whatever order is required. Yet, you don&#8217;t see any reference to GetEnumerator or the enumerator objects they return in the LINQ code above. All that code is hidden inside the LINQ query operators so the LINQ developer doesn&#8217;t have to look at it.<\/p>\n<p>If you squint hard enough, IEnumerable kinda looks like a functional construct. It exposes a single method (GetEnumerator) and can be passed around much the same way functional languages like F# pass around first-order functions. Furthermore, the result of calling GetEnumerator is an IEnumerator object that likewise exposes one main function (MoveNext). In other words, you can think of IEnumerable sort of like a function that returns a function that you call to iterate the collection.<\/p>\n<p>So to sum up, a monad is a sequence of operations in a specific order that automatically flows context from one operation to the next. In the LINQ example, C# has built-in constructs &#8211; IEnumerable&lt;T&gt;, foreach and yield return &#8211; that makes the monad seem less foreign (which is why I used it as my first example!) However, as we&#8217;ll see, the concepts of sequence and context flow in a monad still hold even if we&#8217;re not using built in features of C# to implement them.<\/p>\n","excerpt":"<p>If you don&#8217;t come from a math or philosophy background (and I don&#8217;t) &#8220;monad&#8221; sounds like a made-up word. Of course, understanding OO&#8217;s use of terms like &#8220;class&#8221; and &#8220;object&#8221; can be hard to grok at first too. But at least those terms have some grounding in real-world concepts that non-math geeks come across. Because [&hellip;]<\/p>\n","date":"2008-07-30 09:53:19","modified":"2011-04-17 00:58:17","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":235,"slug":"c-sharp","title":"C#","description":"","post_count":17},{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":202,"slug":"functional-programming","title":"Functional Programming","description":"","post_count":18},{"id":267,"slug":"monads","title":"Monads","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2098,"name":"Barry Kelly","url":"http:\/\/barrkel.blogspot.com\/","date":"2008-07-30 12:33:42","content":"<p>I think programmers would understand monads better if they were described as a design pattern &#8211; anything that follows the monad rules is a monad, effectively.<\/p>\n<p>Monads are that design pattern that permits a library designer to insert himself between a user&#8217;s data and the actions a user wants to apply to that data. Rather than acting directly on data, the data is stuffed into a wrapper object, and the action desired is passed as an argument; the monad then returns a new monad that has logically applied the desired action to the wrapped-up data. The whole point behind the pattern is that the monad can subtly alter the action depending on the purpose of the monad.<\/p>\n<p>For a List monad, it&#8217;s going to apply the operation not just to one element, but to every element in the list. For a Mabye monad, it&#8217;s only going to apply the operation if the wrapper actually holds any data, and not if otherwise. For an IO monad, it&#8217;s going to return a value which logically contains a set of imperative instructions that, when finally interpreted after being returned by the main function, will perform operations with side-effects.<\/p>\n<p>The basic *design pattern* for them all is a wrapper object that takes in functions and returns a new wrapper that has logically applied the function to the contained data.<\/p>\n","parent":0},{"id":2099,"name":"Haskeller","url":"","date":"2008-07-30 13:38:53","content":"<p>I hate seeing these Microsoft shits renaming functional theory, like its Visual Basic&#8230;. <\/p>\n","parent":0},{"id":2100,"name":"atp","url":"","date":"2008-07-31 05:56:59","content":"<p>Don&#8217;t fall into the newbie trap of thinking that monads are about sequencing operations.  They aren&#8217;t.  A large number of monads (for example, Reader) are commutative and do not enforce any sort of statement ordering.<\/p>\n<p>It seems most people are first introduced to the notion of monads when attempting to do purely functional IO or stateful computations, which is too bad.  Not only are these monads extremely complex (causing the beginner to think monads are more complex in general than they really are) but they are also not representatitive.<\/p>\n<p>I think the Maybe monad and List monad are better &#8220;first monads&#8221; than State or IO.<\/p>\n","parent":0}],"attachments":[],"comment_count":3,"comment_status":"closed","custom_fields":{"dasblog_entryid":["6ce19647-2f6f-4d41-aff6-b202df528d21"],"dasblog_compressedtitle":["Monadic+Philosophy+Part+2+The+LINQ+Monad"],"dasblog_compressedtitleunique":["2008\/07\/30\/Monadic+Philosophy+Part+2+The+LINQ+Monad"]}},"previous_url":"http:\/\/devhawk.net\/2008\/07\/29\/monadic-philosophy\/","next_url":"http:\/\/devhawk.net\/2008\/07\/30\/ipy-post-2-0-roadmap-clarifications\/"}