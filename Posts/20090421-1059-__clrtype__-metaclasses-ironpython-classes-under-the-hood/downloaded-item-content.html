<p>Before we start using <a href="http://devhawk.net/2009/04/20/Introducing+Clrtype+Metaclasses.aspx">__clrtype__ metaclasses</a>, we need to understand a bit about how IronPython maps between CLR types and Python classes. IronPython doesn&#8217;t support Reflection based APIs or custom attributes today because IronPython doesn&#8217;t emit a custom CLR types for every Python class. Instead, it typically shares a single CLR type across many Python classes. For example, all three of these Python classes share a single underlying CLR type. </p>
<p></p>
<pre class="brush: python">class shop(object):
  pass 

class cheese_shop(shop):
  def have_cheese(self, cheese_type):
    return False

class argument_clinic(object):
  def is_right_room(self, room=12):
    return &quot;I've told you once&quot;

import clr
print clr.GetClrType(shop).FullName
print clr.GetClrType(cheese_shop).FullName
print clr.GetClrType(argument_clinic).FullName
</pre>
<p></p>
<p>Even though cheese_shop inherits from shop and argument_clinic inherits from object, all three classes share the same underlying CLR type. On my machine, running <a href="http://ironpython.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=22982">IronPython 2.6 Alpha 1</a>, that type is named &#8220;IronPython.NewTypes.System.Object_1$1&#8221;. </p>
<p>IronPython can share the CLR type across multiple Python classes because that CLR type has no code specific to a given Python class. CLR types are immutable &#8211; once you build a CLR type, you can&#8217;t do things like add new methods, remove existing method or change the inheritance hierarchy. But all those things are legal to do in Python. Here, I&#8217;m creating an instance of the cheese_shop class, but then changing that instance to be an argument_clinic instance instead. </p>
<pre class="brush: text">&gt;&gt;&gt; cs = cheese_shop()

&gt;&gt;&gt; cs.have_cheese(&quot;Venezuelan Beaver Cheese&quot;) 
False
&gt;&gt;&gt; cs.is_right_room(12) 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'cheese_shop' object has no attribute 'is_right_room'

&gt;&gt;&gt; # Change the object's class at runtime
&gt;&gt;&gt; cs.__class__ = argument_clinic # don't try this in C#!

&gt;&gt;&gt; cs.have_cheese(&quot;Venezuelan Beaver Cheese&quot;) 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'argument_clinic' object has no attribute 'have_cheese'
&gt;&gt;&gt; cs.is_right_room(12) 
&quot;I've told you once&quot;
</pre>
<p>When you call a method on a Python object, the name is resolved by walking a series of dictionaries. First, the dictionary of the object itself is searched for the method name. Assuming the name isn&#8217;t in the object dictionary, Python then looks in the __class__ dictionary. If it&#8217;s not there, Python recursively looks through the base classes stored in the __bases__ tuple until it finds the method or the name fails to resolve. If we re-assign __class__ at run time, we change the dictionary Python uses to resolve method names.</p>
<p>There are cases where IronPython generates a new underlying CLR type. For example, if you build a Python class that inherits from a CLR type, then IronPython will have to generate a new underlying CLR type that inherits from the CLR type in order to remain compatible. IronPython automatically overrides all the virtual methods of the base type, implementing the same dynamic method dispatch that I described above. This lets you pass the IronPython class wherever the base CLR type is expected. </p>
<p>The ability to swap Python classes at runtime depends on having the same underlying CLR type. If the underlying CLR type doesn&#8217;t match, then assigning a new value to the __class__ field of an object will fail. This applies both to IronPython classes that inherit from CLR types as well as __clrtype__ metaclass types. In the code I&#8217;ll be blogging, I always generate a unique CLR type for every Python class, which means that I can&#8217;t dynamically retype the object. Given that the point of __clrtype__ metaclasses is to generate static type information, this hardly seems like a limitation. However, it&#8217;s something to be aware of as we explore the __clrtypes__ feature.</p>
