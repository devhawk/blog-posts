{"status":"ok","post":{"id":1251,"type":"post","slug":"__clrtype__-metaclasses-ironpython-classes-under-the-hood","url":"http:\/\/devhawk.net\/2009\/04\/21\/__clrtype__-metaclasses-ironpython-classes-under-the-hood\/","status":"publish","title":"__clrtype__ Metaclasses: IronPython Classes Under the Hood","title_plain":"__clrtype__ Metaclasses: IronPython Classes Under the Hood","content":"<p>Before we start using <a href=\"http:\/\/devhawk.net\/2009\/04\/20\/Introducing+Clrtype+Metaclasses.aspx\">__clrtype__ metaclasses<\/a>, we need to understand a bit about how IronPython maps between CLR types and Python classes. IronPython doesn\u2019t support Reflection based APIs or custom attributes today because IronPython doesn\u2019t emit a custom CLR types for every Python class. Instead, it typically shares a single CLR type across many Python classes. For example, all three of these Python classes share a single underlying CLR type. <\/p>\n<\/p>\n<pre class=\"brush: python\">\nclass shop(object):\n  pass \n\nclass cheese_shop(shop):\n  def have_cheese(self, cheese_type):\n    return False\n\nclass argument_clinic(object):\n  def is_right_room(self, room=12):\n    return \"I've told you once\"\n\nimport clr\nprint clr.GetClrType(shop).FullName\nprint clr.GetClrType(cheese_shop).FullName\nprint clr.GetClrType(argument_clinic).FullName\n<\/pre>\n<\/p>\n<p>Even though cheese_shop inherits from shop and argument_clinic inherits from object, all three classes share the same underlying CLR type. On my machine, running <a href=\"http:\/\/ironpython.codeplex.com\/Release\/ProjectReleases.aspx?ReleaseId=22982\">IronPython 2.6 Alpha 1<\/a>, that type is named \u201cIronPython.NewTypes.System.Object_1$1\u201d. <\/p>\n<p>IronPython can share the CLR type across multiple Python classes because that CLR type has no code specific to a given Python class. CLR types are immutable \u2013 once you build a CLR type, you can\u2019t do things like add new methods, remove existing method or change the inheritance hierarchy. But all those things are legal to do in Python. Here, I\u2019m creating an instance of the cheese_shop class, but then changing that instance to be an argument_clinic instance instead. <\/p>\n<pre class=\"brush: text\">\n&gt;&gt;&gt; cs = cheese_shop()\n\n&gt;&gt;&gt; cs.have_cheese(\"Venezuelan Beaver Cheese\") \nFalse\n&gt;&gt;&gt; cs.is_right_room(12) \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'cheese_shop' object has no attribute 'is_right_room'\n\n&gt;&gt;&gt; # Change the object's class at runtime\n&gt;&gt;&gt; cs.__class__ = argument_clinic # don't try this in C#!\n\n&gt;&gt;&gt; cs.have_cheese(\"Venezuelan Beaver Cheese\") \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'argument_clinic' object has no attribute 'have_cheese'\n&gt;&gt;&gt; cs.is_right_room(12) \n\"I've told you once\"\n<\/pre>\n<p>When you call a method on a Python object, the name is resolved by walking a series of dictionaries. First, the dictionary of the object itself is searched for the method name. Assuming the name isn\u2019t in the object dictionary, Python then looks in the __class__ dictionary. If it\u2019s not there, Python recursively looks through the base classes stored in the __bases__ tuple until it finds the method or the name fails to resolve. If we re-assign __class__ at run time, we change the dictionary Python uses to resolve method names.<\/p>\n<p>There are cases where IronPython generates a new underlying CLR type. For example, if you build a Python class that inherits from a CLR type, then IronPython will have to generate a new underlying CLR type that inherits from the CLR type in order to remain compatible. IronPython automatically overrides all the virtual methods of the base type, implementing the same dynamic method dispatch that I described above. This lets you pass the IronPython class wherever the base CLR type is expected. <\/p>\n<p>The ability to swap Python classes at runtime depends on having the same underlying CLR type. If the underlying CLR type doesn\u2019t match, then assigning a new value to the __class__ field of an object will fail. This applies both to IronPython classes that inherit from CLR types as well as __clrtype__ metaclass types. In the code I\u2019ll be blogging, I always generate a unique CLR type for every Python class, which means that I can\u2019t dynamically retype the object. Given that the point of __clrtype__ metaclasses is to generate static type information, this hardly seems like a limitation. However, it\u2019s something to be aware of as we explore the __clrtypes__ feature.<\/p>\n","excerpt":"<p>Before we start using __clrtype__ metaclasses, we need to understand a bit about how IronPython maps between CLR types and Python classes. IronPython doesn\u2019t support Reflection based APIs or custom attributes today because IronPython doesn\u2019t emit a custom CLR types for every Python class. Instead, it typically shares a single CLR type across many Python [&hellip;]<\/p>\n","date":"2009-04-21 10:59:35","modified":"2009-04-21 10:59:35","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":281,"slug":"__clrtype__","title":"__clrtype__","description":"","post_count":9}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["2a805bcd-c55b-4251-9149-935b06a019ac"],"dasblog_compressedtitle":["clrtype+Metaclasses+IronPython+Classes+Under+The+Hood"],"dasblog_compressedtitleunique":["2009\/04\/21\/clrtype+Metaclasses+IronPython+Classes+Under+The+Hood"]}},"previous_url":"http:\/\/devhawk.net\/2009\/04\/20\/the-lounge-survey\/","next_url":"http:\/\/devhawk.net\/2009\/04\/22\/__clrtype__-metaclasses-customizing-the-type-name\/"}