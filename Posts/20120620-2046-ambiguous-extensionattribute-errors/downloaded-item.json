{"status":"ok","post":{"id":2023,"type":"post","slug":"ambiguous-extensionattribute-errors","url":"http:\/\/devhawk.net\/2012\/06\/20\/ambiguous-extensionattribute-errors\/","status":"publish","title":"Ambiguous ExtensionAttribute Errors","title_plain":"Ambiguous ExtensionAttribute Errors","content":"<p>I was recently contacted by <a href=\"http:\/\/nathanaeljones.com\/\">Nathanael Jones<\/a> of the <a href=\"http:\/\/imageresizing.net\/\">ImageResizer project<\/a> about a <a href=\"http:\/\/stackoverflow.com\/questions\/11025100\/escape-catch-22-with-extension-attributes-in-net-2-0\">question<\/a> he had posted on Stack Overflow:<\/p>\n<blockquote><p>How can a single .NET assembly, targeting 2.0, 3.0, 3.5, 4.0, and 4.5 concurrently, support extension methods for both C# and VB.NET consumers?<\/p>\n<\/blockquote>\n<p><strong>Short Answer<\/strong>: <u><em>You can\u2019t.<\/em><\/u> You think you can, but if you\u2019re serious about targeting .NET 2.0\/3.0 and 3.5+ as well as that whole C# and VB support thing, you can\u2019t. Not really. <\/p>\n<p><strong>Long Answer<\/strong>: People <em>love<\/em> extension methods. Seriously, I think some people want to marry extension methods they love them so much. They just can\u2019t stand to be without their extension methods, even when they\u2019re using .NET 2.0. <\/p>\n<p>Rather than go without, <a href=\"http:\/\/www.danielmoth.com\/Blog\/Using-Extension-Methods-In-Fx-20-Projects.aspx\">some<\/a> <a href=\"http:\/\/msdn.microsoft.com\/en-us\/magazine\/cc163317.aspx#S7\">people<\/a> <a href=\"http:\/\/www.codethinked.com\/using-extension-methods-in-net-20\">figured<\/a> <a href=\"http:\/\/kohari.org\/2008\/04\/04\/extension-methods-in-net-20\/\">out<\/a> how to get extension methods support on older versions of the .NET Runtime. Extension methods are essentially a compile time technology \u2013 the IL that gets emitted for calling an extension method is identical to the IL for calling a normal static method. The only runtime dependency for extension methods is the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.runtime.compilerservices.extensionattribute.aspx\">ExtensionAttribute<\/a> which is used to mark methods intended to be used as extension methods (as well as classes and assemblies that contain them). ExtensionAttribute is defined in System.Core from .NET 3.5, but it\u2019s just a marker. If you define your own copy of ExtensionAttribute and use the VS 2008 or later version of the C# compiler, you can get extension methods to work on .NET 2.0.<\/p>\n<p>Back when I was working on IronPython, we ran into this exact issue when we merged DLR expression trees with LINQ expression trees. LINQ trees used extension methods all over the place, but we still needed to support .NET 2.0 in IronPython. We were already using the VS08 compiler so all we had to do was add our own copy of ExtensionAttribute to the DLR and we were good to go\u2026or so we thought. Instead, <a href=\"http:\/\/devhawk.net\/2008\/09\/17\/dlr-namespace-change-fire-drill\/\">we discovered<\/a> that this approach doesn\u2019t work as advertised &#8211; at least not if you care about VB support. <\/p>\n<p>The problem stems from having multiple copies of ExtensionAttribute. IronPython and DLR had no problem \u2013 they were compiled for .NET 2.0 and thus had only the one copy of ExtensionAttribute that we added to the DLR. But people who used IronPython or DLR in a .NET 3.5 project ended up two copies of ExtensionAttribute \u2013 the copy we added to DLR and the official System.Core version. Two copies of a system provided type == start of a big problem.<\/p>\n<p>Actually, if you\u2019re only using C#, having multiple copies of ExtensionAttribute isn\u2019t that big a deal. The C# compiler raises a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/8xys0hxk.aspx\">warning<\/a> when it find multiple definitions of a type in the System namespace. Because ExtensionAttribute is in the System namespace, C# has to pick one of the colliding type definitions to use. However, since the copies of ExtensionAttribute are identical it doesn\u2019t matter which version the C# compiler picks.<\/p>\n<p>Unfortunately, Visual Basic is much less forgiving when it encounters multiple versions of the same type. Instead of a warning like C#, the VB compiler raises an <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/8f0k13d2.aspx\">error<\/a> when it encounters multiple definitions of ExtensionAttribute. So the \u201cdefine your own ExtensionAttribute\u201d approach leaves you with a DLL that won\u2019t work from VB on .NET 3.5 or later.<\/p>\n<p>Excluding VB on what was the most recent version of .NET at the time was a non starter for us, so we investigated other options. We discovered that we could \u201csolve\u201d this issue (again \u201cor so we thought\u201d) by having an internal definition of ExtensionAttribute in every assembly that needed it. Since the types weren\u2019t public, VB stopped complaining about type collisions. C# still had the compiler warning, but we had already decided not to care about that. <\/p>\n<p>I <a href=\"http:\/\/devhawk.net\/2008\/09\/17\/dlr-namespace-change-fire-drill\/\">said at the time<\/a> \u201cIt seems counterintuitive, doesn\u2019t it? To solve a multiple type definition problem, we defined even more copies of the type in question.\u201d Yeah, turns out I was kinda way wrong about that. We <a href=\"http:\/\/devhawk.net\/2008\/10\/21\/the-fifth-assembly\/\">discovered later<\/a> that having an internal ExtensionAttribute per project solved the VB ambiguous type error but introduced a new \u201cbreak all the other extension methods in the project error\u201d. <\/p>\n<p>Remember earlier when I wrote it didn\u2019t matter which copy of ExtensionAttribute the C# compiler picks because they are \u201cidentical\u201d? Remember when I wrote we could solve the VB ambiguous type error by changing the visibility of ExtensionAttribute? Woops. Changing the visibility of our ExtensionAttribute meant it was no longer identical which meant it kinda mattered which copy of ExtensionAttribute the C# compiler choose. If the C# compiler picked one of our internal ExtensionAttributes, it would break every use of extension methods in the project referencing IronPython or the DLR! <\/p>\n<p>We investigated a bunch of ways to control which version of ExtensionAttribute was selected by the C# compiler, but we couldn\u2019t find an easy, obvious way in MSBuild to control the order of references passed to the compiler. In the end, we moved the custom ExtensionAttribute into its own DLL. That way, we could reference it from our IronPython and DLR projects to get extension method support but .NET 3.5 projects referencing either IronPython or DLR could reference System.Core instead. We still got the C# warning, but since we were back to identical ExtensionAttribute&#160; definitions, the warning could be ignored. <\/p>\n<p>Believe me, if there had been any way to remove the extension methods from the DLR and IronPython, we would have done it. Having a separate assembly with just a single custom attribute definition is an ugly hack, pure and simple. But the DLR was essentially the .NET 4.0 version System.Core \u2013 getting it to run along side the .NET 3.5 version of System.Core was bound to require hacks. <\/p>\n<p>My <a href=\"http:\/\/stackoverflow.com\/a\/11113191\">advice to Nathanial on SO<\/a> was the same as I gave at the top of this post: don\u2019t use the \u201cdefine your own ExtensionAttribute\u201d hack to try and get extension method support on .NET 2.0. Extensions methods are nice, but they aren\u2019t worth the headache of dealing with the errors that stem from multiple definitions of ExtensionAttribute when you try to use your library from .NET 3.5 or later.<\/p>\n","excerpt":"<p>I was recently contacted by Nathanael Jones of the ImageResizer project about a question he had posted on Stack Overflow: How can a single .NET assembly, targeting 2.0, 3.0, 3.5, 4.0, and 4.5 concurrently, support extension methods for both C# and VB.NET consumers? Short Answer: You can\u2019t. You think you can, but if you\u2019re serious [&hellip;]<\/p>\n","date":"2012-06-20 20:46:59","modified":"2012-06-20 20:46:59","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":235,"slug":"c-sharp","title":"C#","description":"","post_count":17},{"id":310,"slug":"clr","title":"CLR","description":"","post_count":3},{"id":371,"slug":"extension-methods","title":"Extension Methods","description":"","post_count":1},{"id":224,"slug":"linq","title":"LINQ","description":"","post_count":24},{"id":263,"slug":"visual-basic","title":"Visual Basic","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":3333,"name":"jdhardy","url":"http:\/\/jdhardy.ca","date":"2012-06-22 10:23:01","content":"<p>Newer versions of IronPython solve this problem by not supporting .NET 2. 3.5 is the minimum. I&#8217;d love to make it 4.0, but the mobile platforms aren&#8217;t fully there yet.<\/p>\n","parent":0}],"attachments":[],"comment_count":1,"comment_status":"closed","custom_fields":{}},"previous_url":"http:\/\/devhawk.net\/2012\/06\/19\/windows-camp-demo-part-one\/","next_url":"http:\/\/devhawk.net\/2012\/06\/24\/windows-camp-demo-part-two\/"}