<p>I was recently contacted by <a href="http://nathanaeljones.com/">Nathanael Jones</a> of the <a href="http://imageresizing.net/">ImageResizer project</a> about a <a href="http://stackoverflow.com/questions/11025100/escape-catch-22-with-extension-attributes-in-net-2-0">question</a> he had posted on Stack Overflow:</p>
<blockquote><p>How can a single .NET assembly, targeting 2.0, 3.0, 3.5, 4.0, and 4.5 concurrently, support extension methods for both C# and VB.NET consumers?</p>
</blockquote>
<p><strong>Short Answer</strong>: <u><em>You can&#8217;t.</em></u> You think you can, but if you&#8217;re serious about targeting .NET 2.0/3.0 and 3.5+ as well as that whole C# and VB support thing, you can&#8217;t. Not really. </p>
<p><strong>Long Answer</strong>: People <em>love</em> extension methods. Seriously, I think some people want to marry extension methods they love them so much. They just can&#8217;t stand to be without their extension methods, even when they&#8217;re using .NET 2.0. </p>
<p>Rather than go without, <a href="http://www.danielmoth.com/Blog/Using-Extension-Methods-In-Fx-20-Projects.aspx">some</a> <a href="http://msdn.microsoft.com/en-us/magazine/cc163317.aspx#S7">people</a> <a href="http://www.codethinked.com/using-extension-methods-in-net-20">figured</a> <a href="http://kohari.org/2008/04/04/extension-methods-in-net-20/">out</a> how to get extension methods support on older versions of the .NET Runtime. Extension methods are essentially a compile time technology &#8211; the IL that gets emitted for calling an extension method is identical to the IL for calling a normal static method. The only runtime dependency for extension methods is the <a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.extensionattribute.aspx">ExtensionAttribute</a> which is used to mark methods intended to be used as extension methods (as well as classes and assemblies that contain them). ExtensionAttribute is defined in System.Core from .NET 3.5, but it&#8217;s just a marker. If you define your own copy of ExtensionAttribute and use the VS 2008 or later version of the C# compiler, you can get extension methods to work on .NET 2.0.</p>
<p>Back when I was working on IronPython, we ran into this exact issue when we merged DLR expression trees with LINQ expression trees. LINQ trees used extension methods all over the place, but we still needed to support .NET 2.0 in IronPython. We were already using the VS08 compiler so all we had to do was add our own copy of ExtensionAttribute to the DLR and we were good to go&#8230;or so we thought. Instead, <a href="http://devhawk.net/2008/09/17/dlr-namespace-change-fire-drill/">we discovered</a> that this approach doesn&#8217;t work as advertised &#8211; at least not if you care about VB support. </p>
<p>The problem stems from having multiple copies of ExtensionAttribute. IronPython and DLR had no problem &#8211; they were compiled for .NET 2.0 and thus had only the one copy of ExtensionAttribute that we added to the DLR. But people who used IronPython or DLR in a .NET 3.5 project ended up two copies of ExtensionAttribute &#8211; the copy we added to DLR and the official System.Core version. Two copies of a system provided type == start of a big problem.</p>
<p>Actually, if you&#8217;re only using C#, having multiple copies of ExtensionAttribute isn&#8217;t that big a deal. The C# compiler raises a <a href="http://msdn.microsoft.com/en-us/library/8xys0hxk.aspx">warning</a> when it find multiple definitions of a type in the System namespace. Because ExtensionAttribute is in the System namespace, C# has to pick one of the colliding type definitions to use. However, since the copies of ExtensionAttribute are identical it doesn&#8217;t matter which version the C# compiler picks.</p>
<p>Unfortunately, Visual Basic is much less forgiving when it encounters multiple versions of the same type. Instead of a warning like C#, the VB compiler raises an <a href="http://msdn.microsoft.com/en-us/library/8f0k13d2.aspx">error</a> when it encounters multiple definitions of ExtensionAttribute. So the &#8220;define your own ExtensionAttribute&#8221; approach leaves you with a DLL that won&#8217;t work from VB on .NET 3.5 or later.</p>
<p>Excluding VB on what was the most recent version of .NET at the time was a non starter for us, so we investigated other options. We discovered that we could &#8220;solve&#8221; this issue (again &#8220;or so we thought&#8221;) by having an internal definition of ExtensionAttribute in every assembly that needed it. Since the types weren&#8217;t public, VB stopped complaining about type collisions. C# still had the compiler warning, but we had already decided not to care about that. </p>
<p>I <a href="http://devhawk.net/2008/09/17/dlr-namespace-change-fire-drill/">said at the time</a> &#8220;It seems counterintuitive, doesn&#8217;t it? To solve a multiple type definition problem, we defined even more copies of the type in question.&#8221; Yeah, turns out I was kinda way wrong about that. We <a href="http://devhawk.net/2008/10/21/the-fifth-assembly/">discovered later</a> that having an internal ExtensionAttribute per project solved the VB ambiguous type error but introduced a new &#8220;break all the other extension methods in the project error&#8221;. </p>
<p>Remember earlier when I wrote it didn&#8217;t matter which copy of ExtensionAttribute the C# compiler picks because they are &#8220;identical&#8221;? Remember when I wrote we could solve the VB ambiguous type error by changing the visibility of ExtensionAttribute? Woops. Changing the visibility of our ExtensionAttribute meant it was no longer identical which meant it kinda mattered which copy of ExtensionAttribute the C# compiler choose. If the C# compiler picked one of our internal ExtensionAttributes, it would break every use of extension methods in the project referencing IronPython or the DLR! </p>
<p>We investigated a bunch of ways to control which version of ExtensionAttribute was selected by the C# compiler, but we couldn&#8217;t find an easy, obvious way in MSBuild to control the order of references passed to the compiler. In the end, we moved the custom ExtensionAttribute into its own DLL. That way, we could reference it from our IronPython and DLR projects to get extension method support but .NET 3.5 projects referencing either IronPython or DLR could reference System.Core instead. We still got the C# warning, but since we were back to identical ExtensionAttribute&nbsp; definitions, the warning could be ignored. </p>
<p>Believe me, if there had been any way to remove the extension methods from the DLR and IronPython, we would have done it. Having a separate assembly with just a single custom attribute definition is an ugly hack, pure and simple. But the DLR was essentially the .NET 4.0 version System.Core &#8211; getting it to run along side the .NET 3.5 version of System.Core was bound to require hacks. </p>
<p>My <a href="http://stackoverflow.com/a/11113191">advice to Nathanial on SO</a> was the same as I gave at the top of this post: don&#8217;t use the &#8220;define your own ExtensionAttribute&#8221; hack to try and get extension method support on .NET 2.0. Extensions methods are nice, but they aren&#8217;t worth the headache of dealing with the errors that stem from multiple definitions of ExtensionAttribute when you try to use your library from .NET 3.5 or later.</p>
