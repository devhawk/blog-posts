{"status":"ok","post":{"id":1279,"type":"post","slug":"compiling-python-packages-into-assemblies","url":"http:\/\/devhawk.net\/2009\/08\/10\/compiling-python-packages-into-assemblies\/","status":"publish","title":"Compiling Python Packages into Assemblies","title_plain":"Compiling Python Packages into Assemblies","content":"<p><a href=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/970048722e75_E4A5\/image_5.png\" class=\"grouped_elements\" rel=\"tc-fancybox-group1279\"><img style=\"border-right-width: 0px; margin: 0px 5px 0px 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px\" title=\"image\" border=\"0\" alt=\"image\" align=\"left\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/970048722e75_E4A5\/image_thumb.png\" width=\"144\" height=\"260\" \/><\/a> In looking at my <a href=\"http:\/\/devhawk.net\/2009\/08\/10\/Building+A+Hybrid+C+IronPython+App+Without+Dynamic+Type.aspx\">hybrid IronPython \/ C# Windows Live Writer plugin<\/a>, we\u2019re going to start at the bottom with the Pygments package. Typically Python packages are a physical on-disk folder that contain a collection of Python files (aka modules). And during early development of Pygments for WLWriter, that\u2019s exactly how I used it. However, when it can time for deployment, I figured it would be much easier if I packaged up the <a href=\"http:\/\/github.com\/devhawk\/pygments.wlwriter\/tree\/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e\/pygments_package\/pygments\">Pygments package<\/a>, <a href=\"http:\/\/github.com\/devhawk\/pygments.wlwriter\/blob\/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e\/pygments_package\/devhawk_formatter.py\">my custom HTML formatter<\/a> and the <a href=\"http:\/\/github.com\/devhawk\/pygments.wlwriter\/tree\/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e\/pygments_package\/pygments_dependencies\">standard library modules that Pygments depends on<\/a> into a single assembly.<\/p>\n<p>IronPython ships with a script named <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/57861#758946\">pyc<\/a> for compiling Python files into .NET assemblies. However, pyc is pretty much just a wrapper around the clr module CompileModules function. I wrote my <a href=\"http:\/\/github.com\/devhawk\/pygments.wlwriter\/blob\/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e\/pygments_package\/build_pygments.py\">own custom script<\/a> to build the Pygments assembly from the files in a the pygments and pygments_dependencies folders.<\/p>\n<\/p>\n<pre class=\"brush: python\">\nfrom System import IO\nfrom System.IO.Path import Combine\n\ndef walk(folder):\n  for file in IO.Directory.GetFiles(folder):\n    yield file\n  for folder in IO.Directory.GetDirectories(folder):\n    for file in walk(folder): yield file\n  \nfolder = IO.Path.GetDirectoryName(__file__)\n\npygments_files = list(walk(Combine(folder, 'pygments')))\npygments_dependencies = list(walk(Combine(folder,'pygments_dependencies')))\n\nall_files = pygments_files + pygments_dependencies\nall_files.append(IO.Path.Combine(folder, 'devhawk_formatter.py'))\n\nimport clr\nclr.CompileModules(Combine(folder, \"..externalpygments.dll\"), *all_files)\n<\/pre>\n<\/p>\n<p>Most of this code is a custom implementation of <a href=\"http:\/\/docs.python.org\/library\/os.html#os.walk\">walk<\/a>. I have all the <a href=\"http:\/\/github.com\/devhawk\/pygments.wlwriter\/tree\/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e\/External\">IronPython and DLR dlls<\/a> including ipy.exe checked into my source tree, but I don\u2019t have the standard library checked in. Other than that, the code is pretty straight forward \u2013 collect a bunch of files in a list and call CompileModules.<\/p>\n<p>The problem with this approach is that IronPython isn\u2019t doing any kind of dependency checking when we compile the assembly. If you pass just the contents of the Pygments package into CompileModules, it will emit an assembly but that assembly will still depend on some modules in the standard library. If those aren\u2019t available, the Pygments assembly won\u2019t load. I\u2019d <em>love<\/em> to have an automatic tool to determine module dependencies, but since I didn\u2019t have such a tool I used a brute-force, by-hand solution. I wrote a <a href=\"http:\/\/github.com\/devhawk\/pygments.wlwriter\/blob\/2c9cbb7f777d66d5ad615bb71201dc6c181ef18e\/External\/test_compiled_pygments.py\">small script<\/a> to exercise the Pygments assembly. If there were any missing dependencies, test_compiled_pygments would throw an exception indicating the missing module. For each missing dependency, I copied over the missing dependency, recompiled to project and tried again. Lather, rinse, repeat. Not fun, but Pygments only depended on seven standard library modules so it didn\u2019t end up taking that long. <\/p>\n<p>So having gone down this path of compiling Python files into an assembly, would I do it again? For an application with an installer like this one, yes no question. I added the Pygments assembly as a reference to my C# library and it got added to the installer automatically. That was much easier than managing all of the Pygments files and its dependencies in the installer project manually. Plus, I still would have had to manually figure out the dependencies unless I chose to include the entire standard library.<\/p>\n<p>I will point out that the compiled Pygments assembly is the largest single file in my deployed solution. It clocks in at 2.25MB. That\u2019s about twice the size of the Python files that I compiled it from. So clearly, I\u2019m paying for the convenience of deploying a single file in space and maybe load time. [1] I\u2019m also paying in space for a private copy of IronPython and the DLR \u2013 the two IronPython and five DLR assemblies clock in around 3.16MB. In comparison, the actual Writer plugin assembly itself is only about 25KB! But for an installed desktop app like a WLWriter plugin, 5MB of assorted infrastructure isn\u2019t worth worrying about compared to the hassle of ensuring a shared copy of IronPython is installed. I mean, even if you don\u2019t know IronPython exists, you can still install and use Pygments for WLWriter. Simplifying the install process is easily worth 5MB in storage space on the user\u2019s computer in my opinion.<\/p>\n<p>Next up, we\u2019ll look at the Python half of the PygmentsCodeSource component, which calls into this compiled Pygments library. <\/p>\n<hr \/>\n<p>[1] I haven\u2019t done it, but it would be interesting to compare the load time for the single larger pygments assembly vs. loading and parsing the Python files individually. If I had to guess, I\u2019m thinking the single assembly would load faster even though it\u2019s bigger since there\u2019s less overhead (only loading one big file vs. lots of small ones) and you skip the parsing step. But that\u2019s pure guesswork on my part.<\/p>\n","excerpt":"<p>In looking at my hybrid IronPython \/ C# Windows Live Writer plugin, we\u2019re going to start at the bottom with the Pygments package. Typically Python packages are a physical on-disk folder that contain a collection of Python files (aka modules). And during early development of Pygments for WLWriter, that\u2019s exactly how I used it. However, [&hellip;]<\/p>\n","date":"2009-08-10 11:16:41","modified":"2009-08-10 11:16:41","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":231,"slug":"dlr","title":"DLR","description":"","post_count":25},{"id":285,"slug":"pygments","title":"Pygments","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["058b7415-e1e2-43e8-b6ed-6d9e67a32e1f"],"dasblog_compressedtitle":["Compiling+Python+Packages+Into+Assemblies"],"dasblog_compressedtitleunique":["2009\/08\/10\/Compiling+Python+Packages+Into+Assemblies"]}},"previous_url":"http:\/\/devhawk.net\/2009\/08\/10\/building-a-hybrid-c-ironpython-app-without-dynamic-type\/","next_url":"http:\/\/devhawk.net\/2009\/08\/11\/embedding-python-scripts-in-c-applications\/"}