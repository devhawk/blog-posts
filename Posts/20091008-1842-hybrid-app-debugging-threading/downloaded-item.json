{"status":"ok","post":{"id":1295,"type":"post","slug":"hybrid-app-debugging-threading","url":"http:\/\/devhawk.net\/2009\/10\/08\/hybrid-app-debugging-threading\/","status":"publish","title":"Hybrid App Debugging &#8211; Threading","title_plain":"Hybrid App Debugging &#8211; Threading","content":"<p>I <a href=\"http:\/\/devhawk.net\/2009\/10\/07\/Hybrid+App+Debugging+Ndash+TracebackDelegate+And+SetTrace.aspx\">added traceback<\/a> to my GetThings app in just two lines of code, but so far it doesn\u2019t actually do anything that you would expect a debugger to do. But before we get to that, we need understand a little about how threading works for traceback debugging.<\/p>\n<p>As I mentioned last time, the traceback debugger works by calling into the registered traceback handler at various times (entering\/exiting a function, before executing a line of code and on exceptions). Execution of the Python code continues when the traceback function exits. That means that you have to block the execution thread while you let the user poke around with the debugger UI. For a console based app, that\u2019s easy. For a GUI app, not so much.<\/p>\n<p>At a minimum, you need to run your debugger UI on a separate thread from your main app window. If you want your main app window to be responsive while you debug, you\u2019ll need to pump messages at a minimum (<a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.windows.forms.application.doevents.aspx\">DoEvents<\/a> in Windows Forms, <a href=\"http:\/\/social.msdn.microsoft.com\/forums\/en-US\/wpf\/thread\/a2988ae8-e7b8-4a62-a34f-b851aaf13886\">similar approaches are available<\/a> for WPF) or preferably run your python scripts on a background thread separate from either the main window UI thread or the debugger UI thread. To keep things simple, I\u2019m going to simply block the main window thread while the debugger is active.<\/p>\n<p>Since I\u2019m going to have to setup a new thread for the debugger window, I decided to use a static constructor to centralize creating the thread, creating the window and registering the traceback handler all in one place.<\/p>\n<\/p>\n<pre class=\"brush: csharp\">\nstatic Thread _debugThread;\nstatic DebugWindow _debugWindow;\nstatic ManualResetEvent _debugWindowReady = new ManualResetEvent(false);\n\npublic static void InitDebugWindow(ScriptEngine engine)\n{\n    _debugThread = new Thread(() =&gt;\n    {\n        _debugWindow = new DebugWindow(engine);\n        _debugWindow.Show();\n        Dispatcher.Run();\n    });\n    _debugThread.SetApartmentState(ApartmentState.STA);\n    _debugThread.Start();\n\n    _debugWindowReady.WaitOne();\n    engine.SetTrace(_debugWindow.OnTracebackReceived);\n}\n<\/pre>\n<\/p>\n<p>As you can see, InitDebugWindow spins up a new thread and creates the debug window on that thread. Since it\u2019s not the main WPF application thread, you have to explicitly call <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.windows.threading.dispatcher.run.aspx\">Dispatcher.Run<\/a> to get the event queue pumping. You also have to explicitly <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.thread.setapartmentstate.aspx\">set the apartment state<\/a> to be single threaded for any threads creating WPF objects. Finally, I wait for the window to signal that it\u2019s ready (it set\u2019s the _debugWindowReady AutoResetEvent in the Window Loaded event) and then call SetTrace, passing in the debug window\u2019s OnTracebackReceived event, on the thread that called InitDebugWindow.<\/p>\n<p>It\u2019s critical that you call SetTrace \u2013 and thus InitDebugWindow \u2013 on the thread that\u2019s going to execute the Python code. Debugging in Python is <em>per thread<\/em>. Even if you execute the same code in the same ScriptScope with the same ScriptEngine but on a different thread, the traceback handler calls won\u2019t fire. The way DebugWindow is written, it will only support debugging a single thread, but it would be pretty straightforward to support multiple threads by changing the way OnTracebackReceived gets signaled to continue.<\/p>\n<p>Speaking of OnTracebackReceived, this was my initial basic implementation of it:<\/p>\n<\/p>\n<pre class=\"brush: csharp\">\nprivate TracebackDelegate OnTracebackReceived\n    (TraceBackFrame frame, string result, object payload)\n{\n    Action&lt;TraceBackFrame, string, object&gt; tbAction = this.OnTraceback;\n    this.Dispatcher.BeginInvoke(tbAction, frame, result, payload);\n    _dbgContinue.WaitOne();\n    return this.OnTracebackReceived;\n}\n<\/pre>\n<\/p>\n<p>As we saw, the DebugWindow is running on a different thread than the traceback handler call will come in on. So OnTracebackReceived needs to invoke a new call on the correct thread by using <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.windows.threading.dispatcher.begininvoke.aspx\">Dispatcher.BeginInvoke<\/a>. Even though OnTracebackReceived is always called on the main window thread, it still has access to the properties of the debug window thread like its Dispatcher. I used BeginInvoke to invoke OnTraceback asynchronously \u2013 OnTraceback isn\u2019t going to return anything interesting and we\u2019re going to wait on an AutoResetEvent before continuing anyway so I didn\u2019t see any reason to use a synchronous call. <\/p>\n<p>We\u2019ll discuss OnTraceback more next post, but basically it will configure the UI for the traceback event that happened. Then DebugWindow will wait for user input. When the user indicates they want to resume execution, the command handler in question will set _dbgContinue and the original traceback will return so execution can continue. <\/p>\n","excerpt":"<p>I added traceback to my GetThings app in just two lines of code, but so far it doesn\u2019t actually do anything that you would expect a debugger to do. But before we get to that, we need understand a little about how threading works for traceback debugging. As I mentioned last time, the traceback debugger [&hellip;]<\/p>\n","date":"2009-10-08 18:42:38","modified":"2009-10-08 18:42:38","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23},{"id":291,"slug":"lightweight-debugger","title":"Lightweight Debugger","description":"","post_count":5},{"id":293,"slug":"polyglot","title":"Polyglot","description":"","post_count":3}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["d69568b9-9021-46d6-aeb4-0e1bb554fbf1"],"dasblog_compressedtitle":["Hybrid+App+Debugging+Ndash+Threading"],"dasblog_compressedtitleunique":["2009\/10\/09\/Hybrid+App+Debugging+Ndash+Threading"]}},"previous_url":"http:\/\/devhawk.net\/2009\/10\/07\/hybrid-app-debugging-aside-the-dlr-hosting-api\/","next_url":"http:\/\/devhawk.net\/2009\/10\/09\/hybrid-app-debugging-the-debug-window\/"}