<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>The Two Types of Service Architects</title>
  <link>http://devhawk.net/2006/11/01/the-two-types-of-service-architects/</link>
  <pubDate>Wed, 01 Nov 2006 15:44:18 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://d6fd829a-6770-489a-b276-72c972083f53</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Tomas Restrepo <a href="http://www.winterdom.com/weblog/2006/10/29/WCFAndDuplexChannels.aspx">comments</a> on my recent SSB and WCF posts:</p><blockquote><p><a href="http://www.winterdom.com/weblog/ct.ashx?id=d948c914-95e1-4fe1-ba48-392fd6468be7&amp;url=http%3a%2f%2fdevhawk.net%2f">Harry Pierson</a> asks how well <a href="http://www.winterdom.com/weblog/ct.ashx?id=d948c914-95e1-4fe1-ba48-392fd6468be7&amp;url=http%3a%2f%2fdevhawk.net%2f2006%2f10%2f29%2fIs%2bWCF%2bQuotStraightforwardquot%2bFor%2bLong%2bRunning%2bTasks.aspx">WCF supports long running tasks</a>. He suggests that WCF does not support them very well, and says that's one reason he likes SQL Server Service Broker so much. I'd say SSSB is a good match only as long as the long running tasks you're going to be executing are purely database driven and can be executed completely within the database. Sure, this is an "expanded universe" with the CLR support in SQL Server 2005, but even so it makes me nervous at times <img src="http://www.winterdom.com/weblog/smilies/happy.gif" />. </p><p>You could also consider using a custom service with MSMQ or something like BizTalk Server for this if you had long running processes that were not completely tied to the DB (or a single DB for that matter).</p></blockquote><p>Sam Gentile <a href="http://feeds.feedburner.com/~r/SamGentile/~3/43478464/New-and-Notable-118.aspx">follows up</a>:</p><blockquote><p>In that same post, but I needed to call it out separate, Tomas rightfully says, "I'd say SSSB is a good match only as long as the long running tasks you're going to be executing are purely database driven and can be executed completely within the database," in response to <a href="http://devhawk.net/2006/10/29/Is+WCF+QuotStraightforwardquot+For+Long+Running+Tasks.aspx">Harry liking Service Broker so much</a>. Talk about a narrow edge case. That's way I never really got excited or cared about Service Broker. Its a narrow solution to a special edge case when everything is database driven and can be executed totally inside the database. That's the old Microsoft Data-Driven Architecture for sure. Me, I'd rather have a rich Domain-Driven architecture most of the time. Then if you have Oracle databases in your architecture too, where does it leave you? Nowhere.</p></blockquote><p>As you might expect, I have a few comments,  clarifications and corrections.</p><p>First, Tomas' statement that Service Broker only supports service logic "executed completely within the database" in flat out wrong. Service Broker can be used from any environment that can connect to SQL Server and execute DML statements. If you can call SELECT/INSERT/UPDATE/DELETE, then you can also call BEGIN DIALOG/SEND/RECEIVE/END CONVERSATION. This includes Windows apps and services, web apps and services, console apps and even <a href="http://msdn.microsoft.com/data/ref/jdbc/">Java apps</a>. Of course, you can also access Service Broker from stored procedures if you wish, but you're not limited to them as Tomas suggested. </p><p>Tomas' misconception may come from a feature of Service Broker called <a href="http://msdn2.microsoft.com/en-us/library/ms171617.aspx">Activation</a>. Activation is a feature of Service Broker that <a href="http://msdn2.microsoft.com/en-us/library/ms171601.aspx">dynamically scales message processing to match demand</a>. For example, Service Broker can be configured to launch a new instance of a specified stored procedure if messaging processing isn't keeping up with incoming message traffic on a given queue. This is called <a href="http://msdn2.microsoft.com/en-us/library/ms171585.aspx">internal activation</a> and because it uses stored procedures it does execute within the database as Thomas said. Service Broker also supports <a href="http://msdn2.microsoft.com/en-us/library/ms171581.aspx">external activation</a> where it notifies an external application when activation is needed. You do have to build an application to host your service logic and handle these notifications, but that application doesn't execute within the database. So while you could argue that it's easier to execute your service logic within the database (no need to build a separate host app), it's not required.</p><p>Given that you don't have host your service logic in the database, then you're also not limited to "a single DB" as Tomas suggests. You don't, in fact, have to put your Service Broker queues in the same database with your business data. So if you have Oracle in your environment, like the scenario Sam mentioned, you would host your service logic in an external application that processed messages from a queue in a SQL 2005 database while accessing and modifying business data from tables in the Oracle database. Using multiple databases does require using distributed instead of local transactions, but if you're using MSMQ as Tomas recommended, you're already stuck with the DTC anyway. </p><p>Finally, I didn't get Tomas' "purely database driven" or Sam's "everything is database driven" comments at all. While there are exceptions, the vast majority of systems I've ever seen/built/designed have essentially been one or more stateless tiers sitting in front of a stateful database. If it's a traditional three tier web app, there's a stateless presentation tier, a stateless business logic tier and a stateless data access logic tier. For a web service, there's no presentation tier, but there's is the stateless SOAP processing tier typically provided by the web service stack. Does this mean the vast majority of web apps and services are  "purely database driven" too? If so, then I guess it's a good thing, right?</p><p>In the end, maybe there are two types of service architects - those that believe the majority of services will be atomic and those that believe the majority of services will be long running. For atomic services, Service Broker is overkill. But if it turns out that most services are long running, <a href="http://devhawk.net/2006/10/29/Is+WCF+QuotStraightforwardquot+For+Long+Running+Tasks.aspx">WCF's lack of support</a> is going to be a pretty big roadblock. </p><p>I'm obviously in the long running camp. I'm not sure, but I get the feeling this is the less popular camp, at least for now. We'll have to wait to see, but I do know is that whenever someone brings me what they think is an atomic business scenario, it doesn't take much digging to reveal that the atomic scenario is actually a single step of a long running business scenario that also needs to be automated. </p><p>Here's a question for Tomas, Sam and the rest of you: Which group do you self select into? Are most services going to be atomic or long running in the (pardon the pun) long run?</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">826</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2006-11-01 15:44:18</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2006-11-01 15:44:18</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">the-two-types-of-service-architects</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="service-broker"><![CDATA[Service Broker]]></category>
  <category domain="post_tag" nicename="soa"><![CDATA[SOA]]></category>
  <category domain="post_tag" nicename="wcf"><![CDATA[WCF]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[d6fd829a-6770-489a-b276-72c972083f53]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2006/11/01/The+Two+Types+Of+Service+Architects]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[The+Two+Types+Of+Service+Architects]]></wp:meta_value>
  </wp:postmeta>
</item>