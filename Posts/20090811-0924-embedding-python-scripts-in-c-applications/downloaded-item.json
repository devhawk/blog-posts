{"status":"ok","post":{"id":1280,"type":"post","slug":"embedding-python-scripts-in-c-applications","url":"http:\/\/devhawk.net\/2009\/08\/11\/embedding-python-scripts-in-c-applications\/","status":"publish","title":"Embedding Python Scripts in C# Applications","title_plain":"Embedding Python Scripts in C# Applications","content":"<p><img style=\"border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px\" title=\"image\" border=\"0\" alt=\"image\" align=\"left\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/8d7a6d959c67_6D72\/image_thumb_1.png\" width=\"133\" height=\"240\" \/><\/p>\n<p>Now that I\u2019ve got Pygments and its dependencies <a href=\"http:\/\/devhawk.net\/2009\/08\/10\/Compiling+Python+Packages+Into+Assemblies.aspx\">packaged up in an easy-to-distribute assembly<\/a>, I need to be able to call it from C#. However, if you pop open pygments.dll in Reflector, you\u2019ll notice it\u2019s not exactly intuitive to access. Lots of compiler generated names like pygments$12 and StringIO$64 in a type named DLRCachedCode. Clearly, this code isn\u2019t intended to be used by anything except the IronPython runtime. <\/p>\n<p>So we better create one of those IronPython runtime thingies.<\/p>\n<p>As you can see in the layer diagram to the left, PygmentsCodeSource is split into two parts \u2013 a C# part and a Python part. The Python part is very simple \u2013 just importing a couple of Pygments functions into the global namespace and a simple helper function to generate syntax highlighted HTML from a given block of code in a given language and style. The code itself is pretty simple. Note the reference to the pygments assembly I described last post. Here\u2019s the entire file:<\/p>\n<pre class=\"brush: python\">\nimport clr\nclr.AddReference(\"pygments\")       \n\nfrom pygments.lexers import get_all_lexers       \nfrom pygments.styles import get_all_styles       \n\ndef generate_html(code, lexer_name, style_name):       \n  from pygments import highlight       \n  from pygments.lexers import get_lexer_by_name       \n  from pygments.styles import get_style_by_name       \n  from devhawk_formatter import DevHawkHtmlFormatter       \n\n  if not lexer_name: lexer_name = \"text\"\n  if not style_name: style_name = \"default\"\n  lexer = get_lexer_by_name(lexer_name)       \n  return highlight(code, lexer, DevHawkHtmlFormatter(style=style_name))\n<\/pre>\n<p>Instead of including this in the Pygments assembly, I embedded this file as a resource in my C# assembly. This way, I could use the standard DLR hosting APIs to create a script source and execute this code. I did have to build a concrete StreamContentProvider class to wrap the resource stream in, but otherwise, it\u2019s pretty straight forward. <\/p>\n<pre class=\"brush: csharp\">\nstatic ScriptEngine _engine;      \nstatic ScriptSource _source;      \n\nprivate void InitializeHosting()      \n{\n    _engine = IronPython.Hosting.Python.CreateEngine();      \n\n    var asm = System.Reflection.Assembly.GetExecutingAssembly();      \n    var stream = asm.GetManifestResourceStream(      \n                   \"DevHawk.PygmentsCodeSource.py\");      \n    _source = _engine.CreateScriptSource(      \n                new BasicStreamContentProvider(stream),  \n                \"PygmentsCodeSource.py\");      \n}\n<\/pre>\n<p>Once I got the engine and script source set up, all that remains is setup a script scope to execute the script source in. For this specific application, it\u2019s probably overkill to have a scope per instance \u2013 I think the syntax highlighting process is stateless so a single scope should be easily shared across multiple PygmentsCodeSource instances. But I didn\u2019t take any chances, I created a script scope per instance to execute the source in.<\/p>\n<pre class=\"brush: csharp\">\nScriptScope _scope;     \nThread _init_thread;      \n\npublic PygmentsCodeSource()      \n{\n    if (_engine == null)      \n        InitializeHosting();      \n\n     _scope = _engine.CreateScope();      \n\n    _init_thread = new Thread(() =&gt; { _source.Execute(_scope); });      \n    _init_thread.Start();      \n}\n<\/pre>\n<p>You\u2019ll notice that I\u2019m executing the source in the scope on a background thread. That\u2019s because it takes a while to execute, especially the first time. However, I don\u2019t actually use the Python code until after the user types or copies a block of code into the UI and presses OK. In my experience, executing the Python code is typically finished by the time I get code into the box and press OK. I just need to make sure I add an _init_thread.Join guard anywhere I\u2019m going to access the _scope to be sure the initialization is complete before I try to use it.<\/p>\n<p>In the next, and last, post in this small series we\u2019ll see how to invoke Python functions in the _scope I initialized above from C#.<\/p>\n","excerpt":"<p>Now that I\u2019ve got Pygments and its dependencies packaged up in an easy-to-distribute assembly, I need to be able to call it from C#. However, if you pop open pygments.dll in Reflector, you\u2019ll notice it\u2019s not exactly intuitive to access. Lots of compiler generated names like pygments$12 and StringIO$64 in a type named DLRCachedCode. Clearly, [&hellip;]<\/p>\n","date":"2009-08-11 09:24:42","modified":"2009-08-11 09:24:42","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":231,"slug":"dlr","title":"DLR","description":"","post_count":25},{"id":285,"slug":"pygments","title":"Pygments","description":"","post_count":5}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2251,"name":"Randall Sutton","url":"http:\/\/blog.randallsutton.net","date":"2009-08-11 09:50:12","content":"<p>Good Post.  Seems like managing the engine\/scope startup time is the biggest issue when executing python scripts from C#.<\/p>\n","parent":0}],"attachments":[],"comment_count":1,"comment_status":"closed","custom_fields":{"dasblog_entryid":["ac6fe2e5-6c82-4898-8ee3-1bde31026655"],"dasblog_compressedtitle":["Embedding+Python+Scripts+In+C+Applications"],"dasblog_compressedtitleunique":["2009\/08\/11\/Embedding+Python+Scripts+In+C+Applications"]}},"previous_url":"http:\/\/devhawk.net\/2009\/08\/10\/compiling-python-packages-into-assemblies\/","next_url":"http:\/\/devhawk.net\/2009\/08\/12\/invoking-python-functions-from-c-without-dynamic\/"}