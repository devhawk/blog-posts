{"status":"ok","post":{"id":877,"type":"post","slug":"perusing-powershell-part-2-error-or-no-output","url":"http:\/\/devhawk.net\/2007\/02\/07\/perusing-powershell-part-2-error-or-no-output\/","status":"publish","title":"Perusing Powershell Part 2: Error or No Output?","title_plain":"Perusing Powershell Part 2: Error or No Output?","content":"<p>In <a href=\"http:\/\/devhawk.net\/2007\/02\/06\/Perusing+Powershell+Part+1+GetSQLServer.aspx\">yesterday&#8217;s post on PS<\/a>, I provided the source for my implementation of Get-SQLServer. I realized after I made the post that there was a significant bug in the ProcessRecord method. If you specify a service instance (default or named), the cmdlet makes no effort to actually validate that such a SQL server instance exists. So if you ask for a instance that doesn&#8217;t exist, Get-SQLServer will happily write an\u00a0invalid Server object to the pipeline. So I changed it to actually validate that the specified instance exists. I connect to the specified machine (local machine if not specified) using <a href=\"http:\/\/msdn2.microsoft.com\/library\/microsoft.sqlserver.management.smo.wmi.managedcomputer.aspx\">ManagedComputer<\/a> and look in it&#8217;s ServerInstances collection for the specified SQL instance.<\/p>\n<p>The question is, what should you do if the specified SQL instance <em>doesn&#8217;t<\/em> exist on the specified machine? One the one hand, you could <a href=\"http:\/\/msdn2.microsoft.com\/library\/system.management.automation.cmdlet.writeerror.aspx\">write an error<\/a> indicating that the SQL instance doesn&#8217;t exist. Or, you could simply write nothing to the output pipeline, which may cause an error down the line.<\/p>\n<p>Which is the right approach?<\/p>\n<p>At first, I wrote an error when I couldn&#8217;t find the instance, but decided that wasn&#8217;t the right approach. It isn&#8217;t really an error unless you attempt to act on that instance, right? So I thought the more PS friendly approach would be to write nothing and let the down stream cmdlets deal with it. I do <a href=\"http:\/\/msdn2.microsoft.com\/library\/system.management.automation.cmdlet.writedebug.aspx\">write a debug message<\/a> if the specified instance doesn&#8217;t exist, so the scripter isn&#8217;t completely in the dark.<\/p>\n<p>So here&#8217;s the new and improved ProcessRecord method of my Get-SQLServer cmdlet:<\/p>\n<p>&nbsp;<\/p>\n<pre class=\"brush:csharp\">protected override void ProcessRecord() \r\n{ \r\n    \/\/Make sure both -Name and -Default aren\u2019t specified\r\n    if (!string.IsNullOrEmpty(_Name) &amp;&amp; _Default.IsPresent) \r\n    { \r\n        WriteError(new ErrorRecord( \r\n            new ArgumentException( \r\n                \u201cDefault and Name parameters can\u2019t both be specified\u201d),\r\n            \u201cDefaultAndName\u201d, \r\n            ErrorCategory.InvalidArgument, \r\n            null));\r\n        return; \r\n    }\r\n\r\n    \/\/If the machine name is not specified, assume the local machine \r\n    \/\/(via the \u201c.\u201d value)\r\n    string machine = string.IsNullOrEmpty(_MachineName) ? \u201c.\u201d : _MachineName;\r\n\r\n    \/\/Connect to the specified machine via the SMO WMI ManagedComputer object\r\n    SmoWmi.ManagedComputer mc = new SmoWmi.ManagedComputer(machine);\r\n\r\n    if (string.IsNullOrEmpty(_Name) &amp;&amp; !_Default.IsPresent) \r\n    { \r\n        \/\/If neither Name or Default are specified, write all the \r\n        \/\/server instances on specified machine\r\n        foreach (SmoWmi.ServerInstance si in mc.ServerInstances) \r\n            WriteServerObject(si);\r\n\r\n        return; \r\n    }\r\n\r\n    string instanceName = _Default.IsPresent ? \u201cMSSQLSERVER\u201d : _Name;\r\n\r\n    if (mc.ServerInstances.Contains(instanceName)) \r\n        WriteServerObject(mc.ServerInstances[instanceName]); \r\n    else\r\n        WriteDebug(\u201cThe specified SQL instance does not exist\u201d); \r\n}\r\n\r\n\/\/Helper method to create a SMO Server object from a \r\n\/\/SMO WMI ServerInstance object and write it to the pipeline\r\nprivate void WriteServerObject(SmoWmi.ServerInstance si) \r\n{ \r\n    if (si.Name == \u201cMSSQLSERVER\u201d) \r\n        WriteObject(new Smo.Server(si.Parent.Name)); \r\n    else\r\n        WriteObject(new Smo.Server(si.Parent.Name + \u201c\\\u201d + si.Name));\r\n}<\/pre>\n<p>&nbsp;<\/p>\n<p>&nbsp;<\/p>\n","excerpt":"<p>In yesterday&#8217;s post on PS, I provided the source for my implementation of Get-SQLServer. I realized after I made the post that there was a significant bug in the ProcessRecord method. If you specify a service instance (default or named), the cmdlet makes no effort to actually validate that such a SQL server instance exists. [&hellip;]<\/p>\n","date":"2007-02-07 12:00:35","modified":"2011-04-17 00:12:04","categories":[],"tags":[{"id":230,"slug":"powershell","title":"PowerShell","description":"","post_count":41}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["99d7e902-9225-48e9-89f9-c390ce84afff"],"dasblog_compressedtitle":["Perusing+Powershell+Part+2+Error+Or+No+Output"],"dasblog_compressedtitleunique":["2007\/02\/07\/Perusing+Powershell+Part+2+Error+Or+No+Output"]}},"previous_url":"http:\/\/devhawk.net\/2007\/02\/07\/morning-coffee-26\/","next_url":"http:\/\/devhawk.net\/2007\/02\/08\/morning-coffee-27\/"}