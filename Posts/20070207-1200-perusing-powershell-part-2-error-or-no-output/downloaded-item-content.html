<p>In <a href="http://devhawk.net/2007/02/06/Perusing+Powershell+Part+1+GetSQLServer.aspx">yesterday&#8217;s post on PS</a>, I provided the source for my implementation of Get-SQLServer. I realized after I made the post that there was a significant bug in the ProcessRecord method. If you specify a service instance (default or named), the cmdlet makes no effort to actually validate that such a SQL server instance exists. So if you ask for a instance that doesn&#8217;t exist, Get-SQLServer will happily write an&nbsp;invalid Server object to the pipeline. So I changed it to actually validate that the specified instance exists. I connect to the specified machine (local machine if not specified) using <a href="http://msdn2.microsoft.com/library/microsoft.sqlserver.management.smo.wmi.managedcomputer.aspx">ManagedComputer</a> and look in it&#8217;s ServerInstances collection for the specified SQL instance.</p>
<p>The question is, what should you do if the specified SQL instance <em>doesn&#8217;t</em> exist on the specified machine? One the one hand, you could <a href="http://msdn2.microsoft.com/library/system.management.automation.cmdlet.writeerror.aspx">write an error</a> indicating that the SQL instance doesn&#8217;t exist. Or, you could simply write nothing to the output pipeline, which may cause an error down the line.</p>
<p>Which is the right approach?</p>
<p>At first, I wrote an error when I couldn&#8217;t find the instance, but decided that wasn&#8217;t the right approach. It isn&#8217;t really an error unless you attempt to act on that instance, right? So I thought the more PS friendly approach would be to write nothing and let the down stream cmdlets deal with it. I do <a href="http://msdn2.microsoft.com/library/system.management.automation.cmdlet.writedebug.aspx">write a debug message</a> if the specified instance doesn&#8217;t exist, so the scripter isn&#8217;t completely in the dark.</p>
<p>So here&#8217;s the new and improved ProcessRecord method of my Get-SQLServer cmdlet:</p>
<p>&nbsp;</p>
<pre class="brush:csharp">protected override void ProcessRecord() 
{ 
    //Make sure both -Name and -Default aren&#8217;t specified
    if (!string.IsNullOrEmpty(_Name) &amp;&amp; _Default.IsPresent) 
    { 
        WriteError(new ErrorRecord( 
            new ArgumentException( 
                &#8220;Default and Name parameters can&#8217;t both be specified&#8221;),
            &#8220;DefaultAndName&#8221;, 
            ErrorCategory.InvalidArgument, 
            null));
        return; 
    }

    //If the machine name is not specified, assume the local machine 
    //(via the &#8220;.&#8221; value)
    string machine = string.IsNullOrEmpty(_MachineName) ? &#8220;.&#8221; : _MachineName;

    //Connect to the specified machine via the SMO WMI ManagedComputer object
    SmoWmi.ManagedComputer mc = new SmoWmi.ManagedComputer(machine);

    if (string.IsNullOrEmpty(_Name) &amp;&amp; !_Default.IsPresent) 
    { 
        //If neither Name or Default are specified, write all the 
        //server instances on specified machine
        foreach (SmoWmi.ServerInstance si in mc.ServerInstances) 
            WriteServerObject(si);

        return; 
    }

    string instanceName = _Default.IsPresent ? &#8220;MSSQLSERVER&#8221; : _Name;

    if (mc.ServerInstances.Contains(instanceName)) 
        WriteServerObject(mc.ServerInstances[instanceName]); 
    else
        WriteDebug(&#8220;The specified SQL instance does not exist&#8221;); 
}

//Helper method to create a SMO Server object from a 
//SMO WMI ServerInstance object and write it to the pipeline
private void WriteServerObject(SmoWmi.ServerInstance si) 
{ 
    if (si.Name == &#8220;MSSQLSERVER&#8221;) 
        WriteObject(new Smo.Server(si.Parent.Name)); 
    else
        WriteObject(new Smo.Server(si.Parent.Name + &#8220;\&#8221; + si.Name));
}</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
