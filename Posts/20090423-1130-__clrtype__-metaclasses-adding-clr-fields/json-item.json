{"status":"ok","post":{"id":1253,"type":"post","slug":"__clrtype__-metaclasses-adding-clr-fields","url":"http:\/\/devhawk.net\/2009\/04\/23\/__clrtype__-metaclasses-adding-clr-fields\/","status":"publish","title":"__clrtype__ Metaclasses: Adding CLR Fields","title_plain":"__clrtype__ Metaclasses: Adding CLR Fields","content":"<p>Now that we have the <a href=\"http:\/\/devhawk.net\/2009\/04\/22\/clrtype+Metaclasses+Customizing+The+Type+Name.aspx\">basic __clrtype__ metaclass infrastructure<\/a> in place, let\u2019s enhance it to add support for CLR fields. To do this, we\u2019re going to need to add two things to our custom CLR type. First, we need to define the fields themselves. Second, we need to make sure that Python code will read and writes to the statically typed fields for the specified names rather than the storing them in the object dictionary as usual. Here\u2019s the updated version of ClrTypeMetaclass (or you can get it <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/browse.aspx\/DevHawk%20Content\/IronPython%20Stuff\/%7C_%7C_clrtype%7C_%7C_\">from my skydrive<\/a>)<\/p>\n<pre class=\"brush: python\">\nclass ClrTypeMetaclass(type):\n  def __clrtype__(cls):\n    baseType = super(ClrTypeMetaclass, cls).__clrtype__()\n    typename = cls._clrnamespace + \".\" + cls.__name__ \n                 if hasattr(cls, \"_clrnamespace\") \n                 else cls.__name__\n                 \n    typegen = Snippets.Shared.DefineType(typename, baseType, True, False)\n    typebld = typegen.TypeBuilder\n\n    for ctor in baseType.GetConstructors(): \n      ctorparams = ctor.GetParameters()\n      ctorbld = typebld.DefineConstructor(\n                  ctor.Attributes,\n                  ctor.CallingConvention,\n                  tuple([p.ParameterType for p in ctorparams]))\n      ilgen = ctorbld.GetILGenerator()\n      ilgen.Emit(OpCodes.Ldarg, 0)\n      for index in range(len(ctorparams)):\n        ilgen.Emit(OpCodes.Ldarg, index + 1)\n      ilgen.Emit(OpCodes.Call, ctor)\n      ilgen.Emit(OpCodes.Ret)\n\n    if hasattr(cls, \"_clrfields\"):\n      for fldname in cls._clrfields: \n        typebld.DefineField(\n          fldname, \n          clr.GetClrType(cls._clrfields[fldname]), \n          FieldAttributes.Public)\n          \n    new_type = typebld.CreateType()\n    \n    if hasattr(cls, \"_clrfields\"):\n      for fldname in cls._clrfields: \n        fldinfo = new_type.GetField(fldname)\n        setattr(cls, fldname, ReflectedField(fldinfo))\n        \n    return new_type\n<\/pre>\n<p>All the base type, type name, type builder and constructor code in the first half of the __clrtype__ method is the same as last time, so we\u2019ll focus on the second half. After emitting the constructor(s), next we iterate thru a dictionary named _clrfields (if it exists in the class) that maps field names to types. For each of these dictionary entries, we emit a public field on the CLR type with the specified name and type. <\/p>\n<p>The first time I tried this, I simply added the custom field generation code I just described and left it at that. Didn\u2019t work. Python doesn\u2019t look to store information in fields defined by the static type metadata unless explicitly instructed to. That\u2019s why I need to iterate over the declared list of fields a second time after the type has been created. The first time creates the CLR fields, the second time inserts a <a href=\"http:\/\/ironpython.codeplex.com\/SourceControl\/changeset\/view\/49291#384587\">ReflectedField<\/a> instance into the class dictionary. ReflectedField is a <a href=\"http:\/\/docs.python.org\/reference\/datamodel.html#implementing-descriptors\">Python descriptor<\/a> that reads and writes the field value by calling <a href=\"http:\/\/msdn.microsoft.com\/library\/system.reflection.fieldinfo.getvalue.aspx\">GetValue<\/a> and <a href=\"http:\/\/msdn.microsoft.com\/library\/system.reflection.fieldinfo.setvalue.aspx\">SetValue<\/a> on the contained <a href=\"http:\/\/msdn.microsoft.com\/library\/system.reflection.fieldinfo.aspx\">FieldInfo object<\/a>. Python uses the same name resolution for fields as it does for method (In Python, methods are fields that store callable objects) so when IronPython discovers the ReflectedField descriptor in the class instance, it uses that to get or store the value rather than sticking it in the local dictionary.<\/p>\n<p>Now here\u2019s the new version of the Product class, this time with CLR fields as well as a custom type name:<\/p>\n<pre class=\"brush: python\">\nclass Product(object):\n  __metaclass__ = ClrTypeMetaclass\n  _clrnamespace = \"DevHawk.IronPython.ClrTypeSeries\"   \n  _clrfields = {\n    \"name\":str,\n    \"cost\":float,\n    \"quantity\":int,\n    }\n    \n  def __init__(self, name, cost, quantity):\n    self.name = name\n    self.cost = cost\n    self.quantity = quantity\n    \n  def calc_total(self):\n    return self.cost * self.quantity\n<\/pre>\n<p>As you can see, the only thing that\u2019s changed is the addition of the _clrfields dictionary. But now, we can use reflection to get and set the Product fields, like so:<\/p>\n<pre class=\"brush: text\">\n&gt;&gt;&gt; p = Product(\"Crunchy Frog\", 5.99, 10)\n&gt;&gt;&gt; t = p.GetType()\n&gt;&gt;&gt; p.name\n'Crunchy Frog'\n&gt;&gt;&gt; namefi = t.GetField(\"name\")\n&gt;&gt;&gt; namefi.GetValue(p)\n'Crunchy Frog'\n&gt;&gt;&gt; namefi.SetValue(p, \"Spring Surprise\")\n&gt;&gt;&gt; p.name\n'Spring Surprise'\n<\/pre>\n<p>This is great progress, but not enough to get us to our first \u201creal\u201d scenario: data binding in Silverlight. Silverlight only supports data binding against public properties, so I\u2019ll need to wrap all these CLR fields in CLR properties in my next post.<\/p>\n","excerpt":"<p>Now that we have the basic __clrtype__ metaclass infrastructure in place, let\u2019s enhance it to add support for CLR fields. To do this, we\u2019re going to need to add two things to our custom CLR type. First, we need to define the fields themselves. Second, we need to make sure that Python code will read [&hellip;]<\/p>\n","date":"2009-04-23 11:30:07","modified":"2009-04-23 11:30:07","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":281,"slug":"__clrtype__","title":"__clrtype__","description":"","post_count":9}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2199,"name":"Mark","url":"","date":"2009-04-23 12:36:10","content":"<p>Does the DLR cache the type or will each new instance of the &#8220;Product&#8221; class that is created, also result in the overhead of the ClrTypeMetaclass being executed?<\/p>\n","parent":0},{"id":2200,"name":"DevHawk","url":"","date":"2009-04-24 13:55:42","content":"<p>The CLR type only gets created once, when the associated Python class is created. We don&#8217;t have the overhead of type creation for every Python class instance that gets created.<\/p>\n","parent":0}],"attachments":[],"comment_count":2,"comment_status":"closed","custom_fields":{"dasblog_entryid":["81b7f1ae-7663-4f84-88b7-4dc9de78102f"],"dasblog_compressedtitle":["clrtype+Metaclasses+Adding+CLR+Fields"],"dasblog_compressedtitleunique":["2009\/04\/23\/clrtype+Metaclasses+Adding+CLR+Fields"]}},"previous_url":"http:\/\/devhawk.net\/2009\/04\/22\/__clrtype__-metaclasses-customizing-the-type-name\/","next_url":"http:\/\/devhawk.net\/2009\/04\/24\/__clrtype__-metaclasses-adding-clr-properties\/"}