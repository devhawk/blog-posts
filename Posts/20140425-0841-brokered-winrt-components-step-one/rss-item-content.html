In this step, we’ll build the brokered component itself. Frankly, the only thing that makes a brokered component different than a normal WinRT component is some small tweaks to the project file to enable access to the full .NET Runtime and Base Class Library. The <a href="http://msdn.microsoft.com/en-us/library/windows/apps/dn630195.aspx">brokered component whitepaper</a> describes the these tweaks in detail, but the new <a href="http://visualstudiogallery.msdn.microsoft.com/527286e4-b06a-4234-adde-d313c9c3c23e">brokered component template</a> takes care of these small tweaks for you.

<a href="http://devhawk.net/wp-content/uploads/2014/04/BRT_NewProject.png"><img class="wp-image-2096 alignleft" alt="BRT_NewProject" src="http://devhawk.net/wp-content/uploads/2014/04/BRT_NewProject-300x207.png" width="180" height="124" /></a>Start by selecting File -&gt; New -&gt; Project in Visual Studio. With the sheer number of templates to choose from these days, I find it’s easier to just search for the one I want. Type “broker” in the search box in the upper left, you’ll end up with two choices – the brokered WinRT component and the brokered WinRT proxy/stub. For now, choose the brokered component. We’ll be adding a brokered proxy/stub <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">in step two</a>. Name the project whatever you want. I named mine “HelloWorldBRT”.

This is probably the easiest step of the three as there’s nothing really special you have to do – just write managed code like you always do. In my keynote demo, this is where I wrote the code that wrapped the existing ADO.NET based data access library. For the purposes of this walkthrough, let’s do something simpler. We’ll use P/Invoke to retrieve the current <a href="http://msdn.microsoft.com/en-us/library/windows/apps/ms683180.aspx">process</a> and <a href="http://msdn.microsoft.com/en-us/library/windows/apps/ms683183.aspx">thread</a> IDs. These Win32 APIs are <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br205762.aspx">supported for developing WinRT apps</a> and will make it obvious that the component is running in a separate process than the app. Here’s the simple code to retrieve those IDs (hat tip to <a href="http://www.pinvoke.net">pinvoke.net</a> for the interop signatures):
<pre class="brush:csharp">public sealed class Class
{
    [DllImport("kernel32.dll")]
    static extern uint GetCurrentThreadId();

    [DllImport("kernel32.dll")]
    static extern uint GetCurrentProcessId();

    public uint CurrentThreadId
    {
        get { return GetCurrentThreadId(); }
    }

    public uint CurrentProcessId
    {
        get { return GetCurrentProcessId(); }
    }
}</pre>
That’s it! I didn’t even bother to change the class name for this simple sample.

Now, to be clear, there’s no reason why this code needs to run in a broker process. As I pointed out, the Win32 functions I’m wrapping here are supported for use in Windows Store apps. For this walkthrough, I’m trying to keep the code simple in order to focus on the specifics of building brokered components. If you want to see an example that actually leverages the fact that it’s running outside of the App Container, check out the NorthwindRT sample.

In the <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">next step</a>, we'll add the proxy/stub that enables this component to communicate across a process boundary.