{"status":"ok","post":{"id":1078,"type":"post","slug":"practical-f-parsing-syntactical-productions-2","url":"http:\/\/devhawk.net\/2007\/12\/17\/practical-f-parsing-syntactical-productions-2\/","status":"publish","title":"Practical F# Parsing : Syntactical Productions (2)","title_plain":"Practical F# Parsing : Syntactical Productions (2)","content":"<p>Now that I&#8217;ve moved over to <a href=\"http:\/\/devhawk.net\/2007\/12\/14\/Practical+F+Parsing+Active+Patterns.aspx\" target=\"_blank\">Active Patterns<\/a>, I want to go back and finish the syntactic productions for my PEG parser. Most of the syntactic productions are very straightforward when implemented in AP. We&#8217;ve seen EndOfFile, EndOfLine and Space already. There is also a series of symbol identifiers that have only a single match clause. For example, here&#8217;s DOT:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/DOT &lt;- '.' Spacing\nlet (|DOT|_|) input = \n    match input with\n    | TOKEN \".\" (Spacing(input)) -&gt; Some(input)\n    | _ -&gt; None\n<\/pre>\n<p>I&#8217;m not going to go thru all the symbol AP functions since their all basically like this one. However, you&#8217;ll notice that this function references an AP we haven&#8217;t seen yet &#8211; Spacing. I want to close out the section on Syntactical Productions by looking at the Spacing and Comment productions. Since Spacing depends on Comment, I&#8217;ll start with Comment.<\/p>\n<p>Comments in PEG grammars are single lines that start with a # symbol, similar to the \/\/ line comments in F# and C#. This is the PEG grammar rule for Comment:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Comment &lt;- '#' (!EndOfLine .)* EndOfLine\n<\/pre>\n<p>Basically, this says that a comment starts with a #, then matches zero or more characters that are not EndOfLine, and ends with an EndOfLine. The exclamation point is a <em>syntactic predicate<\/em>, which means that we unconditionally backtrack after attempting to match. PEG has both a success and failure syntactic predicate &#8211; the ! is the failure predicate while &amp; is the success predicate. So inside the parens, this production rule says to test the current point in the parse buffer for EndOfLine. If it finds it, the match fails and we exit out of the parens (where we match EndOfLine again without backtracking it this time). If it doesn&#8217;t find it, the parser backtracks, consumes the next character regardless what it is, then repeats. <\/p>\n<p>Unfortunately, there&#8217;s a bug in this production. If the parse buffer ends in a comment, the production will fail since it hasn&#8217;t reached the EndOfLine and there are no more characters to consume. So I changed the production to:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Comment &lt;- '#' ((!EndOfLine \/ !EndOfFile) .)* EndOfLine?\n<\/pre>\n<p>This rule now ends the comment if it reaches an EndOfLine or EndOfFile. Additionally, it makes the final EndOfLine match optional. So if the comment ends with a new line, the new line is consumed as part of the grammar production. If the comment ends with the end of file, the EndOfFile is not consumed as part of the production. If you&#8217;ll recall, EndOfFile returns Some(unit) rather than Some(char list). In F#, the various branches of a match clause have to have the same return type, so you can&#8217;t return Some() from one branch and Some(input) from another. It&#8217;s no big deal &#8211; you use the EndOfFile production at the top-level grammar to ensure you&#8217;ve consumed the entire file anyway.<\/p>\n<p>Here&#8217;s the F# implementation of Comment:<\/p>\n<p>Comment defines a local AP function called CommentContent, which implements the part of the grammar production inside the parens. <\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Comment &lt;- '#' ((!EndOfLine \/ !EndOfFile) .)* EndOfLine?\nlet (|Comment|_|) input =  \n    let rec (|CommentContent|_|) input =  \n        match input with\n        | EndOfLine (input) -&gt; Some(input)\n        | EndOfFile -&gt; Some(input)\n        | NC (_,input) -&gt; (|CommentContent|_|) input \n        | _ -&gt; None \n    match input with\n    | TOKEN \"#\" (CommentContent (input)) -&gt; Some(input)\n    | _ -&gt; None\n<\/pre>\n<p>Local AP function CommentContent recurses thru the input buffer after the pound sign, looking for\u00a0 EndOfLine or EndOfFile. This function should never match the final default clause, but I put it in to keep the compiler from complaining. Notice that I use symbol redefinition here so both EndOf match clauses return Some(input). For EndOfLine, I&#8217;m re-defining input to mean what is returned by EndOfLine. For EndOfFile, I&#8217;m not re-defining, so input still means the list that is passed into the pattern match statement. <\/p>\n<p>Compared to Comment, Spacing is pretty trivial:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/Spacing &lt;- (Space \/ Comment)*\nlet rec (|Spacing|) input =  \n    match input with\n    | Space (input) -&gt; (|Spacing|) input \n    | Comment (input) -&gt; (|Spacing|) input \n    | _ -&gt; input\n<\/pre>\n<p>There are two things I want to call out about spacing. First, it&#8217;s a recursive function, so it&#8217;s defined with let rec. AP functions can be recursive, just like normal functions. Also, note the lack of an underscore in the name of this AP function. Spacing is defined as zero or more spaces or comments, so it&#8217;s perfectly valid to match nothing. Thus, Spacing is always a successful match. In this case, we don&#8217;t put the underscore in the AP function name and we don&#8217;t wrap the return result in Some(). You&#8217;ll notice the last match clause simply returns input, rather than Some(input). <\/p>\n<p>That&#8217;s all the syntactic predicates. Next up, the meat of the grammar: semantic predicates.<\/p>\n","excerpt":"<p>Now that I&#8217;ve moved over to Active Patterns, I want to go back and finish the syntactic productions for my PEG parser. Most of the syntactic productions are very straightforward when implemented in AP. We&#8217;ve seen EndOfFile, EndOfLine and Space already. There is also a series of symbol identifiers that have only a single match [&hellip;]<\/p>\n","date":"2007-12-17 11:38:42","modified":"2011-04-17 16:02:55","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":209,"slug":"parsing-expression-grammar","title":"Parsing Expression Grammar","description":"","post_count":16}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["4e0fb8db-ee03-4d19-a87b-42d5c7796a3e"],"dasblog_compressedtitle":["Practical+F+Parsing+Syntactical+Productions+2"],"dasblog_compressedtitleunique":["2007\/12\/17\/Practical+F+Parsing+Syntactical+Productions+2"]}},"previous_url":"http:\/\/devhawk.net\/2007\/12\/17\/morning-coffee-131\/","next_url":"http:\/\/devhawk.net\/2007\/12\/18\/practical-f-parsing-semantic-productions-1\/"}