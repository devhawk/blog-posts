{"status":"ok","post":{"id":1070,"type":"post","slug":"practical-parsing-in-f","url":"http:\/\/devhawk.net\/2007\/12\/10\/practical-parsing-in-f\/","status":"publish","title":"Practical Parsing in F#","title_plain":"Practical Parsing in F#","content":"<p>I&#8217;m interested in parsing because I&#8217;m interested in Domain Specific Languages. F# is <a href=\"http:\/\/tomasp.net\/blog\/fsharp-iv-lang.aspx\">pretty good for internal DSLs<\/a>, but internal DSLs are obviously limited by the syntax of the host language. If you want complete control over the language, you&#8217;ve got to build your own parser.<\/p>\n<p>The defacto standard for parser development is <a href=\"http:\/\/en.wikipedia.org\/wiki\/Yacc\">Yet Another Compiler Compiler<\/a>, or yacc. There&#8217;s a version of <a href=\"http:\/\/devhawk.net\/2006\/09\/17\/Managed+Lex+And+Yacc.aspx\">yacc for .NET<\/a> as well as one <a href=\"http:\/\/research.microsoft.com\/fsharp\/manual\/parsing.aspx\">specifically for F#<\/a>. However, I&#8217;m not a fan of yacc. Yacc parsers are specified using <a href=\"http:\/\/en.wikipedia.org\/wiki\/Context-free_grammar\">context-free grammar<\/a> (aka CFG). But CFG&#8217;s can be ambiguous &#8211; actually, it&#8217;s <a href=\"http:\/\/en.wikipedia.org\/wiki\/Dangling_else\">nearly impossible<\/a> to build an unambiguous CFG. Personally, I&#8217;m a big fan of <a href=\"http:\/\/pdos.csail.mit.edu\/~baford\/packrat\/\">Parsing Expression Grammars<\/a> (or PEGs) which among other advantages makes it impossible to develop ambiguous grammars. Furthermore, PEGs don&#8217;t require a separate lexical analyzer like <a href=\"http:\/\/en.wikipedia.org\/wiki\/Lex_programming_tool\">lex<\/a>, so I think they&#8217;re more suitable for building <a href=\"http:\/\/devhawk.net\/2006\/08\/15\/Modular+Compilers.aspx\">modular compilers<\/a>.<\/p>\n<p>Since I like PEGs and F# so much, I developed a parser for the PEG grammar from the <a href=\"http:\/\/pdos.csail.mit.edu\/~baford\/packrat\/popl04\/\">original PEG whitepaper<\/a> using F#. The grammar is much simpler than a language like C#, but with twenty nine grammar productions it&#8217;s certainly not trivial. The F# implementation is fairly straightforward backtracking recursive decent parser, which makes it easy to understand even if you&#8217;re not a parser guru. It&#8217;s also small &#8211; around 400 lines of code including comments. But I think the code illustrates both the general value of Functional Programming as well as the specific value of F#. Here&#8217;s how the series is shaping up (though this is subject to change):<\/p>\n<ul>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/11\/Practical+F+Parsing+The+Parse+Buffer.aspx\" target=\"_blank\">The Parse Buffer<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/12\/Practical+F+Parsing+Unit+Testing.aspx\" target=\"_blank\">Unit Testing<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/13\/Practical+F+Parsing+Syntactical+Productions+1.aspx\" target=\"_blank\">Syntactical Productions (1)<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/14\/Practical+F+Parsing+Active+Patterns.aspx\">Active Patterns<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/17\/Practical+F+Parsing+Syntactical+Productions+2.aspx\" target=\"_blank\">Syntactical Productions (2)<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/18\/Practical+F+Parsing+Semantic+Productions+1.aspx\" target=\"_blank\">Semantic Productions (1)<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/18\/Practical+F+Parsing+Semantic+Productions+1.aspx\" target=\"_blank\"><\/a><a href=\"http:\/\/devhawk.net\/2007\/12\/19\/Practical+F+Parsing+The+Abstract+Syntax+Tree.aspx\" target=\"_blank\">The Abstract Syntax Tree<\/a><\/li>\n<li><a href=\"http:\/\/devhawk.net\/2007\/12\/20\/Practical+F+Parsing+Semantic+Productions+2.aspx\" target=\"_blank\">Semantic Productions (2)<\/a><\/li>\n<li><a class=\"TitleLinkStyle\" rel=\"bookmark\" href=\"http:\/\/devhawk.net\/2008\/01\/29\/Practical+F+Parsing+Recursion+And+Predicate+Functions.aspx\"><span style=\"color: #017cbc;\">Recursion and Predicate Functions<\/span><\/a><\/li>\n<li>Caching and Tracing<\/li>\n<li>C# Interop<\/li>\n<\/ul>\n<p>I was originally planning to post the code for the parser itself with this post. However, i find that I&#8217;m revising the code as I write the articles in this series, so I&#8217;m going to hold off for now. If you&#8217;re really desperate, <a href=\"mailto:harry@devhawk.net\" target=\"_blank\">drop me a line<\/a> and I&#8217;ll see what I can do.<\/p>\n<p>Update &#8211; Almost forgot, if you&#8217;re going to follow along at home, I&#8217;m using the <a href=\"http:\/\/research.microsoft.com\/research\/downloads\/Details\/e8478d6b-49c0-4750-80eb-0e424d1631a3\/Details.aspx\">latest version of F#, v1.9.3.7<\/a>. Note, the <a href=\"http:\/\/research.microsoft.com\/fsharp\/release.aspx\">F# Downloads page<\/a> on the MS Research is woefully out of date, so go to the <a href=\"http:\/\/research.microsoft.com\/research\/downloads\/Browse.aspx?categoryID=0&amp;sortCriteria=releaseDate&amp;sortOrder=descending\">MS Research Downloads page<\/a>. Currently, it&#8217;s the most recent release. It snaps into VS 2005 and 2008 plus has command line tools. If you&#8217;re an VS Express user, Douglas Stockwell <a href=\"http:\/\/11011.net\/archives\/000721.html\">explained<\/a> how to roll your own F# Express.<\/p>\n<p>Much Later Update &#8211; The code is now available <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/browse.aspx\/DevHawk%20Content\/Projects\/Practical%20Parsing%20in%20F%7C3\" target=\"_blank\">on my Skydrive<\/a>.<\/p>\n","excerpt":"<p>I&#8217;m interested in parsing because I&#8217;m interested in Domain Specific Languages. F# is pretty good for internal DSLs, but internal DSLs are obviously limited by the syntax of the host language. If you want complete control over the language, you&#8217;ve got to build your own parser. The defacto standard for parser development is Yet Another [&hellip;]<\/p>\n","date":"2007-12-10 14:40:10","modified":"2011-04-17 16:04:36","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":208,"slug":"domain-specific-languages","title":"Domain Specific Languages","description":"","post_count":15},{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":209,"slug":"parsing-expression-grammar","title":"Parsing Expression Grammar","description":"","post_count":16}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2004,"name":"Tomas Restrepo","url":"http:\/\/www.winterdom.com\/weblog\/","date":"2007-12-10 15:38:24","content":"<p>Pretty cool Harry, looking forward to the rest of the posts and the code!<\/p>\n","parent":0}],"attachments":[],"comment_count":1,"comment_status":"closed","custom_fields":{"dasblog_entryid":["e65ad3ba-088c-4b8b-88e6-e3d273fb7711"],"dasblog_compressedtitle":["Practical+Parsing+In+F"],"dasblog_compressedtitleunique":["2007\/12\/10\/Practical+Parsing+In+F"]}},"previous_url":"http:\/\/devhawk.net\/2007\/12\/10\/morning-coffee-129\/","next_url":"http:\/\/devhawk.net\/2007\/12\/10\/ado-net-data-services-and-idempotence\/"}