{"status":"ok","post":{"id":1224,"type":"post","slug":"writing-an-ironpython-debugger-dynamic-stack-trace","url":"http:\/\/devhawk.net\/2009\/03\/09\/writing-an-ironpython-debugger-dynamic-stack-trace\/","status":"publish","title":"Writing an IronPython Debugger: Dynamic Stack Trace","title_plain":"Writing an IronPython Debugger: Dynamic Stack Trace","content":"<p>Now that I can <a href=\"http:\/\/devhawk.net\/2009\/03\/04\/Writing+And+IronPython+Debugger+Adding+Interactivity.aspx\">interact with my debugger<\/a>, it\u2019s time to add a command. I decided to start with something simple \u2013 or at least something I thought would be simple &#8211; printing a stack trace.<\/p>\n<p>In the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms404520.aspx\">unmanaged debugger API<\/a>, threads have the concept of both <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms233401.aspx\">stack chains<\/a> and <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms230151.aspx\">stack frames<\/a>. A stack chain represents a segment of the physical stack. In a typical managed app, you\u2019ll have at least two stack chains: the unmanaged stack chain and the managed stack chain. You can interate through the stack chains for a given thread via the Chains property. However, ipydbg is a managed only debugger, so I can ignore the unmanaged stack chain. Instead, I just retrieve the current (managed) chain via the thread\u2019s ActiveChain property.<\/p>\n<p>Within a managed stack chain, there is a collection of stack frames. This is the call stack that managed developers are typically used to working with. It turns out that printing a raw stack trace is very easy to do. Here was my first stab at it:<\/p>\n<pre class=\"brush: python\">elif k.Key == ConsoleKey.T:     \r\n  print \"nManaged Stack Trace\"\r\n  for f in active_thread.ActiveChain.Frames:     \r\n    offset, sp = get_location(f)     \r\n    metadata_import = CorMetadataImport(f.Function.Module)     \r\n    method_info = metadata_import.GetMethodInfo(f.FunctionToken)     \r\n    print \"  \",      \r\n      \"%s::%s --\" % (method_info.DeclaringType.Name, method_info.Name),      \r\n      sp if sp != None else \"(offset %d)\" % offset<\/pre>\n<p>This elif block is part of the input method I showed last time. It loops thru the frames in the Active Chain of the active thread and prints some data to the console. As I said, pretty easy. Of course, the devil is in the details.<\/p>\n<p>First detail I should call out is that active_thread variable. <a href=\"http:\/\/blogs.msdn.com\/jmstall\/archive\/2006\/03\/21\/attach_asyncbreak.aspx\">As per Mike Stall<\/a>, \u201cthere is no notion of &#8220;active thread&#8221; in the underlying debug APIs. It&#8217;s purely a construct in a debugger UI to make it easier for end-users.\u201d My console based UI may be rudimentary, but it\u2019s still a UI. Events like OnBreakpoint include the active thread as a event argument, so I stash that away in a variable so it\u2019ll be available to the input loop.<\/p>\n<p>Second detail is the call to get_location. When we <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/blob\/112c3acdcf726c3ad89ce2def8258ecc2fb55513\/ipydbg.py#L50\">last saw get_location<\/a>, it was returning a formatted string. Since my last post, I\u2019ve refactored the code so it returns the raw location data \u2013 a tuple of the raw IP offset and the associated sequence point, if available. I\u2019ve also added a __str__ method to my sequence point object, so when I print it to the console, I get the filename and line nicely formatted.<\/p>\n<p>Finally, there\u2019s all CorMetadataImport code. In addition to wrapping the unmanaged debugger API, CorDebug also wraps the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms404384.aspx\">unmanaged metadata API<\/a>. This code lets me get <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.methodinfo.aspx\">MethodInfo<\/a> compatible view of the function metadata for a given stack frame. I use it here to get the type and function name for each frame on the stack.<\/p>\n<p>The end result looks something like this. Note, I\u2019ve replaced \u201cMicrosoft.Scripting\u201d with \u201cMS.Scripting\u201d to avoid word wrapping.<\/p>\n<pre class=\"brush:plain\">OnBreakpoint Initialize Location: simpletest.py:1 (offset: 84) \r\n\u00bb t \r\nManaged Stack Trace \r\n   S$2::Initialize simpletest.py:1 (offset: 84) \r\n   MS.Scripting.Runtime.OptimizedScriptCode::InvokeTarget (offset 72) \r\n   MS.Scripting.ScriptCode::Run (offset 0) \r\n   IronPython.Hosting.PythonCommandLine::RunFileWorker (offset 77) \r\n   IronPython.Hosting.PythonCommandLine::RunFile (offset 15) \r\n   MS.Scripting.Hosting.Shell.CommandLine::Run (offset 46) \r\n   IronPython.Hosting.PythonCommandLine::Run (offset 240) \r\n   MS.Scripting.Hosting.Shell.CommandLine::Run (offset 74) \r\n   MS.Scripting.Hosting.Shell.ConsoleHost::RunCommandLine (offset 158) \r\n   MS.Scripting.Hosting.Shell.ConsoleHost::ExecuteInternal (offset 32) \r\n   MS.Scripting.Hosting.Shell.ConsoleHost::Execute (offset 63) \r\n   MS.Scripting.Hosting.Shell.ConsoleHost::Run (offset 390) \r\n   PythonConsoleHost::Main \u2014 (offset 125)<\/pre>\n<p>As we can see, we may be on the first line of the python script, but we\u2019ve got a pretty deep stack trace already. Everything but the top-most frame are from the underlying IronPython implementation. Those extra frames obscure the stack frames I actually care about, so it would be nice to hide any stack frames from IronPython or the DLR. It\u2019s easy enough to write a python generator function that filters out frames that from the DLR or IronPython namespaces. In order to get the type name, we need the method_info like we did above. I\u2019ve factored that code into a separate function in order to avoid code duplication.<\/p>\n<pre class=\"brush: python\">def get_method_info_for_frame(frame)     \r\n    if frame.FrameType != CorFrameType.ILFrame:     \r\n      return None\r\n    metadata_import = CorMetadataImport(frame.Function.Module)     \r\n    return metadata_import.GetMethodInfo(frame.FunctionToken)     \r\n\r\ndef get_dynamic_frames(chain):     \r\n  for f in chain.Frames:     \r\n    method_info = get_method_info_for_frame(f)     \r\n    if method_info == None:     \r\n      continue\r\n    typename = method_info.DeclaringType.Name     \r\n    if typename.startswith(\"Microsoft.Scripting.\")      \r\n      or typename.startswith(\"IronPython.\")      \r\n      or typename == \"PythonConsoleHost\":     \r\n        continue\r\n    yield f<\/pre>\n<p>You\u2019ll notice I\u2019ve added a guard to get_method_info_for_frame in order to ensure that the frame argument is an IL Frame. There are <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/blob\/dab527c9bb39e61cc4a464d840db8ee6a2aef753\/CorDebug\/CorDebug\/Thread.cs#L272\">three types of stack frames<\/a> in the debugger API: <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms232990.aspx\">IL<\/a>, native and <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/ms232469.aspx\">internal<\/a>. Most of the frames we\u2019re dealing with are IL frames, but you do run into the occasional <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.dynamicmethod.aspx\">lightweight function<\/a> (i.e. <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.dynamicmethod.aspx\">DynamicMethod<\/a>) frame when debugging IronPython code. Typically, IronPython generates DynamicMethods for all python code except for a few cases related to .NET interop. However, you can\u2019t debug DynamicMethods, so when you run with \u2013D, we generate normal non-dynamic methods instead. However, even when running with \u2013D, we still use DynamicMethods for call site dispatch. Since they\u2019re an implementation detail, we want to filter those out in get_dynamic_frames too.<\/p>\n<p>This gives us a much more manageable stack trace:<\/p>\n<pre class=\"brush:plain\">OnBreakpoint Initialize Location: simpletest.py:1 (offset: 84) \r\n\u00bb t \r\nStack Trace \r\n   S$2::Initialize -- simpletest.py:1 (offset: 84)<\/pre>\n<p>As usual, the <a href=\"http:\/\/github.com\/devhawk\/ipydbg\/blob\/c33cf75c4e9273a21ada00abe2403c392e4ca0a0\/ipydbg.py\">latest ipydbg source<\/a> is up on GitHub.<\/p>\n","excerpt":"<p>Now that I can interact with my debugger, it\u2019s time to add a command. I decided to start with something simple \u2013 or at least something I thought would be simple &#8211; printing a stack trace. In the unmanaged debugger API, threads have the concept of both stack chains and stack frames. A stack chain [&hellip;]<\/p>\n","date":"2009-03-09 15:10:02","modified":"2011-04-17 01:04:07","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":279,"slug":"debugger","title":"Debugger","description":"","post_count":23}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["48c4a70d-e243-43e5-9709-85d2119c592b"],"dasblog_compressedtitle":["Writing+An+IronPython+Debugger+Dynamic+Stack+Trace"],"dasblog_compressedtitleunique":["2009\/03\/09\/Writing+An+IronPython+Debugger+Dynamic+Stack+Trace"]}},"previous_url":"http:\/\/devhawk.net\/2009\/03\/04\/writing-and-ironpython-debugger-adding-interactivity\/","next_url":"http:\/\/devhawk.net\/2009\/03\/11\/devhawk_ipy\/"}