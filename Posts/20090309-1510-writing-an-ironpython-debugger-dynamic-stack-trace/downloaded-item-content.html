<p>Now that I can <a href="http://devhawk.net/2009/03/04/Writing+And+IronPython+Debugger+Adding+Interactivity.aspx">interact with my debugger</a>, it&#8217;s time to add a command. I decided to start with something simple &#8211; or at least something I thought would be simple &#8211; printing a stack trace.</p>
<p>In the <a href="http://msdn.microsoft.com/en-us/library/ms404520.aspx">unmanaged debugger API</a>, threads have the concept of both <a href="http://msdn.microsoft.com/en-us/library/ms233401.aspx">stack chains</a> and <a href="http://msdn.microsoft.com/en-us/library/ms230151.aspx">stack frames</a>. A stack chain represents a segment of the physical stack. In a typical managed app, you&#8217;ll have at least two stack chains: the unmanaged stack chain and the managed stack chain. You can interate through the stack chains for a given thread via the Chains property. However, ipydbg is a managed only debugger, so I can ignore the unmanaged stack chain. Instead, I just retrieve the current (managed) chain via the thread&#8217;s ActiveChain property.</p>
<p>Within a managed stack chain, there is a collection of stack frames. This is the call stack that managed developers are typically used to working with. It turns out that printing a raw stack trace is very easy to do. Here was my first stab at it:</p>
<pre class="brush: python">elif k.Key == ConsoleKey.T:     
  print &quot;nManaged Stack Trace&quot;
  for f in active_thread.ActiveChain.Frames:     
    offset, sp = get_location(f)     
    metadata_import = CorMetadataImport(f.Function.Module)     
    method_info = metadata_import.GetMethodInfo(f.FunctionToken)     
    print &quot;  &quot;,      
      &quot;%s::%s --&quot; % (method_info.DeclaringType.Name, method_info.Name),      
      sp if sp != None else &quot;(offset %d)&quot; % offset</pre>
<p>This elif block is part of the input method I showed last time. It loops thru the frames in the Active Chain of the active thread and prints some data to the console. As I said, pretty easy. Of course, the devil is in the details.</p>
<p>First detail I should call out is that active_thread variable. <a href="http://blogs.msdn.com/jmstall/archive/2006/03/21/attach_asyncbreak.aspx">As per Mike Stall</a>, &#8220;there is no notion of &#8220;active thread&#8221; in the underlying debug APIs. It&#8217;s purely a construct in a debugger UI to make it easier for end-users.&#8221; My console based UI may be rudimentary, but it&#8217;s still a UI. Events like OnBreakpoint include the active thread as a event argument, so I stash that away in a variable so it&#8217;ll be available to the input loop.</p>
<p>Second detail is the call to get_location. When we <a href="http://github.com/devhawk/ipydbg/blob/112c3acdcf726c3ad89ce2def8258ecc2fb55513/ipydbg.py#L50">last saw get_location</a>, it was returning a formatted string. Since my last post, I&#8217;ve refactored the code so it returns the raw location data &#8211; a tuple of the raw IP offset and the associated sequence point, if available. I&#8217;ve also added a __str__ method to my sequence point object, so when I print it to the console, I get the filename and line nicely formatted.</p>
<p>Finally, there&#8217;s all CorMetadataImport code. In addition to wrapping the unmanaged debugger API, CorDebug also wraps the <a href="http://msdn.microsoft.com/en-us/library/ms404384.aspx">unmanaged metadata API</a>. This code lets me get <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodinfo.aspx">MethodInfo</a> compatible view of the function metadata for a given stack frame. I use it here to get the type and function name for each frame on the stack.</p>
<p>The end result looks something like this. Note, I&#8217;ve replaced &#8220;Microsoft.Scripting&#8221; with &#8220;MS.Scripting&#8221; to avoid word wrapping.</p>
<pre class="brush:plain">OnBreakpoint Initialize Location: simpletest.py:1 (offset: 84) 
&#187; t 
Managed Stack Trace 
   S$2::Initialize simpletest.py:1 (offset: 84) 
   MS.Scripting.Runtime.OptimizedScriptCode::InvokeTarget (offset 72) 
   MS.Scripting.ScriptCode::Run (offset 0) 
   IronPython.Hosting.PythonCommandLine::RunFileWorker (offset 77) 
   IronPython.Hosting.PythonCommandLine::RunFile (offset 15) 
   MS.Scripting.Hosting.Shell.CommandLine::Run (offset 46) 
   IronPython.Hosting.PythonCommandLine::Run (offset 240) 
   MS.Scripting.Hosting.Shell.CommandLine::Run (offset 74) 
   MS.Scripting.Hosting.Shell.ConsoleHost::RunCommandLine (offset 158) 
   MS.Scripting.Hosting.Shell.ConsoleHost::ExecuteInternal (offset 32) 
   MS.Scripting.Hosting.Shell.ConsoleHost::Execute (offset 63) 
   MS.Scripting.Hosting.Shell.ConsoleHost::Run (offset 390) 
   PythonConsoleHost::Main &#8212; (offset 125)</pre>
<p>As we can see, we may be on the first line of the python script, but we&#8217;ve got a pretty deep stack trace already. Everything but the top-most frame are from the underlying IronPython implementation. Those extra frames obscure the stack frames I actually care about, so it would be nice to hide any stack frames from IronPython or the DLR. It&#8217;s easy enough to write a python generator function that filters out frames that from the DLR or IronPython namespaces. In order to get the type name, we need the method_info like we did above. I&#8217;ve factored that code into a separate function in order to avoid code duplication.</p>
<pre class="brush: python">def get_method_info_for_frame(frame)     
    if frame.FrameType != CorFrameType.ILFrame:     
      return None
    metadata_import = CorMetadataImport(frame.Function.Module)     
    return metadata_import.GetMethodInfo(frame.FunctionToken)     

def get_dynamic_frames(chain):     
  for f in chain.Frames:     
    method_info = get_method_info_for_frame(f)     
    if method_info == None:     
      continue
    typename = method_info.DeclaringType.Name     
    if typename.startswith(&quot;Microsoft.Scripting.&quot;)      
      or typename.startswith(&quot;IronPython.&quot;)      
      or typename == &quot;PythonConsoleHost&quot;:     
        continue
    yield f</pre>
<p>You&#8217;ll notice I&#8217;ve added a guard to get_method_info_for_frame in order to ensure that the frame argument is an IL Frame. There are <a href="http://github.com/devhawk/ipydbg/blob/dab527c9bb39e61cc4a464d840db8ee6a2aef753/CorDebug/CorDebug/Thread.cs#L272">three types of stack frames</a> in the debugger API: <a href="http://msdn.microsoft.com/en-us/library/ms232990.aspx">IL</a>, native and <a href="http://msdn.microsoft.com/en-us/library/ms232469.aspx">internal</a>. Most of the frames we&#8217;re dealing with are IL frames, but you do run into the occasional <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod.aspx">lightweight function</a> (i.e. <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod.aspx">DynamicMethod</a>) frame when debugging IronPython code. Typically, IronPython generates DynamicMethods for all python code except for a few cases related to .NET interop. However, you can&#8217;t debug DynamicMethods, so when you run with &#8211;D, we generate normal non-dynamic methods instead. However, even when running with &#8211;D, we still use DynamicMethods for call site dispatch. Since they&#8217;re an implementation detail, we want to filter those out in get_dynamic_frames too.</p>
<p>This gives us a much more manageable stack trace:</p>
<pre class="brush:plain">OnBreakpoint Initialize Location: simpletest.py:1 (offset: 84) 
&#187; t 
Stack Trace 
   S$2::Initialize -- simpletest.py:1 (offset: 84)</pre>
<p>As usual, the <a href="http://github.com/devhawk/ipydbg/blob/c33cf75c4e9273a21ada00abe2403c392e4ca0a0/ipydbg.py">latest ipydbg source</a> is up on GitHub.</p>
