<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Practical F# Parsing: The Abstract Syntax Tree</title>
  <link>http://devhawk.net/2007/12/19/practical-f-parsing-the-abstract-syntax-tree/</link>
  <pubDate>Wed, 19 Dec 2007 19:00:57 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://5769c547-ec8f-438e-a34c-08508b3e8bde</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>In the last post, I showed two semantic productions, Char and Range. Char returns an option tuple of a native char and the parse buffer. Range returns a tuple of either a single character or a character range and the parse buffer. Certainly, I could have written Range to always return a char * char tuple, passing in the same character for both in the case of a single character range. However, this provides an opportunity to introduce F#'s <a href="http://research.microsoft.com/fsharp/manual/quicktour.aspx#QuickTourDiscriminatedUnions" target="_blank">discriminated unions</a> (or simply union for short).</p><p>The F# Manual describes a discriminated union as "a new type composed of a fixed number of distinct alternatives". Many of the semantic productions return "a fixed number of distinct alternatives" so I find a union is a good way to model the return value of semantic production functions. Here's the definition of Range:</p><pre class="brush: fsharp">
///AST Type for Range production
type Range = 
| Single of char
| Dual of char * char
    with
    override this.ToString() =  
        match this with
        | Single x -&gt; sprintf "Range.Single (%A)" x 
        | Dual (x,y) -&gt; sprintf "Range.Dual (%A,%A)" x y
</pre><p>So Range is either a single character, or a tuple of two characters. As you saw in the last post, you create an instance of a union with the type.alternative syntax. You can also use simply the alternative name, assuming F# can determine the correct union type. Personally, I like using the full name - it helps me remember what the type really is. </p><p>Notice that the AP function and the union type appear to have the same name. Actually, they don't since the name of the AP function's name includes the bananas - i.e. (|Range|_). However, if you want you can define a function called simply Range and still have a type named Range as well - as long as you're not interested in language interop. F# can tell the difference between the Range function and the Range union, but C# can't. So I'd say we're best off avoiding overloading the names entirely. </p><p>If you look at the compiled union in Reflector, you'll see the Range type, with public internal classes named _Single and _Dual that inherit from Range. In other words, F# implements union types as an inheritance tree.  Range also provides static constructors for the various disparate types in the union. </p><p>One last thing I want to point out about the Range type is how I overrode ToString. This is primarily for unit testing - if you don't override ToString, you only get the type name which isn't very useful when trying to figure out why a given unit test failed. I'm using the F# native sprintf function rather than string.Format, so the <a href="http://research.microsoft.com/fsharp/manual/fslib/Microsoft.FSharp.Text.Printf.html" target="_blank">format string is a little different</a>. </p><p>The other major F# type we'll use in the AST are <a href="http://research.microsoft.com/fsharp/manual/quicktour.aspx#QuickTourRecords" target="_blank">record types</a>. These are similar conceptually to structs in C#. Basically, they're a tuple with names. For example, here's the Definition record type (though we haven't seen any functions that use this type yet). </p><pre class="brush: fsharp">
///AST Type for Definition production 
type Definition =   
    {  
        name: string;  
        exp: Expression;  
    }  
    with  
    override this.ToString() =   
        sprintf "Definition (name: %A, exp: %A)" this.name (Primary.Exp2Str this.exp)
</pre><p>I could have simply defined this type as (string * Expression), but having the fields named makes it crystal clear what the semantic meaning of each field is. The only place where I used an anonymous tuple in the AST instead of a record is in the Range union above - I figured that was simple enough not to warrant named fields. </p><p>I also have a couple of <a href="http://research.microsoft.com/fsharp/manual/quicktour.aspx#QuickTourTypeAbbreviations" target="_blank">type aliases</a>. For example, I have a record type called SequenceItem. An array of SequenceItems is a Sequence and an array of Sequences is an Expression (which we saw in the Definition type above). </p><pre class="brush: fsharp">
///AST Type for Sequence Item production
let SequenceItem = 
    {  
        primaryItem: Primary; 
        itemPrefix: Prefix option;      
        itemSuffix: Suffix option; 
    }

///AST Type for Sequence production
let Sequence = SequenceItem list 

///AST Type for Expression production
let Expression = Sequence list
</pre><p>Note, unlike unions and records, type aliases can't override base class methods like ToString. This is because there is no actual Sequence or Expression types in the compiled code - F# compiles away type aliases completely. Looking at the implementaiton of Definition in reflector confirms that the exp member is of type List&lt;List&lt;SequenceItem&gt;&gt;. Since I need to convert Expressions to strings in two different places, I wrote a static Exp2Str method on the Primary type (not shown). It feels a bit hacky to stick Expression's ToString implementation on the Primary type, but I had little choice given F#'s scoping rules. </p><p>Technically, since they get compiled away anyway, I could have skipped the Sequence and Expression declarations and simply defined the exp field of Definition as "SequenceItem list list". But the "list list" syntax throws me a bit. I mean, I understand it, but I found using the terms Sequence and Expression far more readable. Also, I used the definition of Expression in the definition of Primary, so it makes sense for it to have it's own name.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1080</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-12-19 11:00:57</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-12-19 19:00:57</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">practical-f-parsing-the-abstract-syntax-tree</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="development"><![CDATA[Development]]></category>
  <category domain="post_tag" nicename="f-sharp"><![CDATA[F#]]></category>
  <category domain="post_tag" nicename="parsing-expression-grammar"><![CDATA[Parsing Expression Grammar]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[5769c547-ec8f-438e-a34c-08508b3e8bde]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Practical+F+Parsing+The+Abstract+Syntax+Tree]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/12/19/Practical+F+Parsing+The+Abstract+Syntax+Tree]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>