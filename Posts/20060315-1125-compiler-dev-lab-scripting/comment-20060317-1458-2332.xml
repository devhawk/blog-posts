<?xml version="1.0" encoding="utf-8"?>
<wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
  <wp:comment_id>2332</wp:comment_id>
  <wp:comment_author><![CDATA[John Lam]]></wp:comment_author>
  <wp:comment_author_email>jlam@iunknown.com</wp:comment_author_email>
  <wp:comment_author_url>http://www.iunknown.com</wp:comment_author_url>
  <wp:comment_author_IP>67.69.151.82</wp:comment_author_IP>
  <wp:comment_date>2006-03-17 14:58:16</wp:comment_date>
  <wp:comment_date_gmt>2006-03-17 21:58:16</wp:comment_date_gmt>
  <wp:comment_content><![CDATA[RubyCLR is a bridge, although I do generate a lot of CIL on the fly for my proxies. The next release will let me implement arbitrary CLR interfaces on Ruby objects (I already support delegates today). So I can get most of the way there; and without having to compromise the semantics of Ruby itself (the JRuby guys are having a heck of a time doing just that).

A bigger blocking issue in the short term is adding support for OS native threads to Ruby itself. Since the Ruby interpreter is *not* safe for concurrent access, this limits the kinds of things that you can do with Ruby talking to .NET (ASP.NET just ain't gonna happen). This might be the reason to drive to a native Ruby.NET implementation. But that's a lot more work :)]]></wp:comment_content>
  <wp:comment_approved>1</wp:comment_approved>
  <wp:comment_type></wp:comment_type>
  <wp:comment_parent>0</wp:comment_parent>
  <wp:comment_user_id>0</wp:comment_user_id>
</wp:comment>