<p>As I wrote in my <a href="http://devhawk.net/2006/10/17/WF+Clarifications+And+Corrections.aspx">last post</a>, I&#8217;m doing a bunch of WF related work. I&#8217;m close to releasing some WF related stuff I started building last week in <a href="http://www.masteringbiztalk.com/blogs/jon/default.aspx">Jon&#8217;s</a> class. But I discovered something cool about the way WF&#8217;s queuing system works, and wanted to blog about it. </p>
<blockquote><p>Side note&nbsp;- Speaking of Jon, he&#8217;s <a href="http://www.masteringbiztalk.com/blogs/jon/PermaLink,guid,5cc60ee3-38ce-4fcd-94d7-a8ca9b3b8d5d.aspx">joined</a> the &#8220;WF is not a toy&#8221; conversation. He had an interesting point about the persistence service that I hadn&#8217;t thought of. If you use the SQL persistence service and you have TransactionScope in your workflow, you end up with a distributed transaction, even if these are all writing against the same SQL instance. That&#8217;s a good enough reason to write your own persistence service right there. </p>
</blockquote>
<p>In the WF stuff I&#8217;m building, I need a way for the WF runtime to notify a given workflow instance when something happens. WF has a low level <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.workflow.runtime.workflowqueuingservice(VS.80).aspx">queuing system</a> as well as the higher abstraction <a href="http://windowssdk.msdn.microsoft.com/en-us/library/ms735872(VS.80).aspx">data exchange system</a>. I&#8217;m more interested in low level knowledge of WF, so I decided to use the queuing system. </p>
<p>In my implementation, the workflow&nbsp;instances only need to be notified when specific events happen. That is, I&#8217;m not passing in any real data on the queue &#8211; the arrival of the data is what&#8217;s important, not the data itself. Queues are identified by name and I started by using a simple string as my queue name. However, the queue name isn&#8217;t limited to be a string, it supports any <a href="http://msdn2.microsoft.com/en-us/library/system.icomparable.aspx">IComparable</a> class. This turned out to be a huge advantage for me. </p>
<p>Things worked fine when I was building a simple sequence, but when I moved to a parallel activity things went south. Since I was using a simple string, I ended up creating two queues with the same name, which didn&#8217;t work out well. Furthermore, I have two different notification situations. So I needed a way to have a unique queue name for the same activity type in parallel branches of the workflow as well as supporting two different notification situations. </p>
<p>Because queue name is IComparable instead of a string, I was able to create two queue name types &#8211; one for each notification situation. Each of these queue name types includes a string that I initialize to the activity&#8217;s <a href="http://windowssdk.msdn.microsoft.com/en-us/library/system.workflow.componentmodel.activity.qualifiedname(VS.80).aspx">qualified name</a>, which as per the docs is &#8220;always unique in a workflow instance&#8221;. So I was able to kill two birds with one stone &#8211; supporting multiple parallel activities as well as multiple notification scenarios. That&#8217;s pretty cool. If they had used simple strings, I would have had to have a naming system like &#8220;notificationscenario:notificationdata:activityname&#8221; and then have to parse out the queue name string. In fact, I started down this path before I remembered that queue name is IComparable. Using IComparable is <em>much much </em>cleaner.</p>
