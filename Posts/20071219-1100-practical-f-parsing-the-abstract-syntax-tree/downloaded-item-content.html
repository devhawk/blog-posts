<p>In the last post, I showed two semantic productions, Char and Range. Char returns an option tuple of a native char and the parse buffer. Range returns a tuple of either a single character or a character range and the parse buffer. Certainly, I could have written Range to always return a char * char tuple, passing in the same character for both in the case of a single character range. However, this provides an opportunity to introduce F#&#8217;s <a href="http://research.microsoft.com/fsharp/manual/quicktour.aspx#QuickTourDiscriminatedUnions" target="_blank">discriminated unions</a> (or simply union for short).</p>
<p>The F# Manual describes a discriminated union as &#8220;a new type composed of a fixed number of distinct alternatives&#8221;. Many of the semantic productions return &#8220;a fixed number of distinct alternatives&#8221; so I find a union is a good way to model the return value of semantic production functions. Here&#8217;s the definition of Range:</p>
<pre class="brush: fsharp">///AST Type for Range production
type Range = 
| Single of char
| Dual of char * char
    with
    override this.ToString() =  
        match this with
        | Single x -&gt; sprintf &quot;Range.Single (%A)&quot; x 
        | Dual (x,y) -&gt; sprintf &quot;Range.Dual (%A,%A)&quot; x y
</pre>
<p>So Range is either a single character, or a tuple of two characters. As you saw in the last post, you create an instance of a union with the type.alternative syntax. You can also use simply the alternative name, assuming F# can determine the correct union type. Personally, I like using the full name &#8211; it helps me remember what the type really is. </p>
<p>Notice that the AP function and the union type appear to have the same name. Actually, they don&#8217;t since the name of the AP function&#8217;s name includes the bananas &#8211; i.e. (|Range|_). However, if you want you can define a function called simply Range and still have a type named Range as well &#8211; as long as you&#8217;re not interested in language interop. F# can tell the difference between the Range function and the Range union, but C# can&#8217;t. So I&#8217;d say we&#8217;re best off avoiding overloading the names entirely. </p>
<p>If you look at the compiled union in Reflector, you&#8217;ll see the Range type, with public internal classes named _Single and _Dual that inherit from Range. In other words, F# implements union types as an inheritance tree.&nbsp; Range also provides static constructors for the various disparate types in the union. </p>
<p>One last thing I want to point out about the Range type is how I overrode ToString. This is primarily for unit testing &#8211; if you don&#8217;t override ToString, you only get the type name which isn&#8217;t very useful when trying to figure out why a given unit test failed. I&#8217;m using the F# native sprintf function rather than string.Format, so the <a href="http://research.microsoft.com/fsharp/manual/fslib/Microsoft.FSharp.Text.Printf.html" target="_blank">format string is a little different</a>. </p>
<p>The other major F# type we&#8217;ll use in the AST are <a href="http://research.microsoft.com/fsharp/manual/quicktour.aspx#QuickTourRecords" target="_blank">record types</a>. These are similar conceptually to structs in C#. Basically, they&#8217;re a tuple with names. For example, here&#8217;s the Definition record type (though we haven&#8217;t seen any functions that use this type yet). </p>
<pre class="brush: fsharp">///AST Type for Definition production 
type Definition =   
    {  
        name: string;  
        exp: Expression;  
    }  
    with  
    override this.ToString() =   
        sprintf &quot;Definition (name: %A, exp: %A)&quot; this.name (Primary.Exp2Str this.exp)
</pre>
<p>I could have simply defined this type as (string * Expression), but having the fields named makes it crystal clear what the semantic meaning of each field is. The only place where I used an anonymous tuple in the AST instead of a record is in the Range union above &#8211; I figured that was simple enough not to warrant named fields. </p>
<p>I also have a couple of <a href="http://research.microsoft.com/fsharp/manual/quicktour.aspx#QuickTourTypeAbbreviations" target="_blank">type aliases</a>. For example, I have a record type called SequenceItem. An array of SequenceItems is a Sequence and an array of Sequences is an Expression (which we saw in the Definition type above). </p>
<pre class="brush: fsharp">///AST Type for Sequence Item production
let SequenceItem = 
    {  
        primaryItem: Primary; 
        itemPrefix: Prefix option;      
        itemSuffix: Suffix option; 
    }

///AST Type for Sequence production
let Sequence = SequenceItem list 

///AST Type for Expression production
let Expression = Sequence list
</pre>
<p>Note, unlike unions and records, type aliases can&#8217;t override base class methods like ToString. This is because there is no actual Sequence or Expression types in the compiled code &#8211; F# compiles away type aliases completely. Looking at the implementaiton of Definition in reflector confirms that the exp member is of type List&lt;List&lt;SequenceItem&gt;&gt;. Since I need to convert Expressions to strings in two different places, I wrote a static Exp2Str method on the Primary type (not shown). It feels a bit hacky to stick Expression&#8217;s ToString implementation on the Primary type, but I had little choice given F#&#8217;s scoping rules. </p>
<p>Technically, since they get compiled away anyway, I could have skipped the Sequence and Expression declarations and simply defined the exp field of Definition as &#8220;SequenceItem list list&#8221;. But the &#8220;list list&#8221; syntax throws me a bit. I mean, I understand it, but I found using the terms Sequence and Expression far more readable. Also, I used the definition of Expression in the definition of Primary, so it makes sense for it to have it&#8217;s own name.</p>
