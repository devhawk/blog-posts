{"status":"ok","post":{"id":1080,"type":"post","slug":"practical-f-parsing-the-abstract-syntax-tree","url":"http:\/\/devhawk.net\/2007\/12\/19\/practical-f-parsing-the-abstract-syntax-tree\/","status":"publish","title":"Practical F# Parsing: The Abstract Syntax Tree","title_plain":"Practical F# Parsing: The Abstract Syntax Tree","content":"<p>In the last post, I showed two semantic productions, Char and Range. Char returns an option tuple of a native char and the parse buffer. Range returns a tuple of either a single character or a character range and the parse buffer. Certainly, I could have written Range to always return a char * char tuple, passing in the same character for both in the case of a single character range. However, this provides an opportunity to introduce F#&#8217;s <a href=\"http:\/\/research.microsoft.com\/fsharp\/manual\/quicktour.aspx#QuickTourDiscriminatedUnions\" target=\"_blank\">discriminated unions<\/a> (or simply union for short).<\/p>\n<p>The F# Manual describes a discriminated union as &#8220;a new type composed of a fixed number of distinct alternatives&#8221;. Many of the semantic productions return &#8220;a fixed number of distinct alternatives&#8221; so I find a union is a good way to model the return value of semantic production functions. Here&#8217;s the definition of Range:<\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/AST Type for Range production\ntype Range = \n| Single of char\n| Dual of char * char\n    with\n    override this.ToString() =  \n        match this with\n        | Single x -&gt; sprintf \"Range.Single (%A)\" x \n        | Dual (x,y) -&gt; sprintf \"Range.Dual (%A,%A)\" x y\n<\/pre>\n<p>So Range is either a single character, or a tuple of two characters. As you saw in the last post, you create an instance of a union with the type.alternative syntax. You can also use simply the alternative name, assuming F# can determine the correct union type. Personally, I like using the full name &#8211; it helps me remember what the type really is. <\/p>\n<p>Notice that the AP function and the union type appear to have the same name. Actually, they don&#8217;t since the name of the AP function&#8217;s name includes the bananas &#8211; i.e. (|Range|_). However, if you want you can define a function called simply Range and still have a type named Range as well &#8211; as long as you&#8217;re not interested in language interop. F# can tell the difference between the Range function and the Range union, but C# can&#8217;t. So I&#8217;d say we&#8217;re best off avoiding overloading the names entirely. <\/p>\n<p>If you look at the compiled union in Reflector, you&#8217;ll see the Range type, with public internal classes named _Single and _Dual that inherit from Range. In other words, F# implements union types as an inheritance tree.\u00a0 Range also provides static constructors for the various disparate types in the union. <\/p>\n<p>One last thing I want to point out about the Range type is how I overrode ToString. This is primarily for unit testing &#8211; if you don&#8217;t override ToString, you only get the type name which isn&#8217;t very useful when trying to figure out why a given unit test failed. I&#8217;m using the F# native sprintf function rather than string.Format, so the <a href=\"http:\/\/research.microsoft.com\/fsharp\/manual\/fslib\/Microsoft.FSharp.Text.Printf.html\" target=\"_blank\">format string is a little different<\/a>. <\/p>\n<p>The other major F# type we&#8217;ll use in the AST are <a href=\"http:\/\/research.microsoft.com\/fsharp\/manual\/quicktour.aspx#QuickTourRecords\" target=\"_blank\">record types<\/a>. These are similar conceptually to structs in C#. Basically, they&#8217;re a tuple with names. For example, here&#8217;s the Definition record type (though we haven&#8217;t seen any functions that use this type yet). <\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/AST Type for Definition production \ntype Definition =   \n    {  \n        name: string;  \n        exp: Expression;  \n    }  \n    with  \n    override this.ToString() =   \n        sprintf \"Definition (name: %A, exp: %A)\" this.name (Primary.Exp2Str this.exp)\n<\/pre>\n<p>I could have simply defined this type as (string * Expression), but having the fields named makes it crystal clear what the semantic meaning of each field is. The only place where I used an anonymous tuple in the AST instead of a record is in the Range union above &#8211; I figured that was simple enough not to warrant named fields. <\/p>\n<p>I also have a couple of <a href=\"http:\/\/research.microsoft.com\/fsharp\/manual\/quicktour.aspx#QuickTourTypeAbbreviations\" target=\"_blank\">type aliases<\/a>. For example, I have a record type called SequenceItem. An array of SequenceItems is a Sequence and an array of Sequences is an Expression (which we saw in the Definition type above). <\/p>\n<pre class=\"brush: fsharp\">\n\/\/\/AST Type for Sequence Item production\nlet SequenceItem = \n    {  \n        primaryItem: Primary; \n        itemPrefix: Prefix option;      \n        itemSuffix: Suffix option; \n    }\n\n\/\/\/AST Type for Sequence production\nlet Sequence = SequenceItem list \n\n\/\/\/AST Type for Expression production\nlet Expression = Sequence list\n<\/pre>\n<p>Note, unlike unions and records, type aliases can&#8217;t override base class methods like ToString. This is because there is no actual Sequence or Expression types in the compiled code &#8211; F# compiles away type aliases completely. Looking at the implementaiton of Definition in reflector confirms that the exp member is of type List&lt;List&lt;SequenceItem&gt;&gt;. Since I need to convert Expressions to strings in two different places, I wrote a static Exp2Str method on the Primary type (not shown). It feels a bit hacky to stick Expression&#8217;s ToString implementation on the Primary type, but I had little choice given F#&#8217;s scoping rules. <\/p>\n<p>Technically, since they get compiled away anyway, I could have skipped the Sequence and Expression declarations and simply defined the exp field of Definition as &#8220;SequenceItem list list&#8221;. But the &#8220;list list&#8221; syntax throws me a bit. I mean, I understand it, but I found using the terms Sequence and Expression far more readable. Also, I used the definition of Expression in the definition of Primary, so it makes sense for it to have it&#8217;s own name.<\/p>\n","excerpt":"<p>In the last post, I showed two semantic productions, Char and Range. Char returns an option tuple of a native char and the parse buffer. Range returns a tuple of either a single character or a character range and the parse buffer. Certainly, I could have written Range to always return a char * char [&hellip;]<\/p>\n","date":"2007-12-19 11:00:57","modified":"2011-04-17 16:02:36","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165}],"tags":[{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51},{"id":209,"slug":"parsing-expression-grammar","title":"Parsing Expression Grammar","description":"","post_count":16}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["5769c547-ec8f-438e-a34c-08508b3e8bde"],"dasblog_compressedtitle":["Practical+F+Parsing+The+Abstract+Syntax+Tree"],"dasblog_compressedtitleunique":["2007\/12\/19\/Practical+F+Parsing+The+Abstract+Syntax+Tree"]}},"previous_url":"http:\/\/devhawk.net\/2007\/12\/18\/practical-f-parsing-semantic-productions-1\/","next_url":"http:\/\/devhawk.net\/2007\/12\/20\/practical-f-parsing-semantic-productions-2\/"}