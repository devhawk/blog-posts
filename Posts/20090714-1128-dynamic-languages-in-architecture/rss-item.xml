<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Dynamic Languages in Architecture</title>
  <link>http://devhawk.net/2009/07/14/dynamic-languages-in-architecture/</link>
  <pubDate>Tue, 14 Jul 2009 11:28:47 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://94b98f0d-d884-4557-8df0-8f0dca3b72e7</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>In the comments from <a href="http://devhawk.net/CommentView,guid,cf59d65d-af8c-41c5-9562-a26969d76a5d.aspx#commentstart">yesterday’s post</a>, IronPython MVP and <a href="http://www.ironpythoninaction.com/">author extraordinaire</a><a href="http://www.voidspace.org.uk/">Michael Foord</a> asked:</p><blockquote><p>Has your view on architecture as a discipline separate from coding changed since working with dynamic languages?</p></blockquote><p>In a word:“No” (though as always, I reserve the right to be wrong and/or convinced otherwise.)</p><p>When I was an architect, I tried very hard to treat it as a “discipline separate from coding”. To use my last post as an example, building a central repository of system audit information is an architectural decision. A bad one IMHO - at least the way Dilbert’s <a href="http://en.wikipedia.org/wiki/Pointy-Haired_Boss">PHB</a> described it - but an architectural decision all the same. It was a decision about what kind of system to build, part of an overall application portfolio, as opposed to a decision about how to build the system.</p><p>I’ve held this opinion of architecture for a long time. Four years (and three jobs) ago, I wrote <a href="http://devhawk.net/2005/08/29/What+Is+Architecture.aspx">the following</a>:</p><blockquote><p>IMO, building a system that has a set of functional requirements (track customers, process orders, etc) and non-functional constraints (sub-second response time, support 10,000 concurrent users, use Microsoft Windows platform, etc) is an engineering problem. Coming up with the lists of functional requirements and non-functional constraints is the architecture problem.</p></blockquote><p>Working with dynamic languages has dramatically changed my view of engineering and design of individual systems. But from the pure architecture perspective, I want to be able to treat individual systems as black boxes as much as possible. That means the programming language is an implementation detail that shouldn’t matter to the architect.</p><p>Note the significant bet-hedging language in the paragraph above. I’m using phrases like “shouldn’t matter” and “as much as possible” because we all know that there’s no such thing as a “pure architecture perspective”. Unlike building architecture, software architecture is in constant flux at every level. At the enterprise level, there are always new regulatory obligations, new competitors and new partners to consider. At the end-to-end process level, there are always new systems or new version of existing systems coming on line. And at the individual system level, there are always new – or at least new versions - of tools, frameworks and languages being released. </p><p>Once you introduce time into your architecture perspective, individual system engineering will affect the overall architecture, since system engineering affects the rate of change. Language choice will certainly have some engineering impact. However, in my experience language choice is rarely high on the list of concerns relative to things like project scope and team experience. </p><p>So my “No” answer to Michael’s question is predicated on the following:</p><ul><li>As an architect, I want to consider individual systems as black boxes where implementation details like language choice are completely irrelevant. </li><li>As a practical architect, I realize that some system implementation details are relevant – especially over time - but in my experience language choice isn’t one of them. </li></ul><p>On the other hand, most IT shops try to standardize on one programming language – certainly MS IT did – so maybe language choice would be more architecturally relevant in a mixed language shop. I’d love to hear from folks who have multiple standard languages in their IT shop – especially if you have both static and dynamic languages on your standards list.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1272</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-07-14 11:28:47</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-07-14 11:28:47</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">dynamic-languages-in-architecture</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="dynamic-languages"><![CDATA[Dynamic Languages]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[94b98f0d-d884-4557-8df0-8f0dca3b72e7]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Dynamic+Languages+In+Architecture]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/07/14/Dynamic+Languages+In+Architecture]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2235</wp:comment_id>
    <wp:comment_author><![CDATA[Michael Foord]]></wp:comment_author>
    <wp:comment_author_email>fuzzyman@voidspace.org.uk</wp:comment_author_email>
    <wp:comment_author_url>http://www.ironpythoninaction.com/</wp:comment_author_url>
    <wp:comment_author_IP>87.194.212.65</wp:comment_author_IP>
    <wp:comment_date>2009-07-14 13:37:34</wp:comment_date>
    <wp:comment_date_gmt>2009-07-14 20:37:34</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Interesting response (thanks). I'll have to think about the subject. Architectural thinking is a necessary (and very important) part of software development - but beyond the systems level (which is systems administration and not software architecture) I have a hard time seeing divorcing architectural thinking from the actual development as anything but a terrible thing.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2236</wp:comment_id>
    <wp:comment_author><![CDATA[Michael Foord]]></wp:comment_author>
    <wp:comment_author_email>fuzzyman@voidspace.org.uk</wp:comment_author_email>
    <wp:comment_author_url>http://www.ironpythoninaction.com/</wp:comment_author_url>
    <wp:comment_author_IP>87.194.212.65</wp:comment_author_IP>
    <wp:comment_date>2009-07-14 14:02:56</wp:comment_date>
    <wp:comment_date_gmt>2009-07-14 21:02:56</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Hmmm... although I see that your definition of architecture (at the functional level) does not match my caricature of the 'architecture astronauts' which I do think can be endemic in languages that encourage additional layers of architecture. I do think there are cultural differences between dynamically and statically typed communities, at least I've noticed them being closer to the .NET community these days.

As I said, requires some thinking about - perhaps I'll blog about it.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2237</wp:comment_id>
    <wp:comment_author><![CDATA[Ryan Riley]]></wp:comment_author>
    <wp:comment_author_email>ryan.riley@panesofglass.org</wp:comment_author_email>
    <wp:comment_author_url>http://wizardsofsmart.net/author/riles/</wp:comment_author_url>
    <wp:comment_author_IP>66.193.255.227</wp:comment_author_IP>
    <wp:comment_date>2009-07-15 09:51:59</wp:comment_date>
    <wp:comment_date_gmt>2009-07-15 16:51:59</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[So based on the definition of architecture I'm reading into your post, you wouldn't consider the choice of object-oriented versus functional programming styles from an architectural perspective? I'm trying to understand what level of architecture you mean here. Like Michael, I usually think of architecture even down into the implementation patterns level (hence the architecture astronauts), but that seems to be included in what you might be calling an engineering concern.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>