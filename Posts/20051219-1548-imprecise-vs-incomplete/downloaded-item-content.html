<p><a href="http://blogs.msdn.com/garethj">Gareth</a> responds to the first tenet of <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a>:</p>
<blockquote><p>[A]lthough as an industry we desperately need to drag models kicking and screaming from the far left of pretty-picturedom a good long way to the right in the direction of precision, I don&#8217;t want to throw the baby out with the bathwater.</p>
<p>I&#8217;m going to take it as a given that folks believe that precise models are valuable development artefacts. Why do I think imprecise models are also valuable? Here are three things that tools for imprecise models help you to do:</p>
<ol style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px" type="1">
<li>Communicate with people about design </li>
<li>Think out loud in a way that&#8217;s more shareable that your whiteboard </li>
<li>Start with an imprecise model and progress gradually toward precise models</li>
</ol>
<p>Hopefully the first of these is obvious &#8211; there is value in model as communication device &#8211; it&#8217;s just not enormous.&nbsp; I&#8217;ve <a href="https://blogs.msdn.com/garethj/archive/2004/10/13/241985.aspx">talked before about the value</a> of the second &#8211; I draw pictures on my whiteboard and when I&#8217;m on a conference call to Redmond, they&#8217;re effectively useless.</p>
<p>The third is something I&#8217;ve only recently become a convert to.&nbsp; I&#8217;m happy to have models which are not precise so long as I can still reason about them programmatically.&nbsp; This allows me to have development processes that are about a quantitive process of iterative refinement.</p>
<p>Here&#8217;s an example &#8211; in some infrastructure modelling tool, I have a node type which specifies a logical machine group.&nbsp; One of its properties is the number of actual machines required to suit the proposed scale of the application to be deployed.&nbsp; I&#8217;d like to be able to put &#8220;Depends on outcome of Fred&#8217;s scalability investigation&#8221; into that numeric field, or perhaps &#8220;4-&gt;8&#8243;.&nbsp; I can still generate a pretty good report from this model, but I can&#8217;t really provision a set of physical servers from it.</p>
<p>But here&#8217;s the kicker &#8211; it&#8217;s vital that I can write tools that programmatically assess this model and tell me what work needs to be done in order to make it precise.&nbsp; I want to know exactly what must be done on this model before, for example, it is suitable for feeding into some kind of provisioning tool.&nbsp; You might say it needs to be precisely imprecise; I prefer to think of it as quantifiable imprecision.</p>
<p></p>
<p>[<a href="http://blogs.msdn.com/garethj/archive/2005/12/07/imprecisehippies.aspx">Imprecise Models and Killing Hippies</a>]</p>
</blockquote>
<p>The only thing I disagree with Gareth about is terminology. Like the term architecture, model has become a catch-all for things that aren&#8217;t code. Regular readers of this blog know I like to be more precise than that. As such, I think items #1 and #2 from Gareth&#8217;s list aren&#8217;t actually models at all. I think of them as pseudomodels, similar to the concept of <a href="http://en.wikipedia.org/wiki/Pseudocode">pseudocode</a>. Actually, I like the name pseudomodel &#8211; it also applies well to <a href="http://devhawk.net/2005/12/17/Scaffolding+Isnt+A+Model.aspx">Grady&#8217;s scaffolding</a>. Like psuedocode, pseudomodels have tons of value in communication and reasoning about a problem but they can&#8217;t be used as development artifacts. </p>
<p>As for the third, I think what Gareth is describing is an incomplete model, rather than an imprecise one. If the model is imprecise, there&#8217;s no way to programmatically reason about it. But if we look to code as an example, obviously, there are many cases where code is incomplete. Every compiler error you&#8217;ve ever seen is an example of incomplete code. And because the language is precisely specified, the compiler can tell you what needs to be done in order to make it precise, exactly as Gareth requested. I don&#8217;t think of writing code as &#8220;progressing gradually towards precision&#8221; and I doubt anyone else does either. And while I do see development as an &#8220;iterative process&#8221;, I don&#8217;t think of it as &#8220;iterative refinement&#8221;. Modeling shouldn&#8217;t be any different.</p>
<p>One area where I do see refinement being critical is in the development of the modeling language itself. Traditionally, the language stays stable while the program written with it changes. But with the introduction of DSLs, it becomes possible for both to vary independently. I would assume that a DSL would evolve over time to have better &#8220;coverage&#8221; of a given domain. For example, if I was building a <a href="http://devhawk.net/2005/11/23/Thoughts+On+CAB.aspx">CAB DSL</a>, I would implement support for WorkItem right off the bat, but supporting WorkItemExtension would be much lower on the priority list. This represents language refinement, but I would argue it&#8217;s a refinement of coverage not a refinement of precision. </p>
