<p></p>
<p>Over the past couple of weeks, I&#8217;ve gotten a chance to spend time investigating the <a href="http://msdn2.microsoft.com/en-us/teamsystem/aa718948.aspx">Guidance Automation Toolkit</a>. For those who aren&#8217;t familiar with GAT, it is the underlying enabling technology that powers <a href="http://msdn2.microsoft.com/en-us/practices/bb190387.aspx">p&amp;p&#8217;s Software Factories</a>. Several of p&amp;p&#8217;s factories include data access guidance, but that works against an actual database rather than a <a href="http://msdn2.microsoft.com/en-us/teamsystem/aa718807.aspx">VSTDB</a> project. Given my <a href="http://devhawk.net/2007/03/20/VSTDB+Where+Have+You+Been+All+My+Life.aspx">newfound love</a> for VSTDB + my interest in GAT, I thought I would whip up some simple automated guidance. </p>
<p>The key word in that last sentence is &#8220;thought&#8221;. Turns out that authoring guidance in GAT is extremely unfriendly. GAT&#8217;s unit of automation is called a recipe, which consists of arguments, wizards and actions. Arguments are GAT&#8217;s equivalent of variables, wizards gather argument data from the user and actions execute changes to the solution based on the values of the arguments. There&#8217;s more granularity to the GAT authoring model &#8211; for example, GAT arguments have optionally have value providers and converters (which should be called validators) &#8211; but you get the basic idea. </p>
<p>What makes GAT so hard is that all these recipe elements are wholly independent. This makes individual recipe elements easy to write and recipes fairly modular, but&nbsp;at the cost of making recipe very difficult to write. Your recipe has to define both the list of these elements that it uses as well as their interconnections. For example, arguments optionally contain value providers and converters. They are exposed to the user in wizards as either custom pages or arguments. They are fed into actions as input parameters. Action input parameters can also come from the output parameters of other actions. All these interconnections have to be hand coded in XML&nbsp;with fully specified type names like &#8220;Microsoft.Practices.RecipeFramework.VisualStudio.Library.Templates.TextTemplateAction, Microsoft.Practices.RecipeFramework.VisualStudio.Library&#8221;. Ugh. </p>
<p>The good news for GAT is that help is on the way. Clarius&#8217; <a href="http://softwarefactoriestoolkit.net/">Software Factories Toolkit</a> includes a <a href="http://softwarefactoriestoolkit.net/RecipeDesigner_final.html">graphical domain specific language</a> for&nbsp;authoring recipes.&nbsp;With that tool, you can pick the various recipe elements from a list and connect them graphically instead of hand coding all of that in XML. But why do we have this problem in the first place? How much are we gaining by using this XML format in the first place? Frankly, I don&#8217;t think very much. I think it would make more sense to define recipes in code than XML. </p>
<p>I was talking to <a href="http://blogs.msdn.com/mglehman/">Michael Lehman</a>&nbsp;about <a href="http://projectglidepath.net/">Project Glidepath</a>, which is built on GAT. However, Glidepath only uses GAT for integration with Visual Studio&#8217;s menu system (which seems <a href="http://msdn2.microsoft.com/en-us/library/bb164639(VS.80).aspx">much more difficult</a> than it needs to be, but that&#8217;s a separate post). Instead of GAT&#8217;s recipe system, Glidepath plugins simply expose an Execute() method. Within that method, the plugin can do whatever it wants. Michael showed me the code behind the <a href="http://projectglidepath.net/blog/blogs/glidepath/archive/2007/04/04/166.aspx">Vista Bridge package</a>, and it is MUCH simpler than the GAT equivalent. I could see having a little more structure than just Execute(), but GAT seems like overkill in comparison. </p>
<p>Sometimes <a href="http://devhawk.net/2005/11/23/As+Simple+As+Possible+But+No+Simpler.aspx">complexity is necessary</a>. But I can&#8217;t help but think that GAT&#8217;s complexity wasn&#8217;t really necessary. Wouldn&#8217;t it have been simpler and just as modular to define a recipe in code instead? </p>
