<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Is Guidance Automation Too Complex?</title>
  <link>http://devhawk.net/2007/04/11/is-guidance-automation-too-complex/</link>
  <pubDate>Wed, 11 Apr 2007 11:07:34 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://4fbb71b8-cf62-4e64-ac2c-eac81d8b6c41</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p></p><p>Over the past couple of weeks, I've gotten a chance to spend time investigating the <a href="http://msdn2.microsoft.com/en-us/teamsystem/aa718948.aspx">Guidance Automation Toolkit</a>. For those who aren't familiar with GAT, it is the underlying enabling technology that powers <a href="http://msdn2.microsoft.com/en-us/practices/bb190387.aspx">p&amp;p's Software Factories</a>. Several of p&amp;p's factories include data access guidance, but that works against an actual database rather than a <a href="http://msdn2.microsoft.com/en-us/teamsystem/aa718807.aspx">VSTDB</a> project. Given my <a href="http://devhawk.net/2007/03/20/VSTDB+Where+Have+You+Been+All+My+Life.aspx">newfound love</a> for VSTDB + my interest in GAT, I thought I would whip up some simple automated guidance. </p><p>The key word in that last sentence is "thought". Turns out that authoring guidance in GAT is extremely unfriendly. GAT's unit of automation is called a recipe, which consists of arguments, wizards and actions. Arguments are GAT's equivalent of variables, wizards gather argument data from the user and actions execute changes to the solution based on the values of the arguments. There's more granularity to the GAT authoring model - for example, GAT arguments have optionally have value providers and converters (which should be called validators) - but you get the basic idea. </p><p>What makes GAT so hard is that all these recipe elements are wholly independent. This makes individual recipe elements easy to write and recipes fairly modular, but at the cost of making recipe very difficult to write. Your recipe has to define both the list of these elements that it uses as well as their interconnections. For example, arguments optionally contain value providers and converters. They are exposed to the user in wizards as either custom pages or arguments. They are fed into actions as input parameters. Action input parameters can also come from the output parameters of other actions. All these interconnections have to be hand coded in XML with fully specified type names like "Microsoft.Practices.RecipeFramework.VisualStudio.Library.Templates.TextTemplateAction, Microsoft.Practices.RecipeFramework.VisualStudio.Library". Ugh. </p><p>The good news for GAT is that help is on the way. Clarius' <a href="http://softwarefactoriestoolkit.net/">Software Factories Toolkit</a> includes a <a href="http://softwarefactoriestoolkit.net/RecipeDesigner_final.html">graphical domain specific language</a> for authoring recipes. With that tool, you can pick the various recipe elements from a list and connect them graphically instead of hand coding all of that in XML. But why do we have this problem in the first place? How much are we gaining by using this XML format in the first place? Frankly, I don't think very much. I think it would make more sense to define recipes in code than XML. </p><p>I was talking to <a href="http://blogs.msdn.com/mglehman/">Michael Lehman</a> about <a href="http://projectglidepath.net/">Project Glidepath</a>, which is built on GAT. However, Glidepath only uses GAT for integration with Visual Studio's menu system (which seems <a href="http://msdn2.microsoft.com/en-us/library/bb164639(VS.80).aspx">much more difficult</a> than it needs to be, but that's a separate post). Instead of GAT's recipe system, Glidepath plugins simply expose an Execute() method. Within that method, the plugin can do whatever it wants. Michael showed me the code behind the <a href="http://projectglidepath.net/blog/blogs/glidepath/archive/2007/04/04/166.aspx">Vista Bridge package</a>, and it is MUCH simpler than the GAT equivalent. I could see having a little more structure than just Execute(), but GAT seems like overkill in comparison. </p><p>Sometimes <a href="http://devhawk.net/2005/11/23/As+Simple+As+Possible+But+No+Simpler.aspx">complexity is necessary</a>. But I can't help but think that GAT's complexity wasn't really necessary. Wouldn't it have been simpler and just as modular to define a recipe in code instead? </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">932</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-04-11 11:07:34</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-04-11 11:07:34</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">is-guidance-automation-too-complex</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="guidance"><![CDATA[Guidance]]></category>
  <category domain="post_tag" nicename="software-factories"><![CDATA[Software Factories]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[4fbb71b8-cf62-4e64-ac2c-eac81d8b6c41]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Is+Guidance+Automation+Too+Complex]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/04/11/Is+Guidance+Automation+Too+Complex]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2481</wp:comment_id>
    <wp:comment_author><![CDATA[KR]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>68.18.70.123</wp:comment_author_IP>
    <wp:comment_date>2007-04-17 19:11:04</wp:comment_date>
    <wp:comment_date_gmt>2007-04-18 02:11:04</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[It absolutely is too complex! Microsoft is trying to tread so many new paths and so fast that one or more of them are bound to turn this way! Nothing against the Guidance Automation team but they should stop.. step back.. and start over. I have not seen even one architect or developer that is comfortable with the Guidance Automation concepts or tools. Infact they are more willing to write VS extensions and add-ins for custom functions than use GA tools and concepts. In all fairness, that team might still have a 'vision' to make everything simple.. that they are working towards.. If that is true, they should start laying out that vision and CTPs really fast in front of the developer community. If not.. think of this as a learning exercise and start over! :-)]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>