<p>When I was first experimenting with __clrtype__, I got to the point of making CLR fields work and then immediately tried to do some data binding with Silverlight. Didn&#8217;t work. Turns out Silverlight can only data bind against properties &#8211; fields aren&#8217;t supported. So now let&#8217;s add basic property support to ClrTypeMetaclass. Python has a <a href="http://docs.python.org/library/functions.html#property">rich mechanism</a> for defining properties, but hooking that up requires DLR binders so for now I&#8217;m going to generate properties that are simple wrappers around the associated fields.</p>
<p>There&#8217;s enough code involved in defining a property to break it out into it&#8217;s own method:</p>
<p></p>
<pre class="brush: python">@staticmethod
  def define_prop(typebld, name, fieldtype, fieldbld):
    attribs = ( MethodAttributes.Public 
              | MethodAttributes.SpecialName 
              | MethodAttributes.HideBySig)
    clrtype = clr.GetClrType(fieldtype)
    
    getbld = typebld.DefineMethod(&quot;get_&quot; + name, attribs, clrtype, None)
    getilgen = getbld.GetILGenerator()
    getilgen.Emit(OpCodes.Ldarg_0)
    getilgen.Emit(OpCodes.Ldfld, fieldbld)
    getilgen.Emit(OpCodes.Ret)

    setbld = typebld.DefineMethod(&quot;set_&quot; + name, attribs, None, (clrtype,))
    setilgen = setbld.GetILGenerator()
    setilgen.Emit(OpCodes.Ldarg_0)
    setilgen.Emit(OpCodes.Ldarg_1)
    setilgen.Emit(OpCodes.Stfld, fieldbld)
    setilgen.Emit(OpCodes.Ret)

    prpbld = typebld.DefineProperty(name, 
      PropertyAttributes.None, clrtype, None)
    prpbld.SetGetMethod(getbld)
    prpbld.SetSetMethod(setbld)
</pre>
<p></p>
<p>You provide define_prop the TypeBuilder for the Type being constructed, the name and type of the property as well as the FieldBuilder that gets returned from the call to DefineField. In the <a href="http://devhawk.net/2009/04/23/clrtype+Metaclasses+Adding+CLR+Fields.aspx">previous installment</a>, I wasn&#8217;t bothering to save the FieldBuilder to a variable since I never used it again. Now, I&#8217;m stashing it away for the call to define_prop as I&#8217;ll show below.</p>
<p>For each field, we define a get method, a set method and a property. The get function first executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldarg_0.aspx">ldarg_0</a> to load the current object reference onto the execution stack, then it executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldfld.aspx">ldfld</a> to load the specified field from the object onto the stack, then it returns. The set function executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldarg_0.aspx">ldarg_0</a> to load the current object reference and <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldarg_1.aspx">ldarg_1</a> to load the value passed as the first argument onto the execution stack, then it executes <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.stfld.aspx">stfld</a> to store the value in the specified field of the object. Once I have the two methods, I call DefineProperty to create the PropertyBuilder and then associate the get and set methods with that property. </p>
<p>As I said before, Reflection.Emit is straightforward though tedious. Honestly, I didn&#8217;t go thru the Emit docs to figure out what the methods should look like. Instead, I wrote a basic wrapper property in C# and looked at the generated IL in Reflector. </p>
<p>The only other change here is adding the call to define_prop on our first iteration thru list of _clrfields. Since the rest of __clrtype__ is the same, here&#8217;s just that code snippet:</p>
<pre class="brush: python">if hasattr(cls, &quot;_clrfields&quot;):
      for fldname in cls._clrfields: 
        fieldtype = clr.GetClrType(cls._clrfields[fldname])
        fieldbld = typebld.DefineField(fldname, fieldtype, 
                             FieldAttributes.Public)
        ClrTypeMetaclass.define_prop(typebld, fldname, fieldtype, fieldbld)
</pre>
<p>As I said above, I simply save off the result of calling DefineField so I can pass it to define_prop. I also save off the field type in a variable since I use it more than once. Avoids the second dictionary lookup and is clearer to understand what the function does.</p>
<p>Accessing the CLR properties via reflection is pretty straightforward &#8211; not very different than reflecting over CLR fields. The only significant difference between them is that CLR properties can be indexable and fields can&#8217;t, so you have to pass an index parameter to <a href="http://msdn.microsoft.com/en-us/library/b05d59ty.aspx">GetValue</a> and <a href="http://msdn.microsoft.com/en-us/library/xb5dd1f1.aspx">SetValue</a>. These aren&#8217;t indexed properties, so I pass in None for the index parameter.</p>
<pre class="brush: text">&gt;&gt;&gt; p = Product(&quot;Crunchy Frog&quot;, 10, 12)
&gt;&gt;&gt; pi = p.GetType().GetProperty(&quot;name&quot;)
&gt;&gt;&gt; pi.GetValue(p, None)
'Crunchy Frog'
&gt;&gt;&gt; pi.SetValue(p, &quot;Spring Surprise&quot;, None)
&gt;&gt;&gt; pi.GetValue(p, None)
'Spring Surprise'
&gt;&gt;&gt; p.name
'Spring Surprise'
</pre>
<p></p>
<p>One quick aside about the CLR type I&#8217;m generating here. I&#8217;m fairly certain this reflected object wouldn&#8217;t pass muster with the C# compiler. I&#8217;m defining a field and a property with the same name. It clearly works at the IL level, but I&#8217;m not sure what the C# compiler would do if you tried to refer to a CLR type like this. I should probably be prepending an underscore or something on the field name, but then I wonder if the field should also be private. There&#8217;s a whole API design discussion down that road, but I&#8217;m not quite ready to have that yet so I&#8217;m just leaving the fields public and having fields and properties with the same name. Luckily, I&#8217;m never generating a CLR type on disk so you can&#8217;t build a C# project that refers to it anyway.</p>
