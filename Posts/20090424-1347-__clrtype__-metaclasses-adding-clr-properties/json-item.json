{"status":"ok","post":{"id":1254,"type":"post","slug":"__clrtype__-metaclasses-adding-clr-properties","url":"http:\/\/devhawk.net\/2009\/04\/24\/__clrtype__-metaclasses-adding-clr-properties\/","status":"publish","title":"__clrtype__ Metaclasses: Adding CLR Properties","title_plain":"__clrtype__ Metaclasses: Adding CLR Properties","content":"<p>When I was first experimenting with __clrtype__, I got to the point of making CLR fields work and then immediately tried to do some data binding with Silverlight. Didn\u2019t work. Turns out Silverlight can only data bind against properties \u2013 fields aren\u2019t supported. So now let\u2019s add basic property support to ClrTypeMetaclass. Python has a <a href=\"http:\/\/docs.python.org\/library\/functions.html#property\">rich mechanism<\/a> for defining properties, but hooking that up requires DLR binders so for now I\u2019m going to generate properties that are simple wrappers around the associated fields.<\/p>\n<p>There\u2019s enough code involved in defining a property to break it out into it\u2019s own method:<\/p>\n<\/p>\n<pre class=\"brush: python\">\n@staticmethod\n  def define_prop(typebld, name, fieldtype, fieldbld):\n    attribs = ( MethodAttributes.Public \n              | MethodAttributes.SpecialName \n              | MethodAttributes.HideBySig)\n    clrtype = clr.GetClrType(fieldtype)\n    \n    getbld = typebld.DefineMethod(\"get_\" + name, attribs, clrtype, None)\n    getilgen = getbld.GetILGenerator()\n    getilgen.Emit(OpCodes.Ldarg_0)\n    getilgen.Emit(OpCodes.Ldfld, fieldbld)\n    getilgen.Emit(OpCodes.Ret)\n\n    setbld = typebld.DefineMethod(\"set_\" + name, attribs, None, (clrtype,))\n    setilgen = setbld.GetILGenerator()\n    setilgen.Emit(OpCodes.Ldarg_0)\n    setilgen.Emit(OpCodes.Ldarg_1)\n    setilgen.Emit(OpCodes.Stfld, fieldbld)\n    setilgen.Emit(OpCodes.Ret)\n\n    prpbld = typebld.DefineProperty(name, \n      PropertyAttributes.None, clrtype, None)\n    prpbld.SetGetMethod(getbld)\n    prpbld.SetSetMethod(setbld)\n<\/pre>\n<\/p>\n<p>You provide define_prop the TypeBuilder for the Type being constructed, the name and type of the property as well as the FieldBuilder that gets returned from the call to DefineField. In the <a href=\"http:\/\/devhawk.net\/2009\/04\/23\/clrtype+Metaclasses+Adding+CLR+Fields.aspx\">previous installment<\/a>, I wasn\u2019t bothering to save the FieldBuilder to a variable since I never used it again. Now, I\u2019m stashing it away for the call to define_prop as I\u2019ll show below.<\/p>\n<p>For each field, we define a get method, a set method and a property. The get function first executes <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.opcodes.ldarg_0.aspx\">ldarg_0<\/a> to load the current object reference onto the execution stack, then it executes <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.opcodes.ldfld.aspx\">ldfld<\/a> to load the specified field from the object onto the stack, then it returns. The set function executes <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.opcodes.ldarg_0.aspx\">ldarg_0<\/a> to load the current object reference and <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.opcodes.ldarg_1.aspx\">ldarg_1<\/a> to load the value passed as the first argument onto the execution stack, then it executes <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.reflection.emit.opcodes.stfld.aspx\">stfld<\/a> to store the value in the specified field of the object. Once I have the two methods, I call DefineProperty to create the PropertyBuilder and then associate the get and set methods with that property. <\/p>\n<p>As I said before, Reflection.Emit is straightforward though tedious. Honestly, I didn\u2019t go thru the Emit docs to figure out what the methods should look like. Instead, I wrote a basic wrapper property in C# and looked at the generated IL in Reflector. <\/p>\n<p>The only other change here is adding the call to define_prop on our first iteration thru list of _clrfields. Since the rest of __clrtype__ is the same, here\u2019s just that code snippet:<\/p>\n<pre class=\"brush: python\">\nif hasattr(cls, \"_clrfields\"):\n      for fldname in cls._clrfields: \n        fieldtype = clr.GetClrType(cls._clrfields[fldname])\n        fieldbld = typebld.DefineField(fldname, fieldtype, \n                             FieldAttributes.Public)\n        ClrTypeMetaclass.define_prop(typebld, fldname, fieldtype, fieldbld)\n<\/pre>\n<p>As I said above, I simply save off the result of calling DefineField so I can pass it to define_prop. I also save off the field type in a variable since I use it more than once. Avoids the second dictionary lookup and is clearer to understand what the function does.<\/p>\n<p>Accessing the CLR properties via reflection is pretty straightforward \u2013 not very different than reflecting over CLR fields. The only significant difference between them is that CLR properties can be indexable and fields can\u2019t, so you have to pass an index parameter to <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/b05d59ty.aspx\">GetValue<\/a> and <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/xb5dd1f1.aspx\">SetValue<\/a>. These aren\u2019t indexed properties, so I pass in None for the index parameter.<\/p>\n<pre class=\"brush: text\">\n&gt;&gt;&gt; p = Product(\"Crunchy Frog\", 10, 12)\n&gt;&gt;&gt; pi = p.GetType().GetProperty(\"name\")\n&gt;&gt;&gt; pi.GetValue(p, None)\n'Crunchy Frog'\n&gt;&gt;&gt; pi.SetValue(p, \"Spring Surprise\", None)\n&gt;&gt;&gt; pi.GetValue(p, None)\n'Spring Surprise'\n&gt;&gt;&gt; p.name\n'Spring Surprise'\n<\/pre>\n<\/p>\n<p>One quick aside about the CLR type I\u2019m generating here. I\u2019m fairly certain this reflected object wouldn\u2019t pass muster with the C# compiler. I\u2019m defining a field and a property with the same name. It clearly works at the IL level, but I\u2019m not sure what the C# compiler would do if you tried to refer to a CLR type like this. I should probably be prepending an underscore or something on the field name, but then I wonder if the field should also be private. There\u2019s a whole API design discussion down that road, but I\u2019m not quite ready to have that yet so I\u2019m just leaving the fields public and having fields and properties with the same name. Luckily, I\u2019m never generating a CLR type on disk so you can\u2019t build a C# project that refers to it anyway.<\/p>\n","excerpt":"<p>When I was first experimenting with __clrtype__, I got to the point of making CLR fields work and then immediately tried to do some data binding with Silverlight. Didn\u2019t work. Turns out Silverlight can only data bind against properties \u2013 fields aren\u2019t supported. So now let\u2019s add basic property support to ClrTypeMetaclass. Python has a [&hellip;]<\/p>\n","date":"2009-04-24 13:47:30","modified":"2009-04-24 13:47:30","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":281,"slug":"__clrtype__","title":"__clrtype__","description":"","post_count":9}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["5d800133-200d-40ec-a7b1-956d49ffaaac"],"dasblog_compressedtitle":["clrtype+Metaclasses+Adding+CLR+Properties"],"dasblog_compressedtitleunique":["2009\/04\/24\/clrtype+Metaclasses+Adding+CLR+Properties"]}},"previous_url":"http:\/\/devhawk.net\/2009\/04\/23\/__clrtype__-metaclasses-adding-clr-fields\/","next_url":"http:\/\/devhawk.net\/2009\/04\/24\/__clrtype__-metaclasses-demo-silverlight-databinding\/"}