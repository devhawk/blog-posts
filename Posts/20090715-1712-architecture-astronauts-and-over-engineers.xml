<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Architecture Astronauts and Over Engineers</title>
  <link>http://devhawk.net/2009/07/15/architecture-astronauts-and-over-engineers/</link>
  <pubDate>Wed, 15 Jul 2009 17:12:32 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://9dbbe690-a32a-41c8-996b-d3f1af8ed69c</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Since it’s apparently Architecture Week™ [1] here at DevHawk, here’s another of my favorite Dilbert cartoons of all time – relevant to the discussion at hand.</p><p><a title="Dilbert.com" href="http://dilbert.com/strips/comic/2008-03-04/"><img style="display: block; float: none; margin-left: auto; margin-right: auto" border="0" alt="Dilbert.com" src="http://dilbert.com/dyn/str_strip/000000000/00000000/0000000/000000/00000/1000/800/1890/1890.strip.gif" /></a></p><p>Two interesting <a href="http://devhawk.net/CommentView,guid,94b98f0d-d884-4557-8df0-8f0dca3b72e7.aspx#commentstart">comments</a> on yesterday’s post:</p><blockquote><p>Architectural thinking is a necessary (and very important) part of software development - but beyond the systems level (which is systems administration and not software architecture) I have a hard time seeing divorcing architectural thinking from the actual development as anything but a terrible thing. Although I see that your definition of architecture (at the functional level) does not match my caricature of the 'architecture astronauts' which I do think can be endemic in languages that encourage additional layers of architecture. [<a href="http://www.voidspace.org.uk/">Michael Foord</a>]</p></blockquote><blockquote><p>So based on the definition of architecture I'm reading into your post, you wouldn't consider the choice of object-oriented versus functional programming styles from an architectural perspective? I'm trying to understand what level of architecture you mean here. Like Michael, I usually think of architecture even down into the implementation patterns level (hence the architecture astronauts), but that seems to be included in what you might be calling an engineering concern. [<a href="http://wizardsofsmart.net/">Ryan Riley</a>]</p></blockquote><p>Let me be very clear. Using my definition, there is no such thing “architecture even down into the implementation patterns level”. I’d argue that the implementation patterns level is engineering, not architecture. From what I’ve seen, the terms “architecture” and “engineering” tend to be used interchangeably in the software industry, and frankly I think that’s a mistake. I said as much in <a href="http://devhawk.net/2005/08/31/Architecture+At+The+Intersection.aspx">yet another post</a> I wrote four years ago:</p><blockquote><p>Architecture is the intersection between business and IT.</p><p>If a decision doesn't effect a business person, it's not an architecture decision. I'm not saying it's not important - I think the role of the software engineer is critical in large-scale enterprise system design and construction. And I will readily admit that often a single person is responsible for both architecture and engineering. But that doesn't make them the same activity. As long as we continue to confuse the two disciplines, we hold them both back.</p></blockquote><p>Michael and Ryan (or anyone else for that matter) are welcome to disagree with my definition of architecture. I often joke that if you asked ten architects to define “architecture”, you’d get twelve answers. But that’s my definition and I’m sticking to it. </p><p>But what of the Architecture Astronauts? Both Michael and Ryan mentioned them. Unsurprisingly, I think that term is used too broadly as well. If you go back and read Joel’s <a href="http://www.joelonsoftware.com/articles/fog0000000018.html">original post</a> of Architecture Astronauts, there wasn’t much reference, if any, to the implementation layer at all. </p><blockquote><p>The Architecture Astronauts will say things like: "Can you imagine a program like<i></i>Napster where you can download <i>anything,</i> not just songs?" Then they'll build applications like Groove that they think are <i>more</i> general than Napster, but which seem to have neglected that wee little feature that lets you type the name of a song and then listen to it -- the feature we wanted in the first place. Talk about missing the point. If Napster <i>wasn't</i> peer-to-peer but it <i>did</i> let you type the name of a song and then listen to it, it would have been just as popular</p><p></p><p>[Joel on Software, <a href="http://www.joelonsoftware.com/articles/fog0000000018.html">Don't Let Architecture Astronauts Scare You</a>]</p></blockquote><p>I feel that my definition fits very well with the way Joel writes about architecture in this paragraph. The Architect Astronaut is trying to solve a real business problem - people need access to information besides music. But the mistake they make is thinking they can solve multiple problems with a single solution. So they abstract higher and higher until they’ve lost sight of the original problem and can only focus on the abstractions. If you look at what Joel has to say about technologies like Hailstorm and Jini, you see the same pattern emerge. </p><p>This isn’t to say that similar problems of over-abstraction don’t happen at the implementation layer – they do. But they happen for very different reasons. Astronaut Architects are trying to solve multiple problems with a single solution. But when over-abstraction happens at the implementation level, it because someone thought they could predict the future.</p><p>We’ve all seen our fair share of over-engineered systems that introduce significant unneeded complexity on the off chance that the development team can successfully predict the kind of change likely to come in the next version of the product. Invariably, the team’s precognitive abilities are revealed to be as poor as everyone else's, so they’re left with a bunch of extra layers of software cruft that has to be maintained but provides zero additional value to the system. I’ve blogged about that problem before as well: <a href="http://devhawk.net/2008/03/05/Kitchen+Sink+Variability.aspx">Kitchen Sink Variability</a>.</p><p>Since I’m big on keeping the terminology of architecture and engineering separate, then I’d argue that we need a different term than Architecture Astronaut for people who want to introduce additional layers of abstraction at the implementation layer on the off chance that they don’t suck at precognition. Since we call such systems over-engineered, wouldn’t that make the people who build them “Over Engineers”?</p><p></p><hr /><p>[1] It’s like <a href="http://en.wikipedia.org/wiki/Shark_Week">Shark Week</a>, but with white boards and even more terrifying.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1273</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-07-15 17:12:32</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-07-15 17:12:32</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">architecture-astronauts-and-over-engineers</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[9dbbe690-a32a-41c8-996b-d3f1af8ed69c]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Architecture+Astronauts+And+Over+Engineers]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/07/16/Architecture+Astronauts+And+Over+Engineers]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2238</wp:comment_id>
    <wp:comment_author><![CDATA[Michael Foord]]></wp:comment_author>
    <wp:comment_author_email>michael@voidspace.org.uk</wp:comment_author_email>
    <wp:comment_author_url>http://www.ironpythoninaction.com/</wp:comment_author_url>
    <wp:comment_author_IP>88.96.188.137</wp:comment_author_IP>
    <wp:comment_date>2009-07-17 03:28:09</wp:comment_date>
    <wp:comment_date_gmt>2009-07-17 10:28:09</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I agree that over-engineered is definitely the correct term for software that has too many layers of abstraction (interfaces for everything - yay! internal, private, protected, public - yay! never use fields but always properties - yay! dependency injection or you can't test - yay!).

However, when developers work on the structure of an application it is hard not to call it 'architecture', and the analogy is appropriate. (Architects *do* specify the details, often down to specific materials, of buildings they design.) It seems inevitable that these two meanings of the word will be conflated.

Nice discussion by the way,

]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2239</wp:comment_id>
    <wp:comment_author><![CDATA[Eric Smith]]></wp:comment_author>
    <wp:comment_author_email>eric@smithster.com</wp:comment_author_email>
    <wp:comment_author_url>http://thelimberlambda.com/</wp:comment_author_url>
    <wp:comment_author_IP>196.6.141.26</wp:comment_author_IP>
    <wp:comment_date>2009-07-17 06:44:28</wp:comment_date>
    <wp:comment_date_gmt>2009-07-17 13:44:28</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I'm a little concerned with the intimation that use of interfaces, respect for visibility of type members and use of dependency injection equates to "over-engineering".  As with everything, it depends on what you're trying to achieve, and generalisations in this regard, especially when junior people who may not understand what's at stake are reading, can be damaging.

I find it an uphill battle to engender a constructive mindset in developers who have established bad habits and whose pride lies in the way of addressing those habits.

Anti-"process" talk by Joel Spolsky and the "pragmatism brigade" makes it harder.  A while ago I had a new developer refuse to write unit tests despite it being an established practice in our team because "... Jeff and Joel said they were bad in the StackOverflow podcast ...".  Yikes.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2240</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>71.231.42.80</wp:comment_author_IP>
    <wp:comment_date>2009-07-17 07:24:34</wp:comment_date>
    <wp:comment_date_gmt>2009-07-17 14:24:34</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[@Michael, as I've said above "I will readily admit that often a single person is responsible for both architecture and engineering. But that doesn't make them the same activity."

@Eric, I never intimated that "that use of interfaces, respect for visibility of type members and use of dependency injection" == over-engineering. There are good reasons to use those techniques that has exactly zero to do with thinking you can predict the future. There's good engineering and then there's over engineering. I guess that's will be the subject of my next Architecture post!]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2241</wp:comment_id>
    <wp:comment_author><![CDATA[Eric Smith]]></wp:comment_author>
    <wp:comment_author_email>eric@smithster.com</wp:comment_author_email>
    <wp:comment_author_url>http://thelimberlambda.com/</wp:comment_author_url>
    <wp:comment_author_IP>196.6.141.26</wp:comment_author_IP>
    <wp:comment_date>2009-07-17 08:42:59</wp:comment_date>
    <wp:comment_date_gmt>2009-07-17 15:42:59</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[@DevHawk - I was making a reference to the first paragraph of @Michael's response--I guess I should have indicated as much.  I do agree with the whole over-engineering argument--looking forward to your explanation of where "good" crosses over into "over".]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>