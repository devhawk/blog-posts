<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>The Last Mile of the Internet</title>
  <link>http://devhawk.net/2009/08/27/the-last-mile-of-the-internet/</link>
  <pubDate>Thu, 27 Aug 2009 11:08:02 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://71dfa192-0234-4f3d-9939-bc35274f3f5a</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<a href="http://blogs.thinktecture.com/cweyer">Christian Weyer</a> makes a <a href="http://devhawk.net/CommentView,guid,ebed9385-833f-4ef9-8a32-931162f742a1.aspx#commentstart">great comment</a> on <a href="http://devhawk.net/2009/08/26/Async+Messaging+And+The+Barbarian+Hordes.aspx">yesterday’s post</a> about the barbarian rediscovery of async messaging:
<blockquote>But how do these two toolkits solve the NAT/Firewall issue? Without a solution to this they are pretty much useless in breadth usage.</blockquote>
Simply put, they don’t. Frankly, they don’t even try. And I agree with Christian that the NAT/Firewall issue makes any async messaging based approach useless for clients. It’s kind of like the <a href="http://en.wikipedia.org/wiki/Last_mile">last mile problem</a> in the telco/cable industries – you’ve got this great capability in the center, but you can’t leverage its full potential because of the massive effort it takes to push that capability all the way to the edge of the network.

Dave Winer has been <a href="http://www.scripting.com/stories/2009/07/17/thisIsNotAnEarthshakingAnn.html">pretty explicit</a> with his RSS Cloud work: “The goal is to have a <em>Small Pieces Loosely Joined</em> equivalent of Twitter.” PubSubHubbub doesn’t mention Twitter by name, but the <a href="http://pubsubhubbub.googlecode.com/svn/trunk/pubsubhubbub-core-0.1.html">protocol spec</a> specifically says “Polling sucks. We think a decentralized pubsub layer is a fundamental, missing layer in the Internet architecture today”. Both specs have a fundamental design that looks like this:

<img style="display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;" title="image" src="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/AsyncMessagingandClientApplications_15086/image_3.png" border="0" alt="image" width="640" height="139" />

This picture leaves out multiple publishers and subscribers and the subscriber registration process, but you get the basic idea. And it all works great <em>assuming</em> that both the subscriber and the pub/sub infrastructure can accept incoming connections. While that seems like a fairly safe assumption for infrastructure pieces, it is clearly a faulty assumption for any subscriber running locally on a client machine. Client machines primarily live behind firewalls at the office, behind NAT routers at home or on mobile wireless network – all of which disallow most if not all incoming connections. In other words, this works just fine for server subscribers (like, say Google Reader) but not for client subscribers (like, say TweetDeck).

<img style="display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;" title="image" src="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/AsyncMessagingandClientApplications_15086/image_17.png" border="0" alt="image" width="640" height="113" />

As far as I can tell, the only way to enable client subscribers to play in this async messaging world is via some type of relay service. Any other solution I can think of depends on mass adoption of new technology, which as I mentioned in my last post is nearly impossible.

<img style="display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;" title="image" src="http://s3.amazonaws.com/devhawk_images/WindowsLiveWriter/AsyncMessagingandClientApplications_15086/image_20.png" border="0" alt="image" width="640" height="296" />

In this approach, the client subscriber makes an outbound connection to some type of relay infrastructure, which in turn creates a endpoint on the public internet for that client. Registration for pub/sub happens as normal, using the relay endpoint as the notification URL. Then, when a message arrives on the relay endpoint, it’s sent back down the outbound connection to the client.

The relay approach is technically feasible – it’s used in many places today. <a href="http://technet.microsoft.com/en-us/library/aa997252.aspx">Exchange DirectPush</a> uses this approach to support real-time delivery of mail to mobile devices – though the relay capability is built directly Exchange client access servers rather than available as a separate service. The <a href="http://www.microsoft.com/azure/servicebus.mspx">.NET Service Bus</a> – part of <a href="http://www.microsoft.com/azure">Windows Azure</a> – provides a hosted relay infrastructure that anyone can leverage (though their support of non-windows platforms is pretty weak). I haven’t worked with it, but it looks like <a href="http://dev.opera.com/articles/view/opera-unite-developer-primer/">Opera’s new Unite platform</a> includes a relay service as well (note, they call it a proxy service). Nice thing about Opera Unite is the async messaging infrastructure is built right into their browser, though you could achieve something similar in any browser using <a href="http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/net/Socket.html">Flash</a> or <a href="http://msdn.microsoft.com/en-us/library/cc296248(VS.95).aspx">Silverlight</a>.

Yes, having to relay messages sucks. But the question is, which sucks worse: polling or relaying?]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1287</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-08-27 11:08:02</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-08-27 11:08:02</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">the-last-mile-of-the-internet</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <category domain="post_tag" nicename="async-messaging"><![CDATA[Async Messaging]]></category>
  <category domain="post_tag" nicename="web-2-0"><![CDATA[Web 2.0]]></category>
  <category domain="post_tag" nicename="web-services"><![CDATA[Web Services]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[71dfa192-0234-4f3d-9939-bc35274f3f5a]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[The+Last+Mile+Of+The+Internet]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/08/27/The+Last+Mile+Of+The+Internet]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2255</wp:comment_id>
    <wp:comment_author><![CDATA[Marius Mikučionis]]></wp:comment_author>
    <wp:comment_author_email>marius@cs.aau.dk</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>130.225.198.205</wp:comment_author_IP>
    <wp:comment_date>2009-09-03 02:32:58</wp:comment_date>
    <wp:comment_date_gmt>2009-09-03 09:32:58</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[How about using Jabber (or alike) protocol for relaying?
It works in distributed way just like email, while it has real-time capabilities, also each user can have infinitely many resource locators (and each user has full control over their addresses), then just setup different apps to listen to a different resource name which is subscribed to whatever publisher.
In the end, if your mail/NAT/whatever-publicaly-facing server is Jabber-capable, you have the real-time relay infrastructure in place already. 
Moreover this setup works *everytime* you move your netbook away from home network!
Google uses XMMP even for voice/video communication.
So what are we reinventing?]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2256</wp:comment_id>
    <wp:comment_author><![CDATA[jake]]></wp:comment_author>
    <wp:comment_author_email>jochs@critical-masses.com</wp:comment_author_email>
    <wp:comment_author_url>http://www.critical-masses.com/jakeofalltrades/</wp:comment_author_url>
    <wp:comment_author_IP>67.84.28.174</wp:comment_author_IP>
    <wp:comment_date>2009-09-03 08:05:30</wp:comment_date>
    <wp:comment_date_gmt>2009-09-03 15:05:30</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[@Marius I believe that's exactly what superfeedr does]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2257</wp:comment_id>
    <wp:comment_author><![CDATA[Lo'sos']]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>66.228.93.154</wp:comment_author_IP>
    <wp:comment_date>2009-09-22 12:58:36</wp:comment_date>
    <wp:comment_date_gmt>2009-09-22 19:58:36</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[XMPP is still polling. It's not a naive polling, but polling none the less.
With the client behind NAT/firewall, there doesn't seem to be any way around that. It's the client who is responsible for initiating request. Even if one uses smart tricks with multiple mini-requests and responses to emulate biderectional communications. It's still synchronous request/response model under the hood.
On the other side, if network lattency is low, client and server resources are abundant, and there is no true real-time requirements (all of which is typically the case for all the "webby" things), it should suffice for quite a few (if not most) usage scenarios.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>