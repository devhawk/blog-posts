{"status":"ok","post":{"id":1287,"type":"post","slug":"the-last-mile-of-the-internet","url":"http:\/\/devhawk.net\/2009\/08\/27\/the-last-mile-of-the-internet\/","status":"publish","title":"The Last Mile of the Internet","title_plain":"The Last Mile of the Internet","content":"<p><a href=\"http:\/\/blogs.thinktecture.com\/cweyer\">Christian Weyer<\/a> makes a <a href=\"http:\/\/devhawk.net\/CommentView,guid,ebed9385-833f-4ef9-8a32-931162f742a1.aspx#commentstart\">great comment<\/a> on <a href=\"http:\/\/devhawk.net\/2009\/08\/26\/Async+Messaging+And+The+Barbarian+Hordes.aspx\">yesterday\u2019s post<\/a> about the barbarian rediscovery of async messaging:<\/p>\n<blockquote><p>But how do these two toolkits solve the NAT\/Firewall issue? Without a solution to this they are pretty much useless in breadth usage.<\/p><\/blockquote>\n<p>Simply put, they don\u2019t. Frankly, they don\u2019t even try. And I agree with Christian that the NAT\/Firewall issue makes any async messaging based approach useless for clients. It\u2019s kind of like the <a href=\"http:\/\/en.wikipedia.org\/wiki\/Last_mile\">last mile problem<\/a> in the telco\/cable industries \u2013 you\u2019ve got this great capability in the center, but you can\u2019t leverage its full potential because of the massive effort it takes to push that capability all the way to the edge of the network.<\/p>\n<p>Dave Winer has been <a href=\"http:\/\/www.scripting.com\/stories\/2009\/07\/17\/thisIsNotAnEarthshakingAnn.html\">pretty explicit<\/a> with his RSS Cloud work: \u201cThe goal is to have a <em>Small Pieces Loosely Joined<\/em> equivalent of Twitter.\u201d PubSubHubbub doesn\u2019t mention Twitter by name, but the <a href=\"http:\/\/pubsubhubbub.googlecode.com\/svn\/trunk\/pubsubhubbub-core-0.1.html\">protocol spec<\/a> specifically says \u201cPolling sucks. We think a decentralized pubsub layer is a fundamental, missing layer in the Internet architecture today\u201d. Both specs have a fundamental design that looks like this:<\/p>\n<p><img style=\"display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;\" title=\"image\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/AsyncMessagingandClientApplications_15086\/image_3.png\" border=\"0\" alt=\"image\" width=\"640\" height=\"139\" \/><\/p>\n<p>This picture leaves out multiple publishers and subscribers and the subscriber registration process, but you get the basic idea. And it all works great <em>assuming<\/em> that both the subscriber and the pub\/sub infrastructure can accept incoming connections. While that seems like a fairly safe assumption for infrastructure pieces, it is clearly a faulty assumption for any subscriber running locally on a client machine. Client machines primarily live behind firewalls at the office, behind NAT routers at home or on mobile wireless network \u2013 all of which disallow most if not all incoming connections. In other words, this works just fine for server subscribers (like, say Google Reader) but not for client subscribers (like, say TweetDeck).<\/p>\n<p><img style=\"display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;\" title=\"image\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/AsyncMessagingandClientApplications_15086\/image_17.png\" border=\"0\" alt=\"image\" width=\"640\" height=\"113\" \/><\/p>\n<p>As far as I can tell, the only way to enable client subscribers to play in this async messaging world is via some type of relay service. Any other solution I can think of depends on mass adoption of new technology, which as I mentioned in my last post is nearly impossible.<\/p>\n<p><img style=\"display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;\" title=\"image\" src=\"http:\/\/s3.amazonaws.com\/devhawk_images\/WindowsLiveWriter\/AsyncMessagingandClientApplications_15086\/image_20.png\" border=\"0\" alt=\"image\" width=\"640\" height=\"296\" \/><\/p>\n<p>In this approach, the client subscriber makes an outbound connection to some type of relay infrastructure, which in turn creates a endpoint on the public internet for that client. Registration for pub\/sub happens as normal, using the relay endpoint as the notification URL. Then, when a message arrives on the relay endpoint, it\u2019s sent back down the outbound connection to the client.<\/p>\n<p>The relay approach is technically feasible \u2013 it\u2019s used in many places today. <a href=\"http:\/\/technet.microsoft.com\/en-us\/library\/aa997252.aspx\">Exchange DirectPush<\/a> uses this approach to support real-time delivery of mail to mobile devices \u2013 though the relay capability is built directly Exchange client access servers rather than available as a separate service. The <a href=\"http:\/\/www.microsoft.com\/azure\/servicebus.mspx\">.NET Service Bus<\/a> \u2013 part of <a href=\"http:\/\/www.microsoft.com\/azure\">Windows Azure<\/a> \u2013 provides a hosted relay infrastructure that anyone can leverage (though their support of non-windows platforms is pretty weak). I haven\u2019t worked with it, but it looks like <a href=\"http:\/\/dev.opera.com\/articles\/view\/opera-unite-developer-primer\/\">Opera\u2019s new Unite platform<\/a> includes a relay service as well (note, they call it a proxy service). Nice thing about Opera Unite is the async messaging infrastructure is built right into their browser, though you could achieve something similar in any browser using <a href=\"http:\/\/livedocs.adobe.com\/flash\/9.0\/ActionScriptLangRefV3\/flash\/net\/Socket.html\">Flash<\/a> or <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/cc296248(VS.95).aspx\">Silverlight<\/a>.<\/p>\n<p>Yes, having to relay messages sucks. But the question is, which sucks worse: polling or relaying?<\/p>\n","excerpt":"<p>Christian Weyer makes a great comment on yesterday\u2019s post about the barbarian rediscovery of async messaging: But how do these two toolkits solve the NAT\/Firewall issue? Without a solution to this they are pretty much useless in breadth usage. Simply put, they don\u2019t. Frankly, they don\u2019t even try. And I agree with Christian that the [&hellip;]<\/p>\n","date":"2009-08-27 11:08:02","modified":"2011-04-16 22:04:13","categories":[{"id":177,"slug":"architecture","title":"Architecture","description":"","parent":0,"post_count":296}],"tags":[{"id":289,"slug":"async-messaging","title":"Async Messaging","description":"","post_count":2},{"id":188,"slug":"web-2-0","title":"Web 2.0","description":"","post_count":67},{"id":290,"slug":"web-services","title":"Web Services","description":"","post_count":12}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2255,"name":"Marius Miku\u010dionis","url":"","date":"2009-09-03 02:32:58","content":"<p>How about using Jabber (or alike) protocol for relaying?<br \/>\nIt works in distributed way just like email, while it has real-time capabilities, also each user can have infinitely many resource locators (and each user has full control over their addresses), then just setup different apps to listen to a different resource name which is subscribed to whatever publisher.<br \/>\nIn the end, if your mail\/NAT\/whatever-publicaly-facing server is Jabber-capable, you have the real-time relay infrastructure in place already.<br \/>\nMoreover this setup works *everytime* you move your netbook away from home network!<br \/>\nGoogle uses XMMP even for voice\/video communication.<br \/>\nSo what are we reinventing?<\/p>\n","parent":0},{"id":2256,"name":"jake","url":"http:\/\/www.critical-masses.com\/jakeofalltrades\/","date":"2009-09-03 08:05:30","content":"<p>@Marius I believe that&#8217;s exactly what superfeedr does<\/p>\n","parent":0},{"id":2257,"name":"Lo'sos'","url":"","date":"2009-09-22 12:58:36","content":"<p>XMPP is still polling. It&#8217;s not a naive polling, but polling none the less.<br \/>\nWith the client behind NAT\/firewall, there doesn&#8217;t seem to be any way around that. It&#8217;s the client who is responsible for initiating request. Even if one uses smart tricks with multiple mini-requests and responses to emulate biderectional communications. It&#8217;s still synchronous request\/response model under the hood.<br \/>\nOn the other side, if network lattency is low, client and server resources are abundant, and there is no true real-time requirements (all of which is typically the case for all the &#8220;webby&#8221; things), it should suffice for quite a few (if not most) usage scenarios.<\/p>\n","parent":0}],"attachments":[],"comment_count":3,"comment_status":"closed","custom_fields":{"dasblog_entryid":["71dfa192-0234-4f3d-9939-bc35274f3f5a"],"dasblog_compressedtitle":["The+Last+Mile+Of+The+Internet"],"dasblog_compressedtitleunique":["2009\/08\/27\/The+Last+Mile+Of+The+Internet"]}},"previous_url":"http:\/\/devhawk.net\/2009\/08\/26\/async-messaging-and-the-barbarian-hordes\/","next_url":"http:\/\/devhawk.net\/2009\/09\/18\/danish-university-tour-trip-report\/"}