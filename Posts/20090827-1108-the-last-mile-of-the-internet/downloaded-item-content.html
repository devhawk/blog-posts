<p><a href="http://blogs.thinktecture.com/cweyer">Christian Weyer</a> makes a <a href="http://devhawk.net/CommentView,guid,ebed9385-833f-4ef9-8a32-931162f742a1.aspx#commentstart">great comment</a> on <a href="http://devhawk.net/2009/08/26/Async+Messaging+And+The+Barbarian+Hordes.aspx">yesterday&#8217;s post</a> about the barbarian rediscovery of async messaging:</p>
<blockquote><p>But how do these two toolkits solve the NAT/Firewall issue? Without a solution to this they are pretty much useless in breadth usage.</p></blockquote>
<p>Simply put, they don&#8217;t. Frankly, they don&#8217;t even try. And I agree with Christian that the NAT/Firewall issue makes any async messaging based approach useless for clients. It&#8217;s kind of like the <a href="http://en.wikipedia.org/wiki/Last_mile">last mile problem</a> in the telco/cable industries &#8211; you&#8217;ve got this great capability in the center, but you can&#8217;t leverage its full potential because of the massive effort it takes to push that capability all the way to the edge of the network.</p>
<p>Dave Winer has been <a href="http://www.scripting.com/stories/2009/07/17/thisIsNotAnEarthshakingAnn.html">pretty explicit</a> with his RSS Cloud work: &#8220;The goal is to have a <em>Small Pieces Loosely Joined</em> equivalent of Twitter.&#8221; PubSubHubbub doesn&#8217;t mention Twitter by name, but the <a href="http://pubsubhubbub.googlecode.com/svn/trunk/pubsubhubbub-core-0.1.html">protocol spec</a> specifically says &#8220;Polling sucks. We think a decentralized pubsub layer is a fundamental, missing layer in the Internet architecture today&#8221;. Both specs have a fundamental design that looks like this:</p>
<p><img style="display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;" title="image" src=".\image_3.png" border="0" alt="image" width="640" height="139"></p>
<p>This picture leaves out multiple publishers and subscribers and the subscriber registration process, but you get the basic idea. And it all works great <em>assuming</em> that both the subscriber and the pub/sub infrastructure can accept incoming connections. While that seems like a fairly safe assumption for infrastructure pieces, it is clearly a faulty assumption for any subscriber running locally on a client machine. Client machines primarily live behind firewalls at the office, behind NAT routers at home or on mobile wireless network &#8211; all of which disallow most if not all incoming connections. In other words, this works just fine for server subscribers (like, say Google Reader) but not for client subscribers (like, say TweetDeck).</p>
<p><img style="display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;" title="image" src=".\image_17.png" border="0" alt="image" width="640" height="113"></p>
<p>As far as I can tell, the only way to enable client subscribers to play in this async messaging world is via some type of relay service. Any other solution I can think of depends on mass adoption of new technology, which as I mentioned in my last post is nearly impossible.</p>
<p><img style="display: block; float: none; margin-left: auto; margin-right: auto; border-width: 0px;" title="image" src=".\image_20.png" border="0" alt="image" width="640" height="296"></p>
<p>In this approach, the client subscriber makes an outbound connection to some type of relay infrastructure, which in turn creates a endpoint on the public internet for that client. Registration for pub/sub happens as normal, using the relay endpoint as the notification URL. Then, when a message arrives on the relay endpoint, it&#8217;s sent back down the outbound connection to the client.</p>
<p>The relay approach is technically feasible &#8211; it&#8217;s used in many places today. <a href="http://technet.microsoft.com/en-us/library/aa997252.aspx">Exchange DirectPush</a> uses this approach to support real-time delivery of mail to mobile devices &#8211; though the relay capability is built directly Exchange client access servers rather than available as a separate service. The <a href="http://www.microsoft.com/azure/servicebus.mspx">.NET Service Bus</a> &#8211; part of <a href="http://www.microsoft.com/azure">Windows Azure</a> &#8211; provides a hosted relay infrastructure that anyone can leverage (though their support of non-windows platforms is pretty weak). I haven&#8217;t worked with it, but it looks like <a href="http://dev.opera.com/articles/view/opera-unite-developer-primer/">Opera&#8217;s new Unite platform</a> includes a relay service as well (note, they call it a proxy service). Nice thing about Opera Unite is the async messaging infrastructure is built right into their browser, though you could achieve something similar in any browser using <a href="http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/net/Socket.html">Flash</a> or <a href="http://msdn.microsoft.com/en-us/library/cc296248(VS.95).aspx">Silverlight</a>.</p>
<p>Yes, having to relay messages sucks. But the question is, which sucks worse: polling or relaying?</p>
