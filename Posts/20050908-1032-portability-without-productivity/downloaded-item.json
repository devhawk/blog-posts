{"status":"ok","post":{"id":627,"type":"post","slug":"portability-without-productivity","url":"http:\/\/devhawk.net\/2005\/09\/08\/portability-without-productivity\/","status":"publish","title":"Portability without Productivity","title_plain":"Portability without Productivity","content":"<p>I said this was going to be a slow week, so I dug out something I wrote while I was on paternity leave. I was saving it for a rainy day, which is pretty silly since if it was raining I wouldn&#8217;t mind staying indoors and writing long posts about levels of abstraction, portability and productivity.<\/p>\n<hr \/>\n<p>My <a href=\"http:\/\/halpierson.blogspot.com\/\">father<\/a> and I have a running <s>argument<\/s> debate about the value of platform independence in the system design and development process. As you might guess, as an employee of a platform company I stand firmly on the &#8220;platform neutrality is irrelevant&#8221; side of the debate. Having been around Bell Labs during the development of Unix and C as well as having done a stint for an ISV, my father is firmly on the &#8220;platform neutrality is important&#8221;. Typically, these discussions turn into childish argument where my father continuously says &#8220;what if&#8221; and I continuously say &#8220;that never happens&#8221; and neither of us actually makes any ground on convincing the other of the error of their ways. <\/p>\n<p>So herein is yet another salvo in the discussion, for your entertainment. It&#8217;s long and drawn out, but since it&#8217;s written it means he can&#8217;t interrupt me to say &#8220;what if&#8221; <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" alt=\":)\" class=\"wp-smiley\" \/> <\/p>\n<p>As mentioned above, my father was at Bell Labs in the early 70&#8242;s when Unix and C were developed. I guess it&#8217;s no surprise that he harps so much on portability &#8211; going back and reading some of the papers that came out of\u00a0Bell Labs at the time, it&#8217;s obvious that their culture heavily valued portability. On Dennis Ritchie&#8217;s <a href=\"http:\/\/cm.bell-labs.com\/cm\/cs\/who\/dmr\">site<\/a> (the &#8216;R&#8217; in <a href=\"http:\/\/www.amazon.com\/o\/ASIN\/0131103628\">&#8216;K&amp;R&#8217;<\/a>) there is a wide variety of relevant material including <a href=\"http:\/\/cm.bell-labs.com\/cm\/cs\/who\/dmr\/hist.html\">The Evolution of the Unix Time-sharing System<\/a>, <a href=\"http:\/\/cm.bell-labs.com\/cm\/cs\/who\/dmr\/chist.html\">The Development of the C Language<\/a>, and <a href=\"http:\/\/cm.bell-labs.com\/cm\/cs\/who\/dmr\/portpap.html\">Portability of C Programs and the UNIX System<\/a>. Given the drastic evolution in computing at the time, it&#8217;s not surprising that both Unix and C had portability as primary goals. While I jokingly refer to C&#8217;s portability as &#8220;write once, compile everywhere&#8221;, the reality is that the portability of C and Unix was a key to Unix&#8217;s success. According to the portability article, 95% of the C portion of the Unix kernel required no changes when they ported Unix from PDP-11 to the Interdata 8\/32. Only the core kernel, which was written in assembly, had to be completely rewritten. Even a significant portion of the device drivers ported over to the new machine. <\/p>\n<p>However, C isn&#8217;t just portable. It also provides significant abstraction above assembly code. Anyone who has done any assembly work knows how low level it is and how significant the abstraction jump up to C really is. For example, the simple C statement of &#8220;a = b + c&#8221; requires three lines of assembly code. Here&#8217;s how Ritchie describes C&#8217;s level of abstraction:<\/p>\n<blockquote style=\"MARGIN-TOP: 5pt; MARGIN-BOTTOM: 5pt\"><p>BCPL, B, and C all fit firmly in the traditional procedural family typified by Fortran and Algol 60. They are particularly oriented towards system programming, are small and compactly described, and are amenable to translation by simple compilers. They are `close to the machine&#8217; in that the abstractions they introduce are readily grounded in the concrete data types and operations supplied by conventional computers, and they rely on library routines for input-output and other interactions with an operating system. With less success, they also use library procedures to specify interesting control constructs such as coroutines and procedure closures. At the same time, <i>their abstractions lie at a sufficiently high level that, with care, portability between machines can be achieved<\/i>.\u00a0 (emphasis added) [<a href=\"http:\/\/cm.bell-labs.com\/cm\/cs\/who\/dmr\/chist.html\">The Development of the C Language<\/a> &#8211; <a href=\"http:\/\/cm.bell-labs.com\/cm\/cs\/who\/dmr\/index.html\">Dennis M. Ritchie<\/a>]<\/p>\n<\/blockquote>\n<p>That last sentence is key. C&#8217;s portability derives from raising the level of abstraction. But raising the level of abstraction also had an important productivity impact. Even if you&#8217;re are only building for a single platform and you don&#8217;t care about portability, most people would rather code in C rather than assembly because the raised level of abstraction makes the developer much more productive. However, raising the level of abstraction comes with a performance cost. C is pretty &#8216;close to the machine&#8217; as Richie put it, but there is still a small penalty. If you&#8217;re writing ultra-perf sensitive code, sometimes writing in assembly is necessary. There\u2019s a reason why <a href=\"http:\/\/www.amazon.com\/o\/ASIN\/193176932X\">books on the topic<\/a> keep getting written and the Visual C++ compiler <a href=\"http:\/\/msdn.microsoft.com\/library\/en-us\/vclang\/html\/_core_Assembler_.28.Inline.29_.Topics.asp\">supports inline assembly code<\/a>.<\/p>\n<p>So here&#8217;s my point: Raising the level of abstraction is powerful because it can enable both portability and productivity. However, it also typically carries a performance penalty. As long as the portability and productivity benefits outweigh the performance penalty, everything\u2019s cool. The problem is that productivity is typically WAY <i>WAY<\/i><b><u>WAY<\/u><\/b> more important than portability. So abstractions that enable portability without significant positive productivity benefits will not offset the performance penalty associated with raising the level of abstraction.<\/p>\n<p>The canonical example of &#8220;portability without productivity&#8221; abstraction that leaps to mind today is the Java platform. Certainly, Java has been pretty successful, though I would argue that its success has been extremely localized. Java on the client has never had mass adoption (the only non-toy Java client app I can think of off the top of my head is Eclipse) and the many of the parts of Java on the server bear a striking resemblance to Microsoft technology. (ODBC vs. JDBC, ASP vs. JSP, Session beans vs. MTS, etc.) Either way, Java adoption has fallen below .NET adoption even though Java had the promise of platform neutrality as well as several years head start. [1]<\/p>\n<p>I would argue that one of the main reasons that Java has had only limited success is that while Java is portable, it doesn&#8217;t provide much in the way of productivity improvements. Sure, garbage collection is much easier to program to than C++&#8217;s explicit memory management model. But Java&#8217;s primary competitor (at least in hindsight) was Visual Basic, not C++. While Java focused on portability, VB focused on productivity and in the end it was productivity that drove VB&#8217;s massive market share. If you were a Java developer, you had worse tools than VB and worse performance than C++ and the only advantage you had was portability which turned out to be more problematic and less important than advertised. Server apps are rarely re-platformed and Java&#8217;s UI implementation caused as many problems as it solved.<\/p>\n<p>From a geek aesthetic perspective, you would have guessed that Java with its clean language and programming model would crush VB and COM in the marketplace, but it just didn&#8217;t happen. VB, with its <a href=\"http:\/\/devhawk.net\/2004\/08\/29\/The+Most+Popular+Modeling+Environment+Ever+So+Far.aspx\">software factory-esque approach<\/a>, was easier to use and thus attracted more developers who got more apps written. I&#8217;d guess that ease of use \/ developer productivity is the key indicator of success for programming environments. If Java had focused on productivity and portability, I might be working for Sun today. <\/p>\n<p style=\"FONT-SIZE: smaller\">[1] Obviously, there are varying opinions on this point. <a href=\"http:\/\/www.microsoft.com\/presspass\/exec\/steve\/2005\/06-06TechEd.mspx\">SteveB said @ TechEd<\/a> that .NET is the weapon of choice (my words not his) for 43% of all developers. Java was second with 35% and non .NET Windows development was third (no percentage given).\u00a0 Even if you want to nit-pick on the numbers, you\u2019d be hard pressed to argue that Java hasn\u2019t been losing ground dramatically to .NET in the past three years since VS 2002 RTMed. <\/p>\n","excerpt":"<p>I said this was going to be a slow week, so I dug out something I wrote while I was on paternity leave. I was saving it for a rainy day, which is pretty silly since if it was raining I wouldn&#8217;t mind staying indoors and writing long posts about levels of abstraction, portability and [&hellip;]<\/p>\n","date":"2005-09-08 10:32:19","modified":"2005-09-08 10:32:19","categories":[{"id":177,"slug":"architecture","title":"Architecture","description":"","parent":0,"post_count":296}],"tags":[],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":2843,"name":"Larry O'Brien","url":"http:\/\/www.knowing.net\/","date":"2005-09-08 12:26:21","content":"<p>Your point is a good one, but it&#8217;s harmed by your choice of Java as an example. If you chose server-side development as your benchmark, Java would come out ahead of VB in adoption. Meanwhile, your point on the relationship between productivity, performance, and abstraction is strengthened when memory management is taken as the subject: is the abstraction of managed memory a productivity boost? Absolutely. Is it lower in performance? Yes, when compared to a skilled developer. <\/p>\n<p>Saying that Java is\/was primarily competitive with VB is too revisionist. Java came out at the beginning of the massive wave of server-side \/ Web development and crushed C++ and Perl as the preferred environment for that type of programming. Java&#8217;s original APIs included network and threading libraries that were both easier than any others and standardized, creating a perfect little ecosystem of programmers, educators, and business people, all eager to move into this new realm. <\/p>\n<p>At that point, server-side portability _was_ important because business people _did not know_ if Microsoft would deliver a stable and scalable server OS. In the mid-to-late 90s, hedging your bets over server-side OS choice was a good decision from both a business and technical perspective.<\/p>\n<p>Now, that&#8217;s no longer an issue and part of the reason that .NET has more momentum than Java is precisely because the \/. crowd is the only one left that thinks that MS hasn&#8217;t proved itself on the server. <\/p>\n","parent":0},{"id":2844,"name":"Pawel","url":"","date":"2005-09-08 21:59:24","content":"<p>You have made a perfect point about productivity. In late &#8217;90, when first Java app servers came out, most of the server development was either on RS6000 or on Solaris. The only abstractions available were those provided by Rogue Wave toolkits and CORBA IDL. So Java introduced an enormous productivity boost for server applications. <\/p>\n<p>At the same time, however, it was portability which made Java viable economically for IBM, BEA and others. It changed recurring cost of chasing OS\/library versions into much smaller cost of upgrades to subsequent JVM levels. SUN has helped a lot in that area with relatively slow pace of innovation between JDK 1.2 and JDK 1.3.<\/p>\n<p>There is no doubt that portability brings little benefit to developers of business applications. Maybe with exception of programming on Windows\/ hosting on Unix scheme. But there would be no Linux and no Java without it.<\/p>\n","parent":0},{"id":2845,"name":"DevHawk","url":"","date":"2005-09-13 10:07:22","content":"<p>Larry, while I apprectiate your comments, I have to disagree with some of your points about Java. Java was originally pushed as a client side technology. Remember the failed WordPerfect for Java project? Sun started pushing Java on the server because of the rise of web servers and the failure of Java on the client. <\/p>\n<p>As for the stable and scalable server OS point, that would be much easier to agree with if the Java server stack wasn&#8217;t so obviously cloned from Windows. Also, if you include VBScript under the general heading of VB, I&#8217;m not sure that Java would come out ahead of VB in adoption. I don&#8217;t have access to numbers right this second, but if memory serves, there were ASP than JSP sites out there in the late 90&#8242;s.<\/p>\n","parent":0}],"attachments":[],"comment_count":3,"comment_status":"closed","custom_fields":{"dasblog_entryid":["503c5712-df5e-4a56-a558-2567d7c554cc"],"dasblog_compressedtitle":["Portability+Without+Productivity"],"dasblog_compressedtitleunique":["2005\/09\/08\/Portability+Without+Productivity"]}},"previous_url":"http:\/\/devhawk.net\/2005\/09\/08\/short-week\/","next_url":"http:\/\/devhawk.net\/2005\/09\/13\/devhawk-on-c9\/"}