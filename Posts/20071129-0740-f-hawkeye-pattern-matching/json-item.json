{"status":"ok","post":{"id":1059,"type":"post","slug":"f-hawkeye-pattern-matching","url":"http:\/\/devhawk.net\/2007\/11\/29\/f-hawkeye-pattern-matching\/","status":"publish","title":"F# Hawkeye : Pattern Matching","title_plain":"F# Hawkeye : Pattern Matching","content":"<p><em>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that&#8217;s turned out to be infeasible. So instead, you get a series of pre-written posts about F#.)<\/em><\/p>\n<p>Most FP languages include some type of pattern matching, and F# is no exception. At first blush, pattern matching looks a little like a switch statement, but it&#8217;s much more powerful. Where switch statements typically only do simple matches such as &#8220;does this variable equal this constant?&#8221;. In F#, you can break apart types, use wildcards even pass the potential match data into a custom function to determines if there&#8217;s a match. Of course, you can also do your more run-of-the-mill &#8220;does value equal constant&#8221; comparisons as well.<\/p>\n<p>The problem with most functional language is that while pattern matching is powerful, it&#8217;s not particularly extensible. As Don pointed out in a <a href=\"http:\/\/blogs.msdn.com\/dsyme\/archive\/2007\/04\/07\/draft-paper-on-f-active-patterns.aspx\">recent paper<\/a>, this becomes a real problem when trying to integrate FP with OO. OO is designed to hide details behind abstractions. Yet those abstractions can&#8217;t be used in pattern matching. Luckily, Don and the F# Guys (sounds like a band) have invented an extensible pattern matching syntax called Active Patterns to deal with this problem. Basically, in more recent versions of F#, you can adorn functions with special syntax so that you can use them in your pattern matching clauses.<\/p>\n<p>This turns out to be wicked cool for writing parsers. I&#8217;m building recursive descent parsers, so each grammar production is implemented as a function. Yet, since I&#8217;m using the active pattern syntax, I can use them in pattern matching clauses. This allows me to chain together functions in a single match clause rather than having multiple match statements. And it&#8217;s very readable. For example, the function to recognize the grammar production &#8220;Additive&nbsp; &lt;- Multitive \u2018+\u2019 Additive | Multitive&#8221; is translated into the following F#:<\/p>\n<pre class=\"brush: fsharp\">and (|Additive|_|) input =\r\n    match input with\r\n    | Multitive(v1,Token '+' (Additive(v2, input))) -&gt; Some(v1+v2,input)\r\n    | Multitive(v,input) -&gt; Some(v,input)\r\n    | _ -&gt; None<\/pre>\n<p>The weird &#8220;bananas&#8221; around Additive on the first line indicate this is an active pattern. Multitive and Token are also an active patterns. This syntax is a little parens heavy, but otherwise, that translation from grammar to F# is nearly declarative. It almost defeats the need for having a parser generator when building a parser is this straightforward. Almost.<\/p>\n","excerpt":"<p>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that&#8217;s turned out to be infeasible. So instead, you get a series of pre-written posts about F#.) Most FP languages include some type of pattern matching, and F# is no exception. At first blush, [&hellip;]<\/p>\n","date":"2007-11-29 07:40:04","modified":"2011-04-17 00:32:49","categories":[],"tags":[{"id":198,"slug":"f-sharp","title":"F#","description":"","post_count":51}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[{"id":1989,"name":"Alex Hendrson","url":"http:\/\/blog.bittercoder.com\/","date":"2007-12-01 21:05:36","content":"<p>Out of curiosity, are you able to post any of your parser code? I&#8217;m only just getting into F# as and when I have spare time &#8211; but I&#8217;m interested in if\/how you tokenize your input string using F# code before parsing the stream of tokens via pattern matching &#8211; I&#8217;ve been attempting to use regex Active Patterns so far, and the results aren&#8217;t pretty (possibly because I haven&#8217;t quite &#8220;grokked&#8221; how best to use Active Patterns to their full potential).<\/p>\n<p>Keep up the good posts on F#!<\/p>\n<p>Chez,<\/p>\n<p> &#8211; Alex<\/p>\n","parent":0},{"id":1990,"name":"DevHawk","url":"","date":"2007-12-03 11:07:43","content":"<p>Will do &#8211; just let me get caught up at work first!<\/p>\n","parent":0},{"id":1991,"name":"Tony Nassar","url":"http:\/\/slideguitarist.blogspot.com\/","date":"2007-12-08 07:27:23","content":"<p>Does your weaponly also comprise such elements as &#8220;nice red uniforms&#8221;? <\/p>\n<p>I&#8217;d love to see the parser, too, as I&#8217;ll soon be embarking on one of my own, though I&#8217;ll be using fslex and fsyacc for practice. I&#8217;ll post about it. The Active Pattern thing is mind-blowing. <\/p>\n","parent":0},{"id":1992,"name":"DevHawk","url":"","date":"2007-12-08 15:58:02","content":"<p>I didn&#8217;t expect a kind of Spanish Inquisition! <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" alt=\":)\" class=\"wp-smiley\" \/> <\/p>\n","parent":0},{"id":1993,"name":"Art Scott","url":"","date":"2007-12-10 11:29:03","content":"<p>I&#8217;m interested in generating various classes of pictures using grammars.<\/p>\n<p>I&#8217;ve worked through the included intro fslex fsyacc examples from Microsoft, Foundations of F#, and F# Journal; each has its&#8217;differences.<\/p>\n<p>Just ordered F# Expert, and considering geting OCaml book.<br \/>\nI&#8217;m always interested in more intelligible code examples.<\/p>\n<p>Glad to find you&#8217;re a resource.<\/p>\n","parent":0}],"attachments":[],"comment_count":5,"comment_status":"closed","custom_fields":{"dasblog_entryid":["13219b39-a182-4488-a97d-2dc78e63780e"],"dasblog_compressedtitle":["F+Hawkeye+Pattern+Matching"],"dasblog_compressedtitleunique":["2007\/11\/29\/F+Hawkeye+Pattern+Matching"]}},"previous_url":"http:\/\/devhawk.net\/2007\/11\/28\/f-hawkeye-functional-programming\/","next_url":"http:\/\/devhawk.net\/2007\/11\/29\/f-hawkeye-type-inference\/"}