<p><em>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that&#8217;s turned out to be infeasible. So instead, you get a series of pre-written posts about F#.)</em></p>
<p>Most FP languages include some type of pattern matching, and F# is no exception. At first blush, pattern matching looks a little like a switch statement, but it&#8217;s much more powerful. Where switch statements typically only do simple matches such as &#8220;does this variable equal this constant?&#8221;. In F#, you can break apart types, use wildcards even pass the potential match data into a custom function to determines if there&#8217;s a match. Of course, you can also do your more run-of-the-mill &#8220;does value equal constant&#8221; comparisons as well.</p>
<p>The problem with most functional language is that while pattern matching is powerful, it&#8217;s not particularly extensible. As Don pointed out in a <a href="http://blogs.msdn.com/dsyme/archive/2007/04/07/draft-paper-on-f-active-patterns.aspx">recent paper</a>, this becomes a real problem when trying to integrate FP with OO. OO is designed to hide details behind abstractions. Yet those abstractions can&#8217;t be used in pattern matching. Luckily, Don and the F# Guys (sounds like a band) have invented an extensible pattern matching syntax called Active Patterns to deal with this problem. Basically, in more recent versions of F#, you can adorn functions with special syntax so that you can use them in your pattern matching clauses.</p>
<p>This turns out to be wicked cool for writing parsers. I&#8217;m building recursive descent parsers, so each grammar production is implemented as a function. Yet, since I&#8217;m using the active pattern syntax, I can use them in pattern matching clauses. This allows me to chain together functions in a single match clause rather than having multiple match statements. And it&#8217;s very readable. For example, the function to recognize the grammar production &#8220;Additive&nbsp; &lt;- Multitive &#8216;+&#8217; Additive | Multitive&#8221; is translated into the following F#:</p>
<pre class="brush: fsharp">and (|Additive|_|) input =
    match input with
    | Multitive(v1,Token '+' (Additive(v2, input))) -&gt; Some(v1+v2,input)
    | Multitive(v,input) -&gt; Some(v,input)
    | _ -&gt; None</pre>
<p>The weird &#8220;bananas&#8221; around Additive on the first line indicate this is an active pattern. Multitive and Token are also an active patterns. This syntax is a little parens heavy, but otherwise, that translation from grammar to F# is nearly declarative. It almost defeats the need for having a parser generator when building a parser is this straightforward. Almost.</p>
