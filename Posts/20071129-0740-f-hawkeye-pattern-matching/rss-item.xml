<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>F# Hawkeye : Pattern Matching</title>
  <link>http://devhawk.net/2007/11/29/f-hawkeye-pattern-matching/</link>
  <pubDate>Thu, 29 Nov 2007 07:40:04 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://13219b39-a182-4488-a97d-2dc78e63780e</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<em>(Harry is @ DevTeach in Vancounver with his family this week. He was hoping to still do Morning Coffee posts, but that's turned out to be infeasible. So instead, you get a series of pre-written posts about F#.)</em>

Most FP languages include some type of pattern matching, and F# is no exception. At first blush, pattern matching looks a little like a switch statement, but it's much more powerful. Where switch statements typically only do simple matches such as "does this variable equal this constant?". In F#, you can break apart types, use wildcards even pass the potential match data into a custom function to determines if there's a match. Of course, you can also do your more run-of-the-mill "does value equal constant" comparisons as well.

The problem with most functional language is that while pattern matching is powerful, it's not particularly extensible. As Don pointed out in a <a href="http://blogs.msdn.com/dsyme/archive/2007/04/07/draft-paper-on-f-active-patterns.aspx">recent paper</a>, this becomes a real problem when trying to integrate FP with OO. OO is designed to hide details behind abstractions. Yet those abstractions can't be used in pattern matching. Luckily, Don and the F# Guys (sounds like a band) have invented an extensible pattern matching syntax called Active Patterns to deal with this problem. Basically, in more recent versions of F#, you can adorn functions with special syntax so that you can use them in your pattern matching clauses.

This turns out to be wicked cool for writing parsers. I'm building recursive descent parsers, so each grammar production is implemented as a function. Yet, since I'm using the active pattern syntax, I can use them in pattern matching clauses. This allows me to chain together functions in a single match clause rather than having multiple match statements. And it's very readable. For example, the function to recognize the grammar production "Additive&nbsp; &lt;- Multitive ‘+’ Additive | Multitive" is translated into the following F#:
<pre class="brush: fsharp">and (|Additive|_|) input =
    match input with
    | Multitive(v1,Token '+' (Additive(v2, input))) -&gt; Some(v1+v2,input)
    | Multitive(v,input) -&gt; Some(v,input)
    | _ -&gt; None</pre>
The weird "bananas" around Additive on the first line indicate this is an active pattern. Multitive and Token are also an active patterns. This syntax is a little parens heavy, but otherwise, that translation from grammar to F# is nearly declarative. It almost defeats the need for having a parser generator when building a parser is this straightforward. Almost.]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1059</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-11-29 07:40:04</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-11-29 07:40:04</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">f-hawkeye-pattern-matching</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="f-sharp"><![CDATA[F#]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[13219b39-a182-4488-a97d-2dc78e63780e]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[F+Hawkeye+Pattern+Matching]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/11/29/F+Hawkeye+Pattern+Matching]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>1989</wp:comment_id>
    <wp:comment_author><![CDATA[Alex Hendrson]]></wp:comment_author>
    <wp:comment_author_email>bittercoder@gmail.com</wp:comment_author_email>
    <wp:comment_author_url>http://blog.bittercoder.com/</wp:comment_author_url>
    <wp:comment_author_IP>60.234.250.81</wp:comment_author_IP>
    <wp:comment_date>2007-12-01 21:05:36</wp:comment_date>
    <wp:comment_date_gmt>2007-12-02 05:05:36</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Out of curiosity, are you able to post any of your parser code? I'm only just getting into F# as and when I have spare time - but I'm interested in if/how you tokenize your input string using F# code before parsing the stream of tokens via pattern matching - I've been attempting to use regex Active Patterns so far, and the results aren't pretty (possibly because I haven't quite "grokked" how best to use Active Patterns to their full potential).

Keep up the good posts on F#!

Chez,

 - Alex]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>1990</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>131.107.0.102</wp:comment_author_IP>
    <wp:comment_date>2007-12-03 11:07:43</wp:comment_date>
    <wp:comment_date_gmt>2007-12-03 19:07:43</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Will do - just let me get caught up at work first!]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>1991</wp:comment_id>
    <wp:comment_author><![CDATA[Tony Nassar]]></wp:comment_author>
    <wp:comment_author_email>linux@anthonynassar.com</wp:comment_author_email>
    <wp:comment_author_url>http://slideguitarist.blogspot.com/</wp:comment_author_url>
    <wp:comment_author_IP>151.200.150.88</wp:comment_author_IP>
    <wp:comment_date>2007-12-08 07:27:23</wp:comment_date>
    <wp:comment_date_gmt>2007-12-08 15:27:23</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Does your weaponly also comprise such elements as "nice red uniforms"? 

I'd love to see the parser, too, as I'll soon be embarking on one of my own, though I'll be using fslex and fsyacc for practice. I'll post about it. The Active Pattern thing is mind-blowing. ]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>1992</wp:comment_id>
    <wp:comment_author><![CDATA[DevHawk]]></wp:comment_author>
    <wp:comment_author_email>harry@devhawk.net</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>24.16.13.109</wp:comment_author_IP>
    <wp:comment_date>2007-12-08 15:58:02</wp:comment_date>
    <wp:comment_date_gmt>2007-12-08 23:58:02</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I didn't expect a kind of Spanish Inquisition! :)]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>1993</wp:comment_id>
    <wp:comment_author><![CDATA[Art Scott]]></wp:comment_author>
    <wp:comment_author_email>art_scott@msn.com</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>68.127.27.107</wp:comment_author_IP>
    <wp:comment_date>2007-12-10 11:29:03</wp:comment_date>
    <wp:comment_date_gmt>2007-12-10 19:29:03</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I'm interested in generating various classes of pictures using grammars.

I've worked through the included intro fslex fsyacc examples from Microsoft, Foundations of F#, and F# Journal; each has its'differences.

Just ordered F# Expert, and considering geting OCaml book.
I'm always interested in more intelligible code examples.

Glad to find you're a resource.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>