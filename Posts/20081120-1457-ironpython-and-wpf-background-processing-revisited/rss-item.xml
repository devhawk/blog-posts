<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>IronPython and WPF Background Processing Revisited</title>
  <link>http://devhawk.net/2008/11/20/ironpython-and-wpf-background-processing-revisited/</link>
  <pubDate>Thu, 20 Nov 2008 14:57:18 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://cb662cda-a1c5-46fb-a936-4d662cf87551</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p><a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">Yesterday</a>, I blogged about using decorators to indicate if a given function should execute on the UI or background thread. While the solution works, I wrote “I’m thinking there might be a way to use <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.aspx">SynchronizationContext</a> to marshal it automatically, but I haven’t tried to figure that out yet.” I had some time this morning so I figured out how to use SynchronizationContext instead of the WPF dispatcher. </p><p>Leslie Sanford wrote a <a href="http://www.codeproject.com/KB/cpp/SyncContextTutorial.aspx">pretty good overview</a>, but the short version is that SyncContext is an abstraction for concurrency management. It lets you write code that is ignorant of specific synchronization mechanisms in concurrency-aware managed frameworks like WinForms and WPF. For example, while my previous version worked fine, it was specific to WPF. If I wanted to provide similar functionality that worked with WinForms, I’d have to rewrite my decorators to use Control.Invoke. But if I port them over to use SyncContext, they would work with WinForms, WPF and any other library that plugs into SyncContext.</p><p>SyncContext abstracts away both initially obtaining the sync context as well as marshaling calls back to the UI thread. SyncContext provides a <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.current.aspx">static property</a> to access  current context, instead of a framework specific mechanism like accessing the <a href="http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcherobject.dispatcher.aspx">Dispatcher</a> property of the WPF <a href="http://msdn.microsoft.com/en-us/library/system.windows.window.aspx">Window</a> class. Once you have a context, you can call <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.send.aspx">Send</a> or <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.post.aspx">Post</a> to marshal the call back to the UI thread (Send blocks the calling thread, Post doesn’t). </p><p>With that in mind, here’s the new version of BGThread and UIThread. Slightly more complex, but still pretty simple clocking in at just under 30 lines. </p><pre class="brush: python">
def BGThread(fun):  
  def argUnpacker(args):  
    oldSyncContext = SynchronizationContext.Current     
    try:     
      SynchronizationContext.SetSynchronizationContext(args[-1])     
      fun(*args[:-1])     
    finally:     
      SynchronizationContext.SetSynchronizationContext(oldSyncContext)     
   
  def wrapper(*args):     
    args2 = args + (SynchronizationContext.Current,)     
    ThreadPool.QueueUserWorkItem(WaitCallback(argUnpacker), args2)     
   
  return wrapper     

def UIThread(fun):     
  def unpack(args):  
    ret = fun(*args)     
    if ret != None:     
      import warnings     
      warnings.warn(fun.__name__ + " function returned " + str(ret) + " but that return value isn't propigated to the calling thread")     

  def wrapper(*args):     
    if SynchronizationContext.Current == None:     
      fun(*args)     
    else:     
      SynchronizationContext.Current.Send(SendOrPostCallback(unpack), args)     
      
  return wrapper
</pre><p>In the BGThread wrapper, I add the current SyncContext to the parameter tuple that I pass to the background thread. Once on the background thread, I set the current SyncContext to the last element of the the parameter tuple then call the decorated function with the remaining parameters. (for the non pythonic: args[:-1] is <a href="http://www.python.org/doc/2.5.2/ref/slicings.html">Python slicing syntax</a> that means “all but the last element of args”). Using a try/finally block is probably overkill – I expect the current SyncContext to be either None or leftover garbage – but the urge to clean up after myself is apparently much stronger on the background thread than it is in say my office. :)</p><p>In the UIThread wrapper, I grab the current context and invoke the decorated method via the Send method. Like QueueUserWorkItem, SyncContext Send and Post only support a single parameter, so I use the same *args trick I <a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">described</a> in my last post. (I changed the name to unpack in the code above for blog formatting purposes)</p><p>One major caveat about this approach is that there’s no way to return a value from a function decorated as UIThread. I understand why SyncContext.Post doesn’t return a value (it’s async) but SyncContext.Send is synchronous call, so why doesn’t it marshal the return value back to the calling thread? WPF’s <a href="http://msdn.microsoft.com/en-us/library/cc647509.aspx">Dispatcher.Invoke</a> and WinForm’s <a href="http://msdn.microsoft.com/en-us/library/a1hetckb.aspx">Control.Invoke</a> both return a value. I didn’t handle the return value in my original version of UIThread, but now that I’ve moved over to using SyncContext, I can’t. Not sure why the SyncContext is designed that way – seems like a design flaw to me. Since the return value won’t propagate, I sniff the result decorated function’s return value and raise a warning if it’s not None. </p><p>I’ve uploaded the SyncContext version <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/WpfThreadDemo2.zip">to my SkyDrive</a> in case you want the code for yourself. Note, I’ll thinking I’ll revise code this one more time – I want to rebuild the WPF version so that it propagates return values and picks up an dispatcher via Application.Current.MainWindow rather than having to have a dispatcher property on my class. </p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1192</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2008-11-20 14:57:18</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2008-11-20 14:57:18</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">ironpython-and-wpf-background-processing-revisited</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="parallel-programming"><![CDATA[Parallel Programming]]></category>
  <category domain="post_tag" nicename="wpf"><![CDATA[WPF]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[cb662cda-a1c5-46fb-a936-4d662cf87551]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[IronPython+And+WPF+Background+Processing+Revisited]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2008/11/20/IronPython+And+WPF+Background+Processing+Revisited]]></wp:meta_value>
  </wp:postmeta>
</item>