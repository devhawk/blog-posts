{"status":"ok","post":{"id":1192,"type":"post","slug":"ironpython-and-wpf-background-processing-revisited","url":"http:\/\/devhawk.net\/2008\/11\/20\/ironpython-and-wpf-background-processing-revisited\/","status":"publish","title":"IronPython and WPF Background Processing Revisited","title_plain":"IronPython and WPF Background Processing Revisited","content":"<p><a href=\"http:\/\/devhawk.net\/2008\/11\/19\/IronPython+And+WPF+Part+4+Background+Processing.aspx\">Yesterday<\/a>, I blogged about using decorators to indicate if a given function should execute on the UI or background thread. While the solution works, I wrote \u201cI\u2019m thinking there might be a way to use <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.synchronizationcontext.aspx\">SynchronizationContext<\/a> to marshal it automatically, but I haven\u2019t tried to figure that out yet.\u201d I had some time this morning so I figured out how to use SynchronizationContext instead of the WPF dispatcher. <\/p>\n<p>Leslie Sanford wrote a <a href=\"http:\/\/www.codeproject.com\/KB\/cpp\/SyncContextTutorial.aspx\">pretty good overview<\/a>, but the short version is that SyncContext is an abstraction for concurrency management. It lets you write code that is ignorant of specific synchronization mechanisms in concurrency-aware managed frameworks like WinForms and WPF. For example, while my previous version worked fine, it was specific to WPF. If I wanted to provide similar functionality that worked with WinForms, I\u2019d have to rewrite my decorators to use Control.Invoke. But if I port them over to use SyncContext, they would work with WinForms, WPF and any other library that plugs into SyncContext.<\/p>\n<p>SyncContext abstracts away both initially obtaining the sync context as well as marshaling calls back to the UI thread. SyncContext provides a <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.synchronizationcontext.current.aspx\">static property<\/a> to access\u00a0 current context, instead of a framework specific mechanism like accessing the <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.windows.threading.dispatcherobject.dispatcher.aspx\">Dispatcher<\/a> property of the WPF <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.windows.window.aspx\">Window<\/a> class. Once you have a context, you can call <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.synchronizationcontext.send.aspx\">Send<\/a> or <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/system.threading.synchronizationcontext.post.aspx\">Post<\/a> to marshal the call back to the UI thread (Send blocks the calling thread, Post doesn\u2019t). <\/p>\n<p>With that in mind, here\u2019s the new version of BGThread and UIThread. Slightly more complex, but still pretty simple clocking in at just under 30 lines. <\/p>\n<pre class=\"brush: python\">\ndef BGThread(fun):  \n  def argUnpacker(args):  \n    oldSyncContext = SynchronizationContext.Current     \n    try:     \n      SynchronizationContext.SetSynchronizationContext(args[-1])     \n      fun(*args[:-1])     \n    finally:     \n      SynchronizationContext.SetSynchronizationContext(oldSyncContext)     \n   \n  def wrapper(*args):     \n    args2 = args + (SynchronizationContext.Current,)     \n    ThreadPool.QueueUserWorkItem(WaitCallback(argUnpacker), args2)     \n   \n  return wrapper     \n\ndef UIThread(fun):     \n  def unpack(args):  \n    ret = fun(*args)     \n    if ret != None:     \n      import warnings     \n      warnings.warn(fun.__name__ + \" function returned \" + str(ret) + \" but that return value isn't propigated to the calling thread\")     \n\n  def wrapper(*args):     \n    if SynchronizationContext.Current == None:     \n      fun(*args)     \n    else:     \n      SynchronizationContext.Current.Send(SendOrPostCallback(unpack), args)     \n      \n  return wrapper\n<\/pre>\n<p>In the BGThread wrapper, I add the current SyncContext to the parameter tuple that I pass to the background thread. Once on the background thread, I set the current SyncContext to the last element of the the parameter tuple then call the decorated function with the remaining parameters. (for the non pythonic: args[:-1] is <a href=\"http:\/\/www.python.org\/doc\/2.5.2\/ref\/slicings.html\">Python slicing syntax<\/a> that means \u201call but the last element of args\u201d). Using a try\/finally block is probably overkill \u2013 I expect the current SyncContext to be either None or leftover garbage \u2013 but the urge to clean up after myself is apparently much stronger on the background thread than it is in say my office. <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" class=\"grouped_elements\" rel=\"tc-fancybox-group1192\" alt=\":)\" class=\"wp-smiley\" \/> <\/p>\n<p>In the UIThread wrapper, I grab the current context and invoke the decorated method via the Send method. Like QueueUserWorkItem, SyncContext Send and Post only support a single parameter, so I use the same *args trick I <a href=\"http:\/\/devhawk.net\/2008\/11\/19\/IronPython+And+WPF+Part+4+Background+Processing.aspx\">described<\/a> in my last post. (I changed the name to unpack in the code above for blog formatting purposes)<\/p>\n<p>One major caveat about this approach is that there\u2019s no way to return a value from a function decorated as UIThread. I understand why SyncContext.Post doesn\u2019t return a value (it\u2019s async) but SyncContext.Send is synchronous call, so why doesn\u2019t it marshal the return value back to the calling thread? WPF\u2019s <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/cc647509.aspx\">Dispatcher.Invoke<\/a> and WinForm\u2019s <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/a1hetckb.aspx\">Control.Invoke<\/a> both return a value. I didn\u2019t handle the return value in my original version of UIThread, but now that I\u2019ve moved over to using SyncContext, I can\u2019t. Not sure why the SyncContext is designed that way \u2013 seems like a design flaw to me. Since the return value won\u2019t propagate, I sniff the result decorated function\u2019s return value and raise a warning if it\u2019s not None. <\/p>\n<p>I\u2019ve uploaded the SyncContext version <a href=\"http:\/\/cid-0d9bc809858885a4.skydrive.live.com\/self.aspx\/DevHawk%20Content\/IronPython%20Stuff\/WpfThreadDemo2.zip\">to my SkyDrive<\/a> in case you want the code for yourself. Note, I\u2019ll thinking I\u2019ll revise code this one more time \u2013 I want to rebuild the WPF version so that it propagates return values and picks up an dispatcher via Application.Current.MainWindow rather than having to have a dispatcher property on my class. <\/p>\n","excerpt":"<p>Yesterday, I blogged about using decorators to indicate if a given function should execute on the UI or background thread. While the solution works, I wrote \u201cI\u2019m thinking there might be a way to use SynchronizationContext to marshal it automatically, but I haven\u2019t tried to figure that out yet.\u201d I had some time this morning [&hellip;]<\/p>\n","date":"2008-11-20 14:57:18","modified":"2008-11-20 14:57:18","categories":[{"id":252,"slug":"ironpython","title":"IronPython","description":"","parent":0,"post_count":99}],"tags":[{"id":272,"slug":"parallel-programming","title":"Parallel Programming","description":"","post_count":3},{"id":271,"slug":"wpf","title":"WPF","description":"","post_count":8}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[],"comment_count":0,"comment_status":"closed","custom_fields":{"dasblog_entryid":["cb662cda-a1c5-46fb-a936-4d662cf87551"],"dasblog_compressedtitle":["IronPython+And+WPF+Background+Processing+Revisited"],"dasblog_compressedtitleunique":["2008\/11\/20\/IronPython+And+WPF+Background+Processing+Revisited"]}},"previous_url":"http:\/\/devhawk.net\/2008\/11\/19\/ironpython-and-wpf-part-4-background-processing\/","next_url":"http:\/\/devhawk.net\/2008\/11\/21\/introducing-ironpython-article\/"}