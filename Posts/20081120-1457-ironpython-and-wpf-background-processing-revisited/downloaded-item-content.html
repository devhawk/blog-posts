<p><a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">Yesterday</a>, I blogged about using decorators to indicate if a given function should execute on the UI or background thread. While the solution works, I wrote &#8220;I&#8217;m thinking there might be a way to use <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.aspx">SynchronizationContext</a> to marshal it automatically, but I haven&#8217;t tried to figure that out yet.&#8221; I had some time this morning so I figured out how to use SynchronizationContext instead of the WPF dispatcher. </p>
<p>Leslie Sanford wrote a <a href="http://www.codeproject.com/KB/cpp/SyncContextTutorial.aspx">pretty good overview</a>, but the short version is that SyncContext is an abstraction for concurrency management. It lets you write code that is ignorant of specific synchronization mechanisms in concurrency-aware managed frameworks like WinForms and WPF. For example, while my previous version worked fine, it was specific to WPF. If I wanted to provide similar functionality that worked with WinForms, I&#8217;d have to rewrite my decorators to use Control.Invoke. But if I port them over to use SyncContext, they would work with WinForms, WPF and any other library that plugs into SyncContext.</p>
<p>SyncContext abstracts away both initially obtaining the sync context as well as marshaling calls back to the UI thread. SyncContext provides a <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.current.aspx">static property</a> to access&nbsp; current context, instead of a framework specific mechanism like accessing the <a href="http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcherobject.dispatcher.aspx">Dispatcher</a> property of the WPF <a href="http://msdn.microsoft.com/en-us/library/system.windows.window.aspx">Window</a> class. Once you have a context, you can call <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.send.aspx">Send</a> or <a href="http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.post.aspx">Post</a> to marshal the call back to the UI thread (Send blocks the calling thread, Post doesn&#8217;t). </p>
<p>With that in mind, here&#8217;s the new version of BGThread and UIThread. Slightly more complex, but still pretty simple clocking in at just under 30 lines. </p>
<pre class="brush: python">def BGThread(fun):  
  def argUnpacker(args):  
    oldSyncContext = SynchronizationContext.Current     
    try:     
      SynchronizationContext.SetSynchronizationContext(args[-1])     
      fun(*args[:-1])     
    finally:     
      SynchronizationContext.SetSynchronizationContext(oldSyncContext)     
   
  def wrapper(*args):     
    args2 = args + (SynchronizationContext.Current,)     
    ThreadPool.QueueUserWorkItem(WaitCallback(argUnpacker), args2)     
   
  return wrapper     

def UIThread(fun):     
  def unpack(args):  
    ret = fun(*args)     
    if ret != None:     
      import warnings     
      warnings.warn(fun.__name__ + &quot; function returned &quot; + str(ret) + &quot; but that return value isn't propigated to the calling thread&quot;)     

  def wrapper(*args):     
    if SynchronizationContext.Current == None:     
      fun(*args)     
    else:     
      SynchronizationContext.Current.Send(SendOrPostCallback(unpack), args)     
      
  return wrapper
</pre>
<p>In the BGThread wrapper, I add the current SyncContext to the parameter tuple that I pass to the background thread. Once on the background thread, I set the current SyncContext to the last element of the the parameter tuple then call the decorated function with the remaining parameters. (for the non pythonic: args[:-1] is <a href="http://www.python.org/doc/2.5.2/ref/slicings.html">Python slicing syntax</a> that means &#8220;all but the last element of args&#8221;). Using a try/finally block is probably overkill &#8211; I expect the current SyncContext to be either None or leftover garbage &#8211; but the urge to clean up after myself is apparently much stronger on the background thread than it is in say my office. <img class="grouped_elements" src=".\icon_smile.gif" rel="tc-fancybox-group1192" alt=":)"> </p>
<p>In the UIThread wrapper, I grab the current context and invoke the decorated method via the Send method. Like QueueUserWorkItem, SyncContext Send and Post only support a single parameter, so I use the same *args trick I <a href="http://devhawk.net/2008/11/19/IronPython+And+WPF+Part+4+Background+Processing.aspx">described</a> in my last post. (I changed the name to unpack in the code above for blog formatting purposes)</p>
<p>One major caveat about this approach is that there&#8217;s no way to return a value from a function decorated as UIThread. I understand why SyncContext.Post doesn&#8217;t return a value (it&#8217;s async) but SyncContext.Send is synchronous call, so why doesn&#8217;t it marshal the return value back to the calling thread? WPF&#8217;s <a href="http://msdn.microsoft.com/en-us/library/cc647509.aspx">Dispatcher.Invoke</a> and WinForm&#8217;s <a href="http://msdn.microsoft.com/en-us/library/a1hetckb.aspx">Control.Invoke</a> both return a value. I didn&#8217;t handle the return value in my original version of UIThread, but now that I&#8217;ve moved over to using SyncContext, I can&#8217;t. Not sure why the SyncContext is designed that way &#8211; seems like a design flaw to me. Since the return value won&#8217;t propagate, I sniff the result decorated function&#8217;s return value and raise a warning if it&#8217;s not None. </p>
<p>I&#8217;ve uploaded the SyncContext version <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/WpfThreadDemo2.zip">to my SkyDrive</a> in case you want the code for yourself. Note, I&#8217;ll thinking I&#8217;ll revise code this one more time &#8211; I want to rebuild the WPF version so that it propagates return values and picks up an dispatcher via Application.Current.MainWindow rather than having to have a dispatcher property on my class. </p>
