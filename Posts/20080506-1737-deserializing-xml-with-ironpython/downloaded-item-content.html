<p>Now that I can <a href="http://devhawk.net/2008/05/06/Stream+Processing+XML+In+IronPython.aspx">stream process XML</a>, the next logical step is to deserialize it into some type of object graph. As I said in my last post, there are at least three different DOM-esque options on the .NET platform as well as two in the Python library (<a href="http://docs.python.org/lib/module-xml.dom.html">xml.dom</a> and <a href="http://docs.python.org/lib/module-xml.dom.minidom.html">xml.minidom</a>)</p>
<p>However, anyone who&#8217;s ever programmed against the <a href="http://www.w3.org/DOM/">DOM</a> knows just what a major PITA it is. </p>
<p>Instead, you could deserialize the XML into a custom object tree, based on the nodes in the XML stream. In .NET, there are at least two libraries for doing this: the old-school <a href="http://msdn.microsoft.com/library/system.xml.serialization.xmlserializer">XmlSerializer</a> as well as the new-fangled <a href="http://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer">DataContractSerializer</a>. In these libraries, the PITA comes in defining the static types with all the various custom attribute adornments you need to tell the deserializer how to do it&#8217;s job. Actually, if you&#8217;re defining your code first, all those adornments aren&#8217;t that big a deal. However, if you&#8217;re starting from the XML, especially XML with lots of different namespaces &#8211; like say <a href="http://feeds.feedburner.com/Devhawk">my RSS feed</a> &#8211; defining a static type for this gets old fast. </p>
<p>Of course, if you&#8217;re not using a statically typed language&#8230; <img class="wp-smiley" src=".\icon_wink.gif" alt=";)"> </p>
<p>One of the cool aspects of dynamic languages is the ability to easily generate new types on the fly. In Python, you can create a new type by calling the type function. Here&#8217;s an example of creating a new type for a XML node:</p>
<pre class="brush: python">def create_type(node, parent):  
  return type(node.name, (parent,), {'xmlns':node.namespace})
</pre>
<p>Since I&#8217;m working with XML, I wanted to make sure I handled namespaces. Thus, I add the namespace to the class definition (the third parameter in the type function above). This lets me walk up to any arbitrary object created from an XML element and check it&#8217;s namespace. </p>
<p>I used this dynamic type creation functionality in my <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/xml2py.py">xml2py</a> module, which I added to my <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff">IronPython SkyDrive folder</a>. It leverages <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/ipypulldom.py">ipypulldom</a>, so make sure you get both. The heart of the module is the xml2py function, which recursively iterates thru the node stream and builds the tree. Attributes and child elements become named attributes on the object, so I can write code that looks like this:</p>
<pre class="brush: python">import xml2py  
rss = xml2py.parse('http://feeds.feedburner.com/Devhawk')  
for item in rss.channel.item:  
  print item.title
</pre>
<p>You see? No screwing around with childNodes or getAttribute here.</p>
<p>The basic processing loop of xml2py creates a new instance of a new type when it encounters a start element tag. It then collects all the attributes and children of that element, and adds them as attributes on the element object, using the name of the type as name of the attribute. If there are multiple children with the same type name, xml2py converts that attribute to a list of values. For example, in an RSS feed, there will be likely be many rss.channel.item elements. In xml2py, the item attribute of the channel object will be a list of item objects. </p>
<p>Since attributes and child elements are getting slotted together, I added a _nodetype attribute on each so I can later tell (if I care) if the value was originally an attribute or element. I haven&#8217;t written py2xml yet, but that might be important then.</p>
<p>I do one optimization for simple string elements like &lt;foo&gt;bar&lt;/foo&gt;. In this case, I create a type that inherits from string (hence the need for the parent parameter in the create_type function above) and contains the string text. It still has the xmlns and _nodetype attributes, so I could write item.title.xmlns (which is empty since RSS is in the default namespace) or item.title._nodetype (which would be XmlNodeType.Element)</p>
<p>It&#8217;s not much code &#8211; about 100 lines of code split evenly between the xml2py function and the _type_factory object. Given that you usually see the same element in an XML stream over an over, I didn&#8217;t want to create multiple types for the same element. So _type_factory caches types in a dictionary so I can reuse them. One of the cool things is that it&#8217;s a callable type (i.e. it implements __call__ so I can use the instance like a function. I started by defining a xtype function that didn&#8217;t cache anything, but then later switched xtype to be a _type_factory instance, but none of my code that called xtype had to change!</p>
<p>One other quick note. If you put xml2py.py and ipypylldom.py in a folder, you can experiment with them by launching &#8220;ipy -i xml2py&#8221;. This runs xml2py.py as a script, but dumps you into the interactive console when you&#8217;re thru. It will run the little snippet of code above which runs xml2py on my <a href="http://feeds.feedburner.com/Devhawk">FeedBurner feed</a>, but then you can play around with the rss object and see what it contains. Be sure to check out the xmlns attribute for each object in the rss.channel.link list.</p>
