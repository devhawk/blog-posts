<p>One of the cool things about having a blogging conversation with <a href="http://blogs.msdn.com/garethj">someone on the other side of the world</a> is that while you sleep they are thinking of a <a href="http://blogs.msdn.com/garethj/archive/2005/12/19/505732.aspx">good response</a> to your post. The only downside? Having to deal with rampant misspelling like &#8220;artefacts&#8221;. <img class="grouped_elements" src=".\icon_smile.gif" rel="tc-fancybox-group663" alt=":)"> </p>
<p align="left">Anyway, Gareth responds to <a href="http://devhawk.net/2005/12/19/Imprecise+Vs+Incomplete.aspx">my post</a>:</p>
<blockquote><p>Until we get models that are perfectly aligned with our business domains, we&#8217;ll have people who want to create models but who get them slightly wrong from a precision point of view &#8211; usually in the places where the imperfect models interact with other aspects of the system across or down the abstraction stack.</p>
<p>With code, you&#8217;d likely not want to have people check in sources that don&#8217;t even compile and then hand them off to other folks who do make them compile, but I think that&#8217;s exactly the type of process we&#8217;ll see emerging in modelling for a while. I feel this way because I don&#8217;t foresee us getting modelling languages of <i>pure business intent</i> 100% right for some time yet &#8211; we&#8217;re simply not close enough to formal enough descriptions of systems as intensely human as a business yet. However, I hope we won&#8217;t want to try and keep modelling as locked away with the techies as traditional development has been. (Hope I&#8217;m not talking myself out of a job here&#8230;)</p>
<p>[<a href="http://blogs.msdn.com/garethj/archive/2005/12/19/505732.aspx">Pseudomodels and intent</a>]</p>
</blockquote>
<p>I keep saying incomplete and Gareth keeps saying imprecise, but I think we can both agree on the term &#8220;imperfect&#8221;. There&#8217;s a massive difference between having an precise language that is imperfect versus a language that is inherently imprecise like UML. </p>
<p>However, I think the primary disconnect here has to do with Gareth and my views on how higher abstracted languages will evolve. Gareth&#8217;s comments about modeling &#8220;pure business intent&#8221;, having &#8220;models that are perfectly aligned with our business domains&#8221; and not &#8220;keep[ing] modelling as locked away with the techies&#8221; imply to me that Gareth wants to work down from the high level business abstractions into implementable technical abstractions. Frankly, I don&#8217;t think that&#8217;s very likely. Leapfrogging a few levels of abstraction hasn&#8217;t worked well in the past (CASE and UML/MDA) and I don&#8217;t think it will work well now. </p>
<p>I find it much more likely that we will build higher level abstractions directly on top of existing abstractions. Again, this is similar to the way C++ built on C which in turn built on ASM. Sure, that could keep modeling &#8220;locked away with the techies&#8221; for a while, but we&#8217;re already beginning to see the light at the end of that tunnel. <a href="http://msdn.microsoft.com/windowsvista/building/workflow/default.aspx">Windows Workflow Foundation</a> is a significant leap in abstraction while also being something than non-techies can use. Reports about about Sharepoint &#8220;12&#8243; embedding the WF engine and FrontPage &#8220;12&#8243; providing a Workflow Designer for building SharePoint workflows. While I imagine (and I haven&#8217;t used any of the new Office &#8220;12&#8243; suite so this is pure conjecture) these WF tools are targeting the &#8220;power user&#8221;, they certainly aren&#8217;t only for developers. </p>
<p>Believe me, I would love to be wrong about this. I would much rather work down from or business user intent than up from the technical foundation. I just don&#8217;t think it&#8217;s feasible. The process Gareth describes breaks the &#8220;Model Transformation must be Deterministic&#8221; tenet of <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a>, though the word &#8220;must&#8221; may be to strong to allow for language evolution. </p>
