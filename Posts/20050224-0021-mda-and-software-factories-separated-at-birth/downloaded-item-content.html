<p>Tonight I went to the monthly meeting of the local chapter of <a href="http://www.iasarchitects.org/">IASA</a>. I should have also blogged this&nbsp;before the meeting, but I forgot. Sorry about that if you live near the Microsoft campus and wanted to go. Next meeting is on 3/30, so mark your calendars.</p>
<p>Anyway, tonight&#8217;s topic was an MDA workshop featuring <a href="http://www.andromda.org/">AndroMDA</a>. AndroMDA is an open source tool for generating primarily J2EE code for *nix boxes using UML and MDA. (To be fair, the speaker &#8211; local chapter president Chris Sterling &#8211; demonstrated generating C# code as well. Of course, he ran it under Mono on a Linux box.) This provided a great launching point for a general modeling discussion that helped me get a few things straight in my head. Typically, the UML vs. DSL discussion turns religious pretty quickly. However, I believe that people &#8211; like those a the meeting tonight &#8211; who are achieving practical success with MDA in the real world are doing so by using a <a href="http://www.softwarefactories.com">Software Factories</a> style approach.</p>
<p>First off, if you look at how most people use UML for MDA, the class diagram appears to be the most dominant model used. When I say &#8220;UML for MDA&#8221;, what I mean is people using UML as a <a href="http://www.martinfowler.com/bliki/UmlAsBlueprint.html">blueprint</a>&nbsp;or&nbsp;as a&nbsp;<a href="http://www.martinfowler.com/bliki/UmlAsProgrammingLanguage.html">programming language</a>.&nbsp;While UML has 12 different <a href="http://www.omg.org/gettingstarted/what_is_uml.htm#12DiagramTypes">model types</a>, class diagrams make up the bulk of the modeling effort. (The bulk of AndroMDA code generation works off the <a href="http://www.andromda.org/modeling.html">UML class diagram</a>, though the BPM4Struts cartridge uses Use Case &amp; State models as well) The other 11 diagrams are primarily used for <a href="http://www.martinfowler.com/bliki/UmlAsSketch.html">sketching purposes</a>. That means you&#8217;re only blueprinting the structural aspect of your system &#8211; which in turn means that all the system&#8217;s behavior has to be implemented by hand. Now, this is not to say that factories suggests you should only model the structural aspect of your system. However, I think this indicates that most pragmatic users have realized MDA doesn&#8217;t live up to the hype.</p>
<p>Secondly, the class diagram that are used have to&nbsp;be heavily adorned with custom metadata &#8211; typically in the form of stereotypes &#8211; in order to be useful for code generation (i.e. blueprint) purposes. AndroMDA has a set of &#8220;cartridges&#8221; (essentially, target code generators) such as <a href="http://www.andromda.org/andromda-ejb-cartridge/index.html">EJB</a>, <a href="http://www.andromda.org/andromda-hibernate-cartridge/index.html">Hibernate</a> and <a href="http://www.andromda.org/andromda-java-cartridge/modeling.html">POJOs</a>. Each of these cartridges has a supported set of stereotypes. While there is some overlap (for example, EJB and Hibernate cartridges both define the Entity stereotype). These stereotypes assign brand new semantics to the elements being modeled. In short, they turn the the generic class modeler into a domain specific modeler!</p>
<p>It appears to me that the pragmatic MDA crowd is using the class diagram as a generic &#8220;ball and stick&#8221; editor. Model elements that aren&#8217;t needed are ignored and elements that are needed are added via stereotypes. For example, you can use a class diagram to model a database. Certain elements of the model are ignored (Can a column have protected visibility? Can one table inherit from another?) while other elements specific to the domain being modeled are added (primary and foreign keys, indexes, etc). The problem with this approach is that all of the knowledge of how to build a valid model is in the user&#8217;s head, rather than the tool. Typically, that means a lot of training as well as a lot of in depth understanding of the framework underlying the model in order to capture the right amount of information. Since all that domain specific information is trapped in the users head, they have to do a ton of menial drudge work. It&#8217;s different drudge work from things like writing tons of data access code, but it&#8217;s drudgery nonetheless.</p>
<p>If you&#8217;re going to need a tool specifically designed for your problem domain, why use a generic tool and a bunch of handwritten rules, when you can codify those rules into a domain specific language of your own? (I mean, other than the obvious &#8220;because the <a href="http://lab.msdn.microsoft.com/teamsystem/Workshop/DSLTools/default.aspx">DSL Toolkit</a> hasn&#8217;t shipped yet&#8221;)</p>
