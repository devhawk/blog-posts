<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>JavaScript Utilities</title>
  <link>http://devhawk.net/2005/11/23/javascript-utilities/</link>
  <pubDate>Wed, 23 Nov 2005 12:03:42 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://1c6578cc-02cd-497f-86e7-58392de25eb0</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Can you tell it's a slow day in the office? :)</p><p>Speaking of raising the level of abstraction as well as browser based applications, check out Nikhil's <a href="http://www.nikhilk.net/Project.JSUtils.aspx">JavaScript Utilities project</a>:</p><blockquote dir="ltr" style="MARGIN-RIGHT: 0px"><p>The project introduces the notion of .jsx (extended JavaScript) and .jsa (JavaScript assembly) files. JSX files provide the ability to include conditional code via familiar preprocessor directives such as #if, #else, #endif and so on...The tool processes these directives in order to produce a standard .js file. JSA files build on top of .jsx files. While they can include normal JavaScript and preprocessor directives, they are primarily there for including individual .jsx and .js files via #include directives. This allows you to split your script into more manageable individual chunks.</p></blockquote><p>Now, that's not raising the level of abstraction much, but here's another example of working in a higher abstracted environment (jsx and jsa) and then compiling down to something the underlying platform can execute (js). Nikhil provides three ways of doing this compliation:</p><ol><ol><li>A set of standalone tools that output standard .js files that you can then deploy to your web site. Command line parameters are used to control the behavior of the tools. 
</li><li>A couple of IHttpHandler implementations that allow you to dynamically convert your code into standard .js files. This is the mode where you can benefit from implementing per-browser code in a conditional manner. AppSetting values in configuration are used to control the conversion behavior. 
</li><li>As a script project in VS using an msbuild project along with an msbuild task that comes along with the project. MSBuild project properties are used to control the conversion behavior. </li></ol></ol><p>If you're going to raise the level of abstraction to do implement a preprocessor, you could also go all the way and implement an entirely new language that gets compiled down to JavaScript for execution in the browser. For example, I'm not as familiar or comfortable with JavaScript's <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototype based approach</a>. But I could imagine a more class based language that compiles to JavaScript. That's the same way early C++ compilers worked - they were a preprocessor pass that converted the C++ into C, which could then be compiled with traditional C compilers. </p><p>I wonder what JavaScript++ would look like</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">657</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2005-11-23 12:03:42</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2005-11-23 12:03:42</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">javascript-utilities</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="architecture"><![CDATA[Architecture]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[1c6578cc-02cd-497f-86e7-58392de25eb0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[JavaScript+Utilities]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2005/11/23/JavaScript+Utilities]]></wp:meta_value>
  </wp:postmeta>
</item>