<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Functional Understanding</title>
  <link>http://devhawk.net/2007/12/04/functional-understanding/</link>
  <pubDate>Tue, 04 Dec 2007 17:25:42 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://f5911927-c440-4f2d-8539-1382021b6ae3</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>I was showing some of my cool (well, I think it's cool) F# parsing code to some folks @ DevTeach. I realized very quickly that a) most mainstream developers are fairly unaware of functional programming and b) I suck at explaining why functional programming matters. So I decided to take another stab at it. I probably should have posted this before my <a href="http://devhawk.net/2007/11/28/F+As+A+Second+NET+Language.aspx">recent series on F#</a>, but better late than never I suppose.</p><p>Right off the bat, the term "functional" is confusing. When you say "function" to a mainstream developer, they hear "<a href="http://en.wikipedia.org/wiki/Function_%28computer_science%29">subroutine</a>". But when you say "function" to a mathematician, they hear "<a href="http://en.wikipedia.org/wiki/Function_%28math%29">calculation</a>". Functions in functional programming (aka FP) are closer to the mathematic concept. If you think about math functions, they're very different than subroutines. In particular, math functions have no intrinsic mutable data. If you have a math function like f(x) = x<sup>3</sup>, f(7) always equals 343, no matter how many times you call it. This is very different then a function like String.Length() where the value returned depends on the value of the string. </p><p>Another interesting aspect of math-style functions is that they have no side-effects. When you call StringBuilder.Append(), you're changing the internal state of the StringBuilder object. But FP functions don't work like that. Providing the same input always provides the same output (i.e. the same independent variable always yields the same dependent value). </p><p>If you're a .NET developer, this may sound strange, but you're probably very familiar with the <a href="http://msdn2.microsoft.com/library/system.string.aspx">String class</a> which works exactly the same way.</p><blockquote><p>A <b>String</b> object is a sequential collection of <a href="http://msdn2.microsoft.com/en-us/library/k493b04s.aspx">System.Char</a> objects that represent a string. The value of the <b>String</b> object is the content of the sequential collection, and that value is immutable.  </p><p>A <b>String</b> object is called immutable (read-only) because its value cannot be modified once it has been created. Methods that appear to modify a <b>String</b> object actually return a new <b>String</b> object that contains the modification. </p></blockquote><p>In other words, all variables in FP are a lot like .NET Strings. In fact, in many FP languages, variables are actually called "values" because they don't, in fact, vary.  </p><p>It turns out that this approach to programming has significant upside for unit testing and concurrency. Unit tests typically spend a significant effort getting the objects they're testing into the right state to invoke the function under test. In FP, the result of a function is purely dependent on the values passed into it, which makes unit testing very straight forward. For concurrency, since functions don't share mutable state, there's no need to do complicated locking across multiple processors.  </p><p>But if values don't vary, how to we managed application state? FP apps typically maintain their state on the stack. For example, my F# parser starts with a string input and return an abstract syntax tree. All the data is passed between functions on the stack. However, for most user-oriented non-console applications, keeping all state on the stack isn't realistic.  As Simon Peyton Jones <a href="http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/" target="_blank">points out</a>, "The ultimate purpose of running a program is invariably to cause some side effect: a changed file, some new pixels on the screen, a message sent, or whatever." So all FP languages provide some mechanism for purposefully implementing side effects, some (like Haskell) stricter in their syntax than others. </p><p>One of the nice things about F#'s <a href="http://research.microsoft.com/fsharp/faq.aspx#WhatSortOfLanguage">multi-paradigm nature</a> is that side effects is a breeze. Of course, that's both a blessing and a curse, since the much of the aforementioned upside comes from purposefully building side-effect free functions. But the more I work with F#, the more I appreciate the ability to do both functional as well as imperative object-oriented operations in the same language. For example, my parsing code so far is purely functional - it takes in a string to be parsed and returns an AST. But the logical next step would be to generate output based on that AST. Since F# supports non-functional code - not to mention the rich Base Class Library - generating output should be straightforward.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1066</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2007-12-04 17:25:42</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2007-12-04 17:25:42</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">functional-understanding</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="f-sharp"><![CDATA[F#]]></category>
  <category domain="post_tag" nicename="functional-programming"><![CDATA[Functional Programming]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[f5911927-c440-4f2d-8539-1382021b6ae3]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Functional+Understanding]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2007/12/05/Functional+Understanding]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2000</wp:comment_id>
    <wp:comment_author><![CDATA[Naveen]]></wp:comment_author>
    <wp:comment_author_email>naveensrinivasan@yahoo.com</wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>140.188.62.187</wp:comment_author_IP>
    <wp:comment_date>2007-12-05 07:48:45</wp:comment_date>
    <wp:comment_date_gmt>2007-12-05 15:48:45</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Can you post the parsing code? It would be interesting to look at it.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2001</wp:comment_id>
    <wp:comment_author><![CDATA[Anon]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>131.107.0.102</wp:comment_author_IP>
    <wp:comment_date>2007-12-05 12:04:51</wp:comment_date>
    <wp:comment_date_gmt>2007-12-05 20:04:51</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[I think that we FPers commonly introduce our friends to the wrong way. Normally people learn new technologies because they somehow give you more power. I think that eliminating side-effects is only half of the story; and it's the part that feels limiting to non-FP programmers. It's actually not limiting but appreciating that is difficult without working in FP for a while. The powerful part of FP (the other half of the story) is using functions as first-class citizens - composing complex things out of simple already built and working composable pieces. I think it's a lot easier for non-FP programmers to grasp the power of higher order functions first, then later come to realize the value of side-effect-free programming. They see that it gets in the way of the power of composition. But they can't see that until they see the power of composition to begin with.]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>