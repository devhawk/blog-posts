<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Nightly Builds Technical Info</title>
  <link>http://devhawk.net/2009/01/07/nightly-builds-technical-info/</link>
  <pubDate>Wed, 07 Jan 2009 15:23:26 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://9ecbf637-0b38-475e-90ad-33af18381878</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>Here are some technical details on my <a href="http://devhawk.net/2009/01/07/IronPython+Nightly+Builds.aspx">Nightly Builds solution</a>. I broke them into a separate post because I figured most people are more interested in the actual service than how it’s built.</p><p>As you might expect, I built most of the solution in IronPython. All of the download, build, compress and Azure upload code was written in IPy. The one part I didn’t write in IPy was the Azure cloud web app, which I wrote in C#. Jon Udell’s been investigating <a href="http://blog.jonudell.net/2008/12/22/azure-calendar-aggregator-part-1/">getting IPy to run in Azure</a>, but I just wanted something quick and dirty (as you can see from the <a href="http://nightlybuilds.cloudapp.net/">utter lack of formatting</a>) so I decided to use C# instead. Man, were my ASP.NET skills rusty.</p><p>As for the IronPython parts, for the most part I’m using external tools for downloading, building and compressing. I use the <a href="http://www.codeplex.com/IronPython/Project/ProjectRss.aspx?ProjectRSSFeed=codeplex%3a%2f%2fsourcecontrol%2fIronPython">Source Control RSS Feed</a> to discover recent source code changesets, <a href="http://www.codeplex.com/CodePlexClient">CodePlex Client</a> to download source from CodePlex, <a href="http://msdn.microsoft.com/en-us/library/wea2sca5.aspx">MSBuild</a> to build the binaries, <a href="http://www.7-zip.org/">7-zip</a> to compress the binaries and the <a href="http://msdn.microsoft.com/en-us/library/dd135716.aspx">StorageClient library sample</a> to upload the compressed binaries up to Azure blob storage. </p><p>For building and compressing, I’m literally shelling out to MSBuild and 7-Zip via <a href="http://www.python.org/doc/2.5.2/lib/os-process.html">os.system</a>. I looked at <a href="http://www.ironpython.info/index.php/Automating_MSBuild">programmatically building</a> via the MSBuild API, but I ran into an <a href="http://blogs.microsoft.co.il/blogs/idof/archive/2008/11/24/what-does-entity-framework-has-to-do-with-msbuild.aspx">assembly binding bug</a> that I wasn’t motivated enough to work around. As for creating zip files programmatically, IronPython doesn’t have a <a href="http://www.python.org/doc/2.5.2/lib/module-zlib.html">zlib module</a> implementation yet so I just used 7-Zip’s command line utility instead.</p><p>For downloading form CodePlex, I originally started by shelling out to CodePlex Client. However, I wanted the ability to cloak folders – for example Tutorial and SrcTests – that weren’t required to build. CodePlex Client has a very useful TFS library embedded in it – the build process combines all the libraries into a single executable via <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=22914587-b4ad-4eae-87cf-b14ae6a939b0&amp;displaylang=en">ILMerge</a>. I could have compiled my own version of the TFS library, but instead I just load cpc.exe as an assembly reference via clr.AddReferenceToFileAndPath. It’s a nifty trick <a href="http://blogs.msdn.com/hugunin/">Jim Hugunin</a> showed me once. </p><p>Uploading to Azure was very straightforward because of the StorageClient library. Here’s the code to create a blob container object (creating the actual blob container if it doesn’t already exist) and to upload a file to a container.</p><pre class="brush: python">
def get_blob_container(prj):
  azure_account = StorageAccountInfo(endpoint, None, azure_name, azure_key)
  storage = BlobStorage.Create(azure_account)
  container = storage.GetBlobContainer(prj.lower())
  if not container.DoesContainerExist():
    print "Creating", prj, "Azure Blob Storage Container"
    container.CreateContainer(None, ContainerAccessControl.Public)
  return container     

def upload_to_azure(container, upload_filepath, azure_filename, metadata):
    print "Uploading", azure_filename, "to Azure"
    prop = BlobProperties(azure_filename)
    nv = NameValueCollection()
    for key in metadata:
      nv[key] = metadata[key]
    prop.Metadata = nv     
     
    with File.OpenRead(upload_filepath) as stream:
      contents = BlobContents(stream)
      if not container.CreateBlob(prop, contents, True):
        raise "Uploading " + azure_filename + " to Azure failed"
</pre><p>I’ve been working on some pure IronPython code to access the <a href="http://msdn.microsoft.com/en-us/library/dd179355.aspx">blob storage REST API</a> directly, but that’s primarily to familiarize myself with the service. At some point, I’m going to want to leverage <a href="http://msdn.microsoft.com/en-us/library/dd179423.aspx">Table Storage</a> but my brief experimentation with the StorageClient Table Storage interface makes me think that it depends on static typing too much to be useful for IPy. If that turns out to be true, the Table Storage REST API will be my only option.</p><p>As you can see in the code above, these Azure blob containers are set to be publically accessible (via ContainerAccessControl<span style="color: blue">.</span>Public argument passed to CreateContainer). So for my C# app, I’m simply using calling XDocument.Load with the <a href="http://msdn.microsoft.com/en-us/library/dd135734.aspx">List Blobs operation url</a>, shaping the results via LINQ to XML and binding them to nested ASP.NET Repeater controls. </p><p>Assuming people find this useful, I’m thinking of some additional improvements, in order of what I’m likely to get to first:</p><ul><li>Caching Project Info in the cloud app      <br />Currently, I’m hitting getting and processing the list of binary releases on every request. I’m sure caching that data to make it more efficient. </li><li>Virtual Build Environment      <br />Currently, I’m just building on my laptop. It would be nice to have a clean environment dedicated to running the build script. </li><li>Auto-Build      <br />My script uses the RSS feed to find the recent checkins, but I have to manually kick off the process. I’d like it to set it up as a service that periodically checks the source code RSS feed automatically and downloads and builds any new releases that it finds. </li><li>Table Storage for Build Metadata      <br />Today, I am simply grabbing the list of all uploaded compressed binaries for a given project, parsing their names, and displaying that as a hierarchical list on the <a href="http://nightlybuilds.cloudapp.net/Project.aspx?project=ironpython">project page</a>. If I used Table Storage, I could add additional metadata including social software features like ratings and comments. </li><li>Amazon EC2 Virtual Build Environment      <br />If I’m creating a virtual machine for my build environment, I could look at hosting it on <a href="http://aws.amazon.com/ec2/">Amazon EC2</a>. They <a href="http://aws.amazon.com/windows/">support Windows now</a> after all. Ideally, I’d use an <a href="http://msdn.microsoft.com/en-us/library/dd179341.aspx">Azure worker role</a> for compiling and compressing builds, but our build tools need access to the file system. </li></ul>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1210</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2009-01-07 15:23:26</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2009-01-07 15:23:26</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">nightly-builds-technical-info</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="azure"><![CDATA[Azure]]></category>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[9ecbf637-0b38-475e-90ad-33af18381878]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[Nightly+Builds+Technical+Info]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2009/01/07/Nightly+Builds+Technical+Info]]></wp:meta_value>
  </wp:postmeta>
</item>