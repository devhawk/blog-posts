<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>IronPython and Linq to XML Part 2: Screen Scraping</title>
  <link>http://devhawk.net/2008/11/26/ironpython-and-linq-to-xml-part-2-screen-scraping/</link>
  <pubDate>Wed, 26 Nov 2008 17:16:51 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">devhawk</dc:creator>
  <guid isPermaLink="false">http://bcc253be-4491-4c1a-bc67-d9df809ce716</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[<p>First, I need to convert the HTML <a href="http://www.rockband.com/music/songs">list of Rock Band songs</a> into a machine readable format. That means doing a little screen scraping. Originally, I used <a href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> but I found that <a href="http://www.crummy.com/software/BeautifulSoup/documentation.html#Beautiful%20Soup%20Gives%20You%20Unicode,%20Dammit">UnicodeDammit</a> got confused on names like Blue Öyster Cult and Mötley Crüe. I’m guessing it’s broken because IronPython doesn’t have non-unicode strings.</p><p>Instead, I used SgmlReader to provide an XmlReader interface over the HTML, then queried that data via Linq to XML. I used the <a href="http://wiki.developer.mindtouch.com/Community/SgmlReader">version of SgmlReader from MindTouch</a> since they include a compiled binary and it seems to be the only active maintained version. I wrapped it all up in a function called load that loads HTML from either disk or the network (based on the URI scheme) into an <a href="http://msdn.microsoft.com/en-us/library/system.xml.linq.xdocument.aspx">XDocument</a>.</p><pre class="brush: python">
def loadStream(streamreader):
  from System.Xml.Linq import XDocument     
  from Sgml import SgmlReader     
   
  reader = SgmlReader()
  reader.DocType = "HTML"
  reader.InputStream = streamreader     
  return XDocument.Load(reader)
   
def load(url):
  from System import Uri     
  from System.IO import StreamReader     
   
  if isinstance(url, str):
    url = Uri(url)
   
  if url.Scheme == "file":
    from System.IO import File     
    with File.OpenRead(url.LocalPath) as fs:
      with StreamReader(fs) as sr:
        return loadStream(sr)
  else:
    from System.Net import WebClient     
    wc = WebClient()
    with wc.OpenRead(url) as ns:
      with StreamReader(ns) as sr:
        return loadStream(sr)

def parse(text):
  from System.IO import StringReader     
  return loadStream(StringReader(text))
</pre><p>I call load, passing in the URL to the list of songs. The “official” Rock Band song page loads the actual content from <a href="url = 'http://www.rockband.com/music/getSearchResultsTable_Ajax?sort_on=songs.NAME&amp;sort_order=asc'">a different page</a> via AJAX, so I just load the actual list directly via my load function. </p><p>Once the HTML is loaded as an XDocument, I need a way to find the specific HTML nodes I was looking for. As I said earlier, XDocument uses Linq to XML – there is not other API for querying the XML tree. In the HTML, there’s a div tag with the id “content” that contains all the song rows as table row elements. I built a simple function that uses the LINQ Single method to find the tag by it’s id attribute value.</p><pre class="brush: python">
def FindById(node, id):
  def CheckId(n):
    a = n.Attribute('id')
    return a != None and a.Value == id     
   
  return linq.Single(node.Descendants(), CheckId)
</pre><p>(Side note – I didn’t like the verbosity of the “a != None and a<span style="color: blue">.</span>Value == id” line of code, by XAttributes are not comparable by value. That is, I can’t write “node.Attribute(‘id’) == XAttribute(‘id’, id)”. And writing “node.Attribute(‘id’).Value == id” only works if every node has an id attribute. Not making XAttribute comparable by value seems like a strange design choice to me.)</p><p>LINQ to objects works just fine from IronPython, with a few caveats. First, IronPython doesn’t have extension methods, so you can’t chain calls together sequentially like you can in C#. So instead of collection.Where(…).Select(…), you have to write Select(Where(collection, …), …). Second, all the LINQ methods are generic, so you have to use the verbose list syntax (for example: Single[object] or Select[object,object]). Since Python doesn’t care about the generic types, I wrote a bunch of simple helper functions around the common LINQ methods that just use object as the generic type. Here are a few examples:</p><pre class="brush: python">
def Single(col, fun):
  return Enumerable.Single[object](col, Func[object, bool](fun))
   
def Where(col, fun):
  return Enumerable.Where[object](col, Func[object, bool](fun))
   
def Select(col, fun):
  return Enumerable.Select[object, object](col, Func[object, object](fun))
</pre><p>Once I have the content node, all the songs are in tr nodes beneath it. I wrote a function called ScrapeSong that transforms a song tr node into a Song object (which I’ll talk about in the next installment of this series). I use LINQ methods Select, OrderBy and ThenBy to provide me an enumeration of Song objects, ordered by date added (descending) than artist name.</p><pre class="brush: python">
def ScrapeSong(node):     
  tds = list(node.Elements(xhtml.ns+'td'))    
  anchor = list(tds[0].Elements(xhtml.ns+'a'))[0]    
      
  title = anchor.Value    
  url = anchor.Attribute('href').Value    
  artist = tds[1].Value    
  year = tds[2].Value    
  genre = tds[3].Value    
  difficulty = tds[4].Value    
  _type = tds[5].Value    
  added = DateTime.Parse(tds[6].Value)    
      
  return Song(title, artist, added, url, year, genre, difficulty, _type)    

songs = ThenBy(OrderByDesc(   
          Select(content.Elements(xhtml.ns +'tr'), ScrapeSong),    
          lambda s: s.added), lambda s: s.artist)
</pre><p>And that’s pretty much it. Next, I’ll iterate thru the list of songs and get the details I need from Zune’s catalog web services in order to write out a playlist that the Zune software will understand.</p>]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">1199</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2008-11-26 17:16:51</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2008-11-26 17:16:51</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">ironpython-and-linq-to-xml-part-2-screen-scraping</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="category" nicename="ironpython"><![CDATA[IronPython]]></category>
  <category domain="post_tag" nicename="linq"><![CDATA[LINQ]]></category>
  <category domain="post_tag" nicename="rock-band"><![CDATA[Rock Band]]></category>
  <category domain="post_tag" nicename="xml"><![CDATA[XML]]></category>
  <category domain="post_tag" nicename="zune"><![CDATA[Zune]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_entryid</wp:meta_key>
    <wp:meta_value><![CDATA[bcc253be-4491-4c1a-bc67-d9df809ce716]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitle</wp:meta_key>
    <wp:meta_value><![CDATA[IronPython+And+Linq+To+XML+Part+2+Screen+Scraping]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>dasblog_compressedtitleunique</wp:meta_key>
    <wp:meta_value><![CDATA[2008/11/27/IronPython+And+Linq+To+XML+Part+2+Screen+Scraping]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2150</wp:comment_id>
    <wp:comment_author><![CDATA[Ada]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url>http://AsimplewarppertoenableLinq-likestyle</wp:comment_author_url>
    <wp:comment_author_IP>207.46.92.17</wp:comment_author_IP>
    <wp:comment_date>2008-12-04 02:48:01</wp:comment_date>
    <wp:comment_date_gmt>2008-12-04 10:48:01</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[import System, sys
import linq

linqs = {}
for name in dir(linq):
    if not name.startswith('__'):
        linqs[name] = getattr(linq, name)

class IpyLinq:
    def __init__(self, col):
        self.col = col
        
    def __iter__(self):
        return iter(self.col)
        
    def __str__(self):
        return '[%s]' % ', '.join( (str(v) for v in self) )
        
    def __repr__(self):
        return str(self)
        
    def __getattr__(self, name):
        def decorator(*arg, **kws):
            self.col = linqFunc(self.col, *arg, **kws)
            return self
        
        linqFunc = linqs[name]
        return decorator

if __name__ == '__main__':
    for x in IpyLinq([1, 2, 3, 4, 5]).Where(lambda x: x > 1).Where(lambda x: x < 5):
        print x]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
  <wp:comment xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:comment_id>2151</wp:comment_id>
    <wp:comment_author><![CDATA[Ada]]></wp:comment_author>
    <wp:comment_author_email></wp:comment_author_email>
    <wp:comment_author_url></wp:comment_author_url>
    <wp:comment_author_IP>207.46.92.19</wp:comment_author_IP>
    <wp:comment_date>2008-12-04 03:29:41</wp:comment_date>
    <wp:comment_date_gmt>2008-12-04 11:29:41</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[My original implementation has a bug.

class IpyLinq:
    def __init__(self, col):
        self.col = col
        
    def __iter__(self):
        return iter(self.col)
        
    def __str__(self):
        return '[%s]' % ', '.join( (str(v) for v in self) )
        
    def __repr__(self):
        return str(self)
        
    def __getattr__(self, name):
        def decorator(*arg, **kws):
            result = linqs[name](self.col, *arg, **kws)
            if hasattr(result, '__iter__'):
                return IpyLinq(result)
            else:
                return result
        return decorator]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type></wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
  </wp:comment>
</item>