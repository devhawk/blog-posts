<p></p>
<p><a href="http://www.factored-software.com/iimplement">Chris Bilson</a> left the following <a href="http://devhawk.net/CommentView,guid,6e17873f-9d5b-401e-a9b4-609394e97e3f.aspx">comment</a> to my <a href="http://devhawk.net/2005/11/23/Thoughts+On+CAB.aspx">Thoughts on CAB</a> post</p>
<blockquote><p>I hesitate to agree that raising the abstraction level of tools is a good idea. That&#8217;s just hiding the complexity that&#8217;s already there inside of more complexity. If you ever need to look under the hood, it&#8217;s even harder to grok. I think it would be better to go the other way. Try removing stuff to combat complexity.</p>
</blockquote>
<p>Given that the software industry has been raising the level of abstraction of tools since the start, I found this comment surprising. Assuming Chris doesn&#8217;t write in assembly code, he&#8217;s leveraging something at a higher level of abstraction that&#8217;s &#8220;just hiding the complexity that&#8217;s already there&#8221;. As I wrote in <a href="http://devhawk.net/2005/10/05/Code+Is+Model.aspx">Code is Model</a>:</p>
<blockquote><p>The only code that the CPU can understand is machine code. But nobody wants to write and debug all their code using 0&#8217;s and 1&#8217;s. So we move up a level of abstraction and use a language that humans can read more easily and that can be automatically translated (i.e. compiled) into machine code the CPU can execute. The simplest step above machine code is assembly language. <b>But ASM isn&#8217;t particularly productive so work with, so the industry has continuously raised the level of abstraction in the languages they use. C is a higher level of abstraction than ASM, adding concepts like types and functions. C++ is a higher level of abstraction than C, adding concepts like classes and inheritance. Each of these levels of abstraction presents a new model of the execution environment with new features that make programming more productive (and sometimes <a href="http://devhawk.net/2005/09/08/Portability+Without+Productivity.aspx">more portable</a>)</b>. [emphasis added]</p>
</blockquote>
<p>I feel like Chris has mischaracterized what I wrote. Here it is again:</p>
<blockquote><p>If you can&#8217;t lower the complexity of your framework, it&#8217;s time to raise the abstraction of your tools.</p>
</blockquote>
<p>Note I&#8217;m not advocating raising the level of abstraction for abstractions sake. Believe me, I&#8217;m hate overly complex code. The project I&#8217;ve been on (and can blog about soon I hope) had a tone of overly complex code that wasn&#8217;t particularly germane to solving the problem. I yanked all that code and have reduced the framework to a quarter it&#8217;s original size while adding functionality. But the reality is, simplification can&#8217;t <i>always</i> be achieved by removing code. To <a href="http://en.wikipedia.org/wiki/Occam's_Razor">paraphrase Albert Einstein</a>, solutions to problems should be as simple as possible,<i> but no simpler</i>. </p>
<p>CAB is the simplest solution to the problem it addresses, and no simpler. Since we can&#8217;t make CAB simpler and still solve the problem, the <i>only</i> alternative we have is to have the tools hide that complexity. Given how well this has worked in the past, I see no reason why it can&#8217;t work again in the future.</p>
