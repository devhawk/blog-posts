<p><a href="http://www.kuro5hin.org/user/Carnage4Life/diary">Dare</a><a href="http://www.kuro5hin.org/story/2003/5/25/142610/725">commented</a> on my recent post about <a href="PermaLink.aspx?guid=5643b052-f1f2-4c53-ac33-e33d0910f917"> XML not being an object graph</a>. He rightly points out that objects can have associated business logic and XML can&#8217;t. I addressed an aspect of this in my <a href="PermaLink.aspx?guid=58fc378e-7811-41dc-b950-0ee2b9096006">follow up post</a>. I don&#8217;t want behavior in my entity objects &#8211; I want to put that into stateless control objects. So the lack of business logic in XML is no big deal (to me).</p>
<p>He further points that XML != XSD. I should be more precise in my use of the two terms. But while derivation by restriction may be an XSD thing, not an XML thing, the point is that there are things in XML (with or with out XSD) that have no corollary in the strongly typed world of OOP. XML (and all XML related specifications by association) have their original design rooted in a wire format. Even <a href="http://www.w3.org/TR/xml-infoset/">Infoset</a> suffers, as it is designed to provide an abstract data model that maps well to the original XML angle-bracket based format. An example of XML&#8217;s wire format roots is the text-oriented idea of equivalence. In OOP, data has explicit values. In XML, the string representation of the data creates a need to ensure canonical representation for determining equivalence. Class / Element identity has the same issue. In OOP, an object is explicitly mapped to one object. In XML, the equivalent mapping (to element type) is done by a string matching &#8211; a mapping made more difficult by the tacked-on concept of namespaces and namespace prefixes. </p>
<p>XML may have it&#8217;s roots in a wire format with the concept of namespaces tacked on as an afterthought. XSD may have issues including the fact that it was obviously designed by committee and seems to have at least two ways of doing everything. But even with those shortcomings, XML has one major thing going for it: it actually works. We&#8217;ve seen strongly-typed object systems <a href="http://www.microsoft.com/com/">fail</a><a href="http://java.sun.com/"> time</a> and <a href="http://www.corba.org/">time again</a> to deliver promised cross platform integration. Since XML works, I know I&#8217;m going to want to use it in my <strike>application</strike> service. But I&#8217;d rather not have separate programming models for internal and external entities. If XML is the best model for accessing external entities, I want to use that same model to access internal entities as well.</p>
