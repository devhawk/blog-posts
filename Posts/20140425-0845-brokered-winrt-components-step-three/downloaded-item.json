{"status":"ok","post":{"id":2102,"type":"post","slug":"brokered-winrt-components-step-three","url":"http:\/\/devhawk.net\/2014\/04\/25\/brokered-winrt-components-step-three\/","status":"publish","title":"Brokered WinRT Components Step Three","title_plain":"Brokered WinRT Components Step Three","content":"<p>So far, we&#8217;ve created two projects, written all of about two lines of code and we have both our <a href=\"http:\/\/devhawk.net\/2014\/04\/25\/brokered-winrt-components-step-one\">brokered component <\/a>and its <a href=\"http:\/\/devhawk.net\/2014\/04\/25\/brokered-winrt-components-step-two\">proxy\/stub<\/a> ready to go. Now it\u2019s time to build the Windows Runtime app that uses the component. So far, things have been pretty easy \u2013 the only really tricky and\/or manual step so far has been registering the proxy\/stub, and that\u2019s only tricky if you don\u2019t want to run VS as admin. Unfortunately, tying this all together in the app requires a few more manual steps.<\/p>\n<p>But before we get to the manual steps, let\u2019s create the WinRT client app. Again, we\u2019re going to create a new project but this time we\u2019re going to select \u201cBlank App (Windows)\u201d from the Visual C# -&gt; Store Apps -&gt; Windows App node of the Add New Project dialog. Note, I\u2019m not using \u201cBlank App (Universal)\u201d or \u201cBlank App (Windows Phone)\u201d because the brokered WinRT component feature is not support on Windows Phone. Call the client app project whatever you like, I\u2019m calling mine \u201cHelloWorldBRT.Client\u201d.<\/p>\n<p>Before we start writing code, we need to reference the brokered component. We can&#8217;t reference the brokered component directly or it will load in the sandboxed app process. Instead, the app need to reference a reference assembly version of the .winmd that gets generated automatically by the proxy\/stub project. Remember in the <a href=\"http:\/\/devhawk.net\/2014\/04\/25\/brokered-winrt-components-step-two\">last step <\/a>when I said Kieran Mockford is an MSBuild wizard? The proxy\/stub template project includes a custom target that automatically publishes the reference assembly winmd file used by the client app. When he showed me that, I was stunned &#8211; as I said, the man is a wizard. This means all <em>you<\/em> need to do\u00a0is right click on the References node of the WinRT Client app project and select Add Reference. In the Reference Manager dialog, add a reference to the proxy\/stub project you created in step two.<\/p>\n<p>Now I can add the following code to the top of my App.OnLaunched function. Since this is a simple Hello World walkthru, I\u2019m not going to bother to build any UI. I\u2019m just going to inspect variables in the debugger. Believe me, the less UI I write, the better for everyone involved. Note, I\u2019ve also added the P\/Invoke signatures for GetCurrentProcess\/ThreadID and to the client app like I did in the brokered component in <a href=\"http:\/\/devhawk.net\/2014\/04\/25\/brokered-winrt-components-step-one\">step one<\/a>. This way, I can get the process and thread IDs for both the app and broker process and compare them.<\/p>\n<pre class=\"brush:csharp\">var pid = GetCurrentProcessId();\r\nvar tid = GetCurrentThreadId();\r\n\r\nvar c = new HelloWorldBRT.Class();\r\nvar bpid = c.CurrentProcessId;\r\nvar btid = c.CurrentThreadId;<\/pre>\n<p>At this point the app will compile, but if I run it the app will throw a TypeLoadException when it tries to create an instance of HelloWorldBRT.Class. The type can\u2019t be loaded because the we&#8217;re using the reference assembly .winmd published by the proxy\/stub project &#8211; it has no implementation details, so it can&#8217;t load.\u00a0In order to be able to load the type, we need to declare the HelloWorldBRT.Class as a brokered component in the app&#8217;s pacakge.appxmanifest file. For non-brokered components, Visual Studio does this for you automatically. For brokered components we have to do it manually unfortunately. Every activatable class (i.e. class you can construct via \u201cnew\u201d) needs to be registered in the appx manifest this way.<\/p>\n<p>To register HelloWorldBRT.Class, right click the Package.appxmanifest file in the client project, select \u201cOpen With\u201d from the context menu and then select \u201cXML (Text) editor\u201d from the Open With dialog. Then you need to insert <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/br211443.aspx\">inProcessServer extension<\/a> that includes an <a href=\"http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/apps\/br211413.aspx\">ActivatableClass element<\/a> for each class you can activate (aka has a public constructor). Each ActivatableClass element contains an ActivatableClassAttribute element that contains a pointer to the folder where the brokered component is installed. Here\u2019s what I added to Package.appxmainfest of my HelloWorldBRT.Client app.<\/p>\n<pre class=\"brush:xml\">&lt;Extensions&gt;\r\n  &lt;Extension Category=\"windows.activatableClass.inProcessServer\"&gt;\r\n    &lt;InProcessServer&gt;\r\n      &lt;Path&gt;clrhost.dll&lt;\/Path&gt;\r\n      &lt;ActivatableClass ActivatableClassId=\"HelloWorldBRT.Class\" \r\n                        ThreadingModel=\"both\"&gt;\r\n        &lt;ActivatableClassAttribute \r\n             Name=\"DesktopApplicationPath\" \r\n             Type=\"string\" \r\n             Value=\"D:\\dev\\HelloWorldBRT\\Debug\\HelloWorldBRT.PS\"\/&gt;\r\n      &lt;\/ActivatableClass&gt;\r\n    &lt;\/InProcessServer&gt;\r\n  &lt;\/Extension&gt;\r\n&lt;\/Extensions&gt;<\/pre>\n<p>The key thing here is the addition of the DesktopApplicationPath ActivatableClassAttribute. This tells the WinRT activation logic that HelloWorldBRT.Class is a brokered component and where the managed .winmd file with the implementation details is located on the device. Note, you can use multiple brokered components in your side loaded app, but they all have the same DesktopApplicationPath.<\/p>\n<p>Speaking of DesktopApplicationPath, the\u00a0path I\u2019m using here is path the final location of the proxy\/stub components generated by the compiler. Frankly, this isn\u2019t an good choice to use in a production deployment. But for the purposes of this walk thru, it\u2019ll be fine.<\/p>\n<p><a href=\"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow.png\" class=\"grouped_elements\" rel=\"tc-fancybox-group2102\"><img class=\"wp-image-2103 alignleft\" alt=\"ClientWatchWindow\" src=\"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow-300x94.png\" width=\"300\" height=\"94\" \/><\/a><\/p>\n<p>Now when we run the app, we can load a HelloWorldBRT.Class instance and access the properties. re definitely seeing a different app process IDs when comparing the result of calling GetCurrentProcessId directly in App.OnLoaded vs. the result of calling GetCurrentProcessId in the brokered component. Of course, each run of the app will have different ID values, but this proves that we are loading our brokered component into a different process from where our app code is running.<\/p>\n<p>Now you&#8217;re ready to go build your own brokered components! Here&#8217;s hoping you&#8217;ll find more interesting uses for them than comparing the process IDs of the app and broker processes in the debugger! <img src=\"http:\/\/devhawk.net\/wp-includes\/images\/smilies\/icon_smile.gif\" alt=\":)\" class=\"wp-smiley\" \/> <\/p>\n","excerpt":"<p>So far, we&#8217;ve created two projects, written all of about two lines of code and we have both our brokered component and its proxy\/stub ready to go. Now it\u2019s time to build the Windows Runtime app that uses the component. So far, things have been pretty easy \u2013 the only really tricky and\/or manual step [&hellip;]<\/p>\n","date":"2014-04-25 08:45:36","modified":"2014-04-25 08:45:24","categories":[{"id":204,"slug":"development","title":"Development","description":"","parent":0,"post_count":165},{"id":283,"slug":"windows","title":"Windows","description":"","parent":0,"post_count":16},{"id":357,"slug":"windows-runtime","title":"Windows Runtime","description":"","parent":0,"post_count":12}],"tags":[{"id":374,"slug":"brokered-components","title":"brokered components","description":"","post_count":6},{"id":373,"slug":"sideload","title":"sideload","description":"","post_count":6},{"id":378,"slug":"tutorial","title":"tutorial","description":"","post_count":4}],"author":{"id":1,"slug":"admin","name":"DevHawk","first_name":"Harry","last_name":"Pierson","nickname":"DevHawk","url":"","description":""},"comments":[],"attachments":[{"id":2103,"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow.png","slug":"clientwatchwindow","title":"ClientWatchWindow","description":"","caption":"","parent":2102,"mime_type":"image\/png","images":{"full":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow.png","width":611,"height":192},"thumbnail":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow-150x150.png","width":150,"height":150},"medium":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow-300x94.png","width":300,"height":94},"large":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow.png","width":611,"height":192},"tc-thumb":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow-270x192.png","width":270,"height":192},"slider-full":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow.png","width":611,"height":192},"slider":{"url":"http:\/\/devhawk.net\/wp-content\/uploads\/2014\/04\/ClientWatchWindow.png","width":611,"height":192}}}],"comment_count":0,"comment_status":"closed","custom_fields":{"layout_key":[""],"post_slider_check_key":["0"]}},"previous_url":"http:\/\/devhawk.net\/2014\/04\/25\/brokered-winrt-components-step-two\/","next_url":"http:\/\/devhawk.net\/2014\/04\/26\/yet-more-change-for-the-capitals\/"}