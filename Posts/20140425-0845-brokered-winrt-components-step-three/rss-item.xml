<?xml version="1.0" encoding="utf-8"?>
<item>
  <title>Brokered WinRT Components Step Three</title>
  <link>http://devhawk.net/2014/04/25/brokered-winrt-components-step-three/</link>
  <pubDate>Fri, 25 Apr 2014 15:45:36 +0000</pubDate>
  <dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/"><![CDATA[devhawk]]></dc:creator>
  <guid isPermaLink="false">http://devhawk.net/?p=2102</guid>
  <description></description>
  <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"><![CDATA[So far, we've created two projects, written all of about two lines of code and we have both our <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-one">brokered component </a>and its <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">proxy/stub</a> ready to go. Now it’s time to build the Windows Runtime app that uses the component. So far, things have been pretty easy – the only really tricky and/or manual step so far has been registering the proxy/stub, and that’s only tricky if you don’t want to run VS as admin. Unfortunately, tying this all together in the app requires a few more manual steps.

But before we get to the manual steps, let’s create the WinRT client app. Again, we’re going to create a new project but this time we’re going to select “Blank App (Windows)” from the Visual C# -&gt; Store Apps -&gt; Windows App node of the Add New Project dialog. Note, I’m not using “Blank App (Universal)” or “Blank App (Windows Phone)” because the brokered WinRT component feature is not support on Windows Phone. Call the client app project whatever you like, I’m calling mine “HelloWorldBRT.Client”.

Before we start writing code, we need to reference the brokered component. We can't reference the brokered component directly or it will load in the sandboxed app process. Instead, the app need to reference a reference assembly version of the .winmd that gets generated automatically by the proxy/stub project. Remember in the <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">last step </a>when I said Kieran Mockford is an MSBuild wizard? The proxy/stub template project includes a custom target that automatically publishes the reference assembly winmd file used by the client app. When he showed me that, I was stunned - as I said, the man is a wizard. This means all <em>you</em> need to do is right click on the References node of the WinRT Client app project and select Add Reference. In the Reference Manager dialog, add a reference to the proxy/stub project you created in step two.

Now I can add the following code to the top of my App.OnLaunched function. Since this is a simple Hello World walkthru, I’m not going to bother to build any UI. I’m just going to inspect variables in the debugger. Believe me, the less UI I write, the better for everyone involved. Note, I’ve also added the P/Invoke signatures for GetCurrentProcess/ThreadID and to the client app like I did in the brokered component in <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-one">step one</a>. This way, I can get the process and thread IDs for both the app and broker process and compare them.
<pre class="brush:csharp">var pid = GetCurrentProcessId();
var tid = GetCurrentThreadId();

var c = new HelloWorldBRT.Class();
var bpid = c.CurrentProcessId;
var btid = c.CurrentThreadId;</pre>
At this point the app will compile, but if I run it the app will throw a TypeLoadException when it tries to create an instance of HelloWorldBRT.Class. The type can’t be loaded because the we're using the reference assembly .winmd published by the proxy/stub project - it has no implementation details, so it can't load. In order to be able to load the type, we need to declare the HelloWorldBRT.Class as a brokered component in the app's pacakge.appxmanifest file. For non-brokered components, Visual Studio does this for you automatically. For brokered components we have to do it manually unfortunately. Every activatable class (i.e. class you can construct via “new”) needs to be registered in the appx manifest this way.

To register HelloWorldBRT.Class, right click the Package.appxmanifest file in the client project, select “Open With” from the context menu and then select “XML (Text) editor” from the Open With dialog. Then you need to insert <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211443.aspx">inProcessServer extension</a> that includes an <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211413.aspx">ActivatableClass element</a> for each class you can activate (aka has a public constructor). Each ActivatableClass element contains an ActivatableClassAttribute element that contains a pointer to the folder where the brokered component is installed. Here’s what I added to Package.appxmainfest of my HelloWorldBRT.Client app.
<pre class="brush:xml">&lt;Extensions&gt;
  &lt;Extension Category="windows.activatableClass.inProcessServer"&gt;
    &lt;InProcessServer&gt;
      &lt;Path&gt;clrhost.dll&lt;/Path&gt;
      &lt;ActivatableClass ActivatableClassId="HelloWorldBRT.Class" 
                        ThreadingModel="both"&gt;
        &lt;ActivatableClassAttribute 
             Name="DesktopApplicationPath" 
             Type="string" 
             Value="D:\dev\HelloWorldBRT\Debug\HelloWorldBRT.PS"/&gt;
      &lt;/ActivatableClass&gt;
    &lt;/InProcessServer&gt;
  &lt;/Extension&gt;
&lt;/Extensions&gt;</pre>
The key thing here is the addition of the DesktopApplicationPath ActivatableClassAttribute. This tells the WinRT activation logic that HelloWorldBRT.Class is a brokered component and where the managed .winmd file with the implementation details is located on the device. Note, you can use multiple brokered components in your side loaded app, but they all have the same DesktopApplicationPath.

Speaking of DesktopApplicationPath, the path I’m using here is path the final location of the proxy/stub components generated by the compiler. Frankly, this isn’t an good choice to use in a production deployment. But for the purposes of this walk thru, it’ll be fine.

<a href="http://devhawk.net/wp-content/uploads/2014/04/ClientWatchWindow.png"><img class="wp-image-2103 alignleft" alt="ClientWatchWindow" src="http://devhawk.net/wp-content/uploads/2014/04/ClientWatchWindow-300x94.png" width="300" height="94" /></a>

Now when we run the app, we can load a HelloWorldBRT.Class instance and access the properties. re definitely seeing a different app process IDs when comparing the result of calling GetCurrentProcessId directly in App.OnLoaded vs. the result of calling GetCurrentProcessId in the brokered component. Of course, each run of the app will have different ID values, but this proves that we are loading our brokered component into a different process from where our app code is running.

Now you're ready to go build your own brokered components! Here's hoping you'll find more interesting uses for them than comparing the process IDs of the app and broker processes in the debugger! :)]]></content:encoded>
  <excerpt:encoded xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"><![CDATA[]]></excerpt:encoded>
  <wp:post_id xmlns:wp="http://wordpress.org/export/1.2/">2102</wp:post_id>
  <wp:post_date xmlns:wp="http://wordpress.org/export/1.2/">2014-04-25 08:45:36</wp:post_date>
  <wp:post_date_gmt xmlns:wp="http://wordpress.org/export/1.2/">2014-04-25 15:45:36</wp:post_date_gmt>
  <wp:comment_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:comment_status>
  <wp:ping_status xmlns:wp="http://wordpress.org/export/1.2/">open</wp:ping_status>
  <wp:post_name xmlns:wp="http://wordpress.org/export/1.2/">brokered-winrt-components-step-three</wp:post_name>
  <wp:status xmlns:wp="http://wordpress.org/export/1.2/">publish</wp:status>
  <wp:post_parent xmlns:wp="http://wordpress.org/export/1.2/">0</wp:post_parent>
  <wp:menu_order xmlns:wp="http://wordpress.org/export/1.2/">0</wp:menu_order>
  <wp:post_type xmlns:wp="http://wordpress.org/export/1.2/">post</wp:post_type>
  <wp:post_password xmlns:wp="http://wordpress.org/export/1.2/"></wp:post_password>
  <wp:is_sticky xmlns:wp="http://wordpress.org/export/1.2/">0</wp:is_sticky>
  <category domain="post_tag" nicename="brokered-components"><![CDATA[brokered components]]></category>
  <category domain="category" nicename="development"><![CDATA[Development]]></category>
  <category domain="post_tag" nicename="sideload"><![CDATA[sideload]]></category>
  <category domain="post_tag" nicename="tutorial"><![CDATA[tutorial]]></category>
  <category domain="category" nicename="windows"><![CDATA[Windows]]></category>
  <category domain="category" nicename="windows-runtime"><![CDATA[Windows Runtime]]></category>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>layout_key</wp:meta_key>
    <wp:meta_value><![CDATA[]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>post_slider_check_key</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta xmlns:wp="http://wordpress.org/export/1.2/">
    <wp:meta_key>_wpas_done_all</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>