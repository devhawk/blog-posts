<p>In my <a href="http://devhawk.net/2012/06/19/windows-camp-demo-part-one/">previous
post</a>, we set
up a C++ WinRT component project and a C# Metro style XAML app to use
the component. The code was dinky Hello, world type stuff. Now, let’s do
something a little more interesting.</p>
<p>In preparing for this demo, I found a <a href="http://bitmap.codeplex.com/">C++ bitmap
library</a> on CodePlex that includes a plasma
texture generation function. This sounded like a good demo for both
language interop and using existing code. It builds on the code from <a href="http://devhawk.net/2012/06/19/windows-camp-demo-part-one/">my
previous
post</a>, so
either start there or <a href="https://github.com/devhawk/WindowsCampDemo">clone from
GitHub</a> and checkout the
part1 tag.</p>
<p>First step is to add the bitmap_image.hpp file from <a href="http://www.partow.net/index.html">Arash
Partow’s</a> <a href="http://bitmap.codeplex.com/">C++ Bitmap
Library</a> to the C++ component project.
Download the <a href="http://bitmap.codeplex.com/SourceControl/list/changesets">latest
commit</a> from
CodePlex as a zip and extract the bitmap_image.hpp file into your C++
component project directory. Switch over to VS, right click on the
component project node, select Add -&gt; Existing Item… and select the
bitmap_image.hpp file.</p>
<p>Now that we have included the library code, we need to write the wrapper
code to expose that library functionality to other languages via WinRT.
We’ll start by adding the following namespace declarations to the top of
the Class1.h header file:</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">using</span> <span style="color:Blue;">namespace</span> Windows::Foundation;
<span style="color:Blue;">using</span> <span style="color:Blue;">namespace</span> Windows::Storage::Streams;

</pre></div>
</div>
<p>And then we’ll add the declaration for our GetPlasmaImageAsync method to
Class1’s header file underneath the SayHello method. Note, in my
original presentation I called this method GetPlasmaImage, neglecting to
follow the naming convention of appending “Async” to name of all
asynchronous methods.</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
IAsyncOperation&lt;IRandomAccessStream^&gt;^ GetPlasmaImageAsync(
    <span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span> width, <span style="color:Blue;">unsigned</span> <span style="color:Blue;">int</span> height);

</pre></div>
</div>
<p>We’re using two WinRT types in this method declaration.</p>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.irandomaccessstream.aspx">IRandomAccessStream</a>
represents a stream of binary data that supports random access.
We’re going to return our plasma image as an IRandomAccessStream and
then wrap it in a XAML bitmap image for use in our UI.</li>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br206598.aspx">IAsyncOperation&lt;T&gt;</a>
represents an asynchronous operation that returns a value.
Generating the image takes a significant amount of time (especially
given the shortcut I used as you’ll see in a bit) so we need to make
it async. Async is a <em>big</em> topic and we’re just touching on it in
this walkthrough. For more on async in WinRT, check out my teammate
<a href="http://blogs.msdn.com/b/windowsappdev/archive/2012/03/20/keeping-apps-fast-and-fluid-with-asynchrony-in-the-windows-runtime.aspx">Jason Olson’s
post</a>
on the <a href="http://blogs.msdn.com/b/windowsappdev/">Win8 app developer
blog</a>.</li>
</ul>
<p>Now that we have the declaration, let’s switch over to the Class1.cpp
file to add the method implementation. This isn’t a one line method like
SayHello, so I decided to separate declaration from implementation as is
traditional C++ best practice.</p>
<p>Before we do anything else, we need to #include the bitmap_image.hpp
file. However, this bitmap library uses an unchecked destination STL
copy function that <a href="http://msdn.microsoft.com/en-us/library/aa985872(v=vs.110).aspx">Microsoft considers
unsafe</a>.
I <em>really</em> should be updating the code to used <a href="http://msdn.microsoft.com/en-us/library/aa985965(v=vs.110)">checked
iterators</a>,
but since this is demo code, we’re going to turn off the warning
instead. We do that by #defining _SCL_SECURE_NO_WARNINGS. While
we’re doing that, let’s add the additional #includes and using
namespace statements we’re going to need.</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
#include <span style="color:#A31515;">&quot;pch.h&quot;</span>
#include <span style="color:#A31515;">&quot;Class1.h&quot;</span>

#define _SCL_SECURE_NO_WARNINGS
#include <span style="color:#A31515;">&quot;bitmap_image.hpp&quot;</span>
#include &lt;string&gt;
#include &lt;ppltasks.h&gt;

<span style="color:Blue;">using</span> <span style="color:Blue;">namespace</span> WindowsCampComponent;
<span style="color:Blue;">using</span> <span style="color:Blue;">namespace</span> std;
<span style="color:Blue;">using</span> <span style="color:Blue;">namespace</span> concurrency;
<span style="color:Blue;">using</span> <span style="color:Blue;">namespace</span> Windows::Storage;

</pre></div>
</div>
<p>In addition to the bitmap image library, we’re going to need the STL
string library and the Parallel Patterns Library, so I’ve gone ahead and
#included those header files and used those namespaces. We’re also
going to use some types from the Windows::Storage namespace, so I’ve
used that namespace as well.</p>
<p>The implementation of the GetPlasmaImageAsync method is going to happen
in several steps:</p>
<ol>
<li>Generate the plasma image using the C++ Bitmap library</li>
<li>Save the plasma image to a temporary file</li>
<li>Reopen the temporary file as an IRandomAcessStream with WinRT’s file
system APIs</li>
</ol>
<p>Saving and reopening the file is the shortcut I alluded to earlier. The
image library includes a save_image method that uses STL streams to
write the image out to a file. A better solution would be to factor the
save_image method to support saving a bitmap to a stream and then
implementing an STL -&gt; WinRT stream adapter, but this is a simple demo
so I’ll leave that as an exercise to the reader. (Please send me a pull
request if you do this!)</p>
<p>First, we’re going to generate the file path we’ll be saving the image
to. Turns out this somewhat difficult because WinRT uses wide character
strings while the bitmap library expects ASCII STL strings.</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">//get the temp filename</span>
<span style="color:Blue;">auto</span> tempFolder = ApplicationData::Current-&gt;TemporaryFolder;

wstring tempFolderPath(tempFolder-&gt;Path-&gt;Data());
string folderPath(begin(tempFolderPath), end(tempFolderPath));

<span style="color:Blue;">auto</span> filePath = folderPath.append(<span style="color:#A31515;">&quot;\\plasma.bmp&quot;</span>);

</pre></div>
</div>
<p>I’m not proud of this code. It’s the kind of code you write when you’re
rushing to get a demo for your talk done. But lets look at it anyway.</p>
<p>First, I get the path to the temporary folder via the
<a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.applicationdata.current.aspx">current</a>
<a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.applicationdata.aspx">ApplicationData</a>
object. Then I converted it first to a std<span>wstring and then to a
std</span>string. I probably could have created the std::string directly from
the tempFolder variable, but using the begin and end iterators of the
wstring is a clever hack I read somewhere online. Finally, I append the
file name to the folder path to get the final file path name.</p>
<p>Next, we generate and save the plasma image. This code is lifted almost
verbatim from the bitmap_test.cpp file that comes with the C++ image
library. The only difference is that we’re using the width and height
arguments as parameters to the bitmap_image constructor rather than
hardcoded values.</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">//create the image object</span>
bitmap_image image(width, height);
image.clear();

<span style="color:Blue;">double</span> c1 = 0.9;
<span style="color:Blue;">double</span> c2 = 0.5;
<span style="color:Blue;">double</span> c3 = 0.3;
<span style="color:Blue;">double</span> c4 = 0.7;

::srand(0xA5AA5AA5);

<span style="color:Green;">//generate plasma image</span>
plasma(image, 0, 0, image.width(), image.height(),
    c1, c2, c3, c4, 3.0, jet_colormap);

<span style="color:Green;">//Save the image to the file</span>
image.save_image(filePath);

</pre></div>
</div>
<p>Finally, we open the image file from the temporary folder using WinRT
APIs. File access APIs in WinRT are exclusively async, so I’m using <a href="http://msdn.microsoft.com/en-us/library/hh750113(v=vs.110)">PPL
tasks</a> to
simplify the async code. Note, I’ve reworked this code from what I did
in the video to make it easier to understand. I’ve also added explicit
type declarations that I didn’t need to make it clear what each type is.
If I replaced those all with the new auto keyword from C++11, the code
would work the same.</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">//reopen the image file using WinRT</span>
IAsyncOperation&lt;StorageFile^&gt;^ getFileAsyncOp =
    tempFolder-&gt;GetFileAsync(ref <span style="color:Blue;">new</span> String(L<span style="color:#A31515;">&quot;plasma.bmp&quot;</span>));

task&lt;StorageFile^&gt; getFileTask(getFileAsyncOp);

task&lt;IRandomAccessStream^&gt; openFileTask =
    getFileTask.then([](StorageFile^ storageFile) {
       <span style="color:Blue;">return</span> storageFile-&gt;OpenAsync(FileAccessMode::Read);
    });

<span style="color:Blue;">return</span> create_async(
    [openFileTask]() { <span style="color:Blue;">return</span> openFileTask; });

</pre></div>
</div>
<p>First, we call GetFileAsync to get the file from the temp folder which
returns an IAsyncOperation&lt;StorageFolder^&gt; object. We then convert
the IAsyncOperation to a PPL task via the task constructor. Note, these
two steps could be easily combined into a single step if you not being
extra verbose for education purposes.</p>
<p>Once we have a PPL task to get the file, we specify the operation to do
when the task completes by passing a lambda to the <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh750044.aspx">task’s then
method</a>.
In this case, we’re going to open the file after we get it. The then
method is nice because we can chain together as many async operations as
we want in a nearly-synchronous coding style.</p>
<p>Finally, once we have built up the PPL task that represents the entire
asynchronous operation, we use the
<a href="http://msdn.microsoft.com/en-us/library/hh750102(v=vs.110).aspx">create_async</a>
method to convert the PPL task back to an IAsyncOperation which we
return from the function.</p>
<p>Now that we have written the component side, lets update the client
side. Async operations are very succinct in CLR because of the <a href="http://msdn.microsoft.com/en-us/library/hh191443(v=VS.110).aspx">new
await
keywords</a>.
Much nicer than the .then model used by PPL (which is probably why Herb
Sutter <a href="http://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/">wants to see await added to
C++</a>).</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">private</span> async <span style="color:Blue;">void</span> Button_Click_1(<span style="color:Blue;">object</span> sender, RoutedEventArgs e)
{
    <span style="color:Blue;">var</span> wcc = <span style="color:Blue;">new</span> WindowsCampComponent.Class1();
    myText.Text = wcc.SayHello(<span style="color:#A31515;">&quot;Herb Sutter&quot;</span>);

    <span style="color:Blue;">var</span> stm = await wcc.GetPlasmaImageAsync(800, 600);

    <span style="color:Blue;">var</span> bitmap = <span style="color:Blue;">new</span> BitmapImage();
    bitmap.SetSource(stm);
    myImage.Source = bitmap;
}

</pre></div>
</div>
<p>And it works!</p>
<p><a href="http://image.devhawk.net/blog-content/20120624-windows-camp-demo-part-two/WCDemo2-RunningApp.png"><img src="http://image.devhawk.net/blog-content/20120624-windows-camp-demo-part-two/WCDemo2-RunningApp-300x187.png" alt="" title="WCDemo2-RunningApp" /></a></p>
<p>And that’s the entire demo. About 20 lines of code to wrap a
 pre-existing library function and make it available to other languages
via the Windows Runtime. I showed calling my WinRT component from C#
here, but I could have called it from JavaScript just as easily.</p>
