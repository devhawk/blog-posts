<p>Martin Fowler <a href="http://martinfowler.com/bliki/DslReadings.html">points
to</a> a
<a href="http://andersnoras.com/blogs/anoras/archive/2007/07/04/i-m-coming-down-with-a-serious-case-of-the-dsls.aspx">couple</a>
of
<a href="http://andersnoras.com/blogs/anoras/archive/2007/07/09/behind-the-scenes-of-the-planning-dsl.aspx">articles</a>
by Anders Norås on building internal / embedded domain specific
languages in C#. Anders has built a DSL for creating calendar events
and tasks, like you might expect to do in Outlook. Here’s an example:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
ToDoComponent planningTask =
   Plan.ToDo(<span style="color:#A31515;">&quot;Plan project X&quot;</span>).
      StartingNow.
      MustBeCompletedBy(<span style="color:#A31515;">&quot;2007.08.17&quot;</span>).
      ClassifyAs(<span style="color:#A31515;">&quot;Public&quot;</span>);
planningTask.Save();

EventComponent planningMeeting =
   Plan.Event(<span style="color:#A31515;">&quot;Project planning meeting&quot;</span>).
      RelatedTo(planningTask).
      WithPriority(1).
      At(<span style="color:#A31515;">&quot;Head office&quot;</span>).
      OrganizedBy(<span style="color:#A31515;">&quot;jane@megacorp.com&quot;</span>, <span style="color:#A31515;">&quot;Jane Doe&quot;</span>).
      StartingAt(<span style="color:#A31515;">&quot;12:00&quot;</span>).Lasting(45).Minutes.
      Attendants(
         <span style="color:#A31515;">&quot;peter@megacorp.com&quot;</span>,
         <span style="color:#A31515;">&quot;paul@megacorp.com&quot;</span>,
         <span style="color:#A31515;">&quot;mary@contractor.com&quot;</span>).AreRequired.
      Attendant(<span style="color:#A31515;">&quot;john@megacorp.com&quot;</span>).IsOptional.
      Resource(<span style="color:#A31515;">&quot;Projector&quot;</span>).IsRequired.
      ClassifyAs(<span style="color:#A31515;">&quot;Public&quot;</span>).
      CategorizeAs(<span style="color:#A31515;">&quot;Businees&quot;</span>, <span style="color:#A31515;">&quot;Development&quot;</span>).
      Recurring.Until(2008).EverySingle.Week.On(Day.Thursday).
      Except.Each.Year.In(Month.July | Month.August);
planningMeeting.SendInvitations();

</pre></div>
</div>
<p>It may not be as clean as a say a Ruby version might be, but even with
all the parens and periods it’s still pretty readable. Fowler calls this
a <a href="http://www.martinfowler.com/bliki/FluentInterface.html">fluent
interface</a>, a
term I like better than “internal DSL”.</p>
<p>Two things jumped out at me reading Anders’
<a href="http://andersnoras.com/blogs/anoras/archive/2007/07/09/behind-the-scenes-of-the-planning-dsl.aspx">entry</a>
on how he built this fluent interface. First, there’s a lot of code to
make this work. Anders didn’t publish the code, but he did admit:</p>
<blockquote>
<p>“Believe me, there will be a lot of code when you’re done. I’m almost
there with this DSL, and at the time of writing it consists of 58
classes not including the API and tests.”</p>
</blockquote>
<p>That’s 58 classes just to implement the fluent interface, not counting
the underlying EventComponent API. That’s a lot of non-business logic
code to write. How many projects are willing to invest that kind of time
and effort to build a fluent interface? (I would guess “not many”)</p>
<p>However, I bet there’s a lot of template-izable code in Anders fluent
interface. When he writes about keeping the language consistent by
“creating branches within our grammar using different descriptor
objects”, I can help but think about parser development with
<a href="http://en.wikipedia.org/wiki/YACC">YACC</a> and the like. These tools
typically use a DSL like
<a href="http://en.wikipedia.org/wiki/Backus-Naur_form">BNF</a>. Maybe we could
build a DSL for building fluent interfaces?</p>
<p>Second, Anders makes a very interesting point about the structure of the
fluent interface code:</p>
<blockquote>
<p>Writing DSLs is a little different from the regular object oriented
programming style. You might have noticed that the Plan class has a
verb for its name rather than the usual noun. This allows us to have a
natural starting point for writing out the “sentence” explaining our
intention.</p>
</blockquote>
<p>Where have you seen this verb based approach before? Powershell cmdlets.</p>
<blockquote>
<p>Windows PowerShell uses a verb-noun pair format for the names of
cmdlets and their derived .NET classes. For example, the Get-Command
cmdlet provided by Windows PowerShell is used to retrieve all commands
registered in the Windows PowerShell shell. The verb part of the name
identifies the action that the cmdlet performs. The noun part of the
name identifies the entity on which the action is performed.<br />
[<a href="http://msdn2.microsoft.com/en-us/library/ms714428.aspx">Cmdlet Verb
Names</a>, MSDN
Library]</p>
</blockquote>
<p>I’ve
<a href="http://devhawk.net/2007/02/06/perusing-powershell-part-1-get-sqlserver/">written</a>
about this aspect of PowerShell before:</p>
<blockquote>
<p>In OO, most of the focus is on objects, naturally. However,
administrators (i.e. the target audience of PS) tend to be much more
task or action focused than object focused. Most OO languages don’t
have actions as a first class citizens within the language. C# and
Java don’t even allow stand alone functions – they always have to be
at least static members of a class.</p>
<p>I’m fairly sure there are many reasons why strongly typed OO languages
aren’t popular among administrators. I’m not going to go down the
static/dynamic typing rat hole here, but I would guess the
object/action language tradeoff is almost as important as the typing
tradeoff. What’s nice about PowerShell is that while it has strong
object support, it also has strong action support as well. In PS,
actions are called Cmdlets. While I’m not a big fan of the name,
having first class support for them in PS is one of the things I find
most interesting.<br />
[<a href="http://devhawk.net/2007/02/06/perusing-powershell-part-1-get-sqlserver/">Perusing Powershell Part 1:
Get-SQLServer</a>,
DevHawk]</p>
</blockquote>
<p>While there is no first-class support for verbs or actions in C#, it
looks like Anders has essentially rolled his own. For example, his
Plan.Event() method returns a new EventDescriptor object. Subsequent
calls on this object (RelatedTo, WithPriority, OrganizedBy) change the
internal state of this EventDescriptor object. When you reach the end of
the chain of calls, EventDescriptor has an implicit EventComponent cast
operator that creates a new EventComponent with all the data that’s been
collected along the chain by the EventDescriptor.</p>
<p>Again, I can help but think a significant amount of code in this
approach can be generalized and the creation automated. Also, I wonder
if any of the new C# 3.0 capabilities could be used to improve the
implementation. For example, would <a href="http://weblogs.asp.net/scottgu/archive/2007/03/13/new-orcas-language-feature-extension-methods.aspx">Extension
Methods</a>
make it easier to build the fluent interface? Maybe / Maybe not.
Regardless, Anders has given me a lot to noodle on.</p>
