<p>One of the cool things about having a blogging conversation with
<a href="http://blogs.msdn.com/garethj">someone on the other side of the world</a>
is that while you sleep they are thinking of a <a href="http://blogs.msdn.com/garethj/archive/2005/12/19/505732.aspx">good
response</a>
to your post. The only downside? Having to deal with rampant misspelling
like â€œartefactsâ€.
ğŸ˜„</p>
<p>Anyway, Gareth responds to <a href="http://devhawk.net/2005/12/19/imprecise-vs-incomplete/">my
post</a>:</p>
<blockquote>
<p>Until we get models that are perfectly aligned with our business
domains, weâ€™ll have people who want to create models but who get them
slightly wrong from a precision point of view â€“ usually in the places
where the imperfect models interact with other aspects of the system
across or down the abstraction stack.</p>
<p>With code, youâ€™d likely not want to have people check in sources that
donâ€™t even compile and then hand them off to other folks who do make
them compile, but I think thatâ€™s exactly the type of process weâ€™ll see
emerging in modelling for a while. I feel this way because I donâ€™t
foresee us getting modelling languages of <em>pure business intent</em> 100%
right for some time yet â€“ weâ€™re simply not close enough to formal
enough descriptions of systems as intensely human as a business yet.
However, I hope we wonâ€™t want to try and keep modelling as locked away
with the techies as traditional development has been. (Hope Iâ€™m not
talking myself out of a job hereâ€¦)<br />
[<a href="http://blogs.msdn.com/garethj/archive/2005/12/19/505732.aspx">Pseudomodels and intent</a>]</p>
</blockquote>
<p>I keep saying incomplete and Gareth keeps saying imprecise, but I think
we can both agree on the term â€œimperfectâ€. Thereâ€™s a massive difference
between having an precise language that is imperfect versus a language
that is inherently imprecise like UML.</p>
<p>However, I think the primary disconnect here has to do with Gareth and
my views on how higher abstracted languages will evolve. Garethâ€™s
comments about modeling â€œpure business intentâ€, having â€œmodels that are
perfectly aligned with our business domainsâ€ and not â€œkeep[ing]
modelling as locked away with the techiesâ€ imply to me that Gareth wants
to work down from the high level business abstractions into
implementable technical abstractions. Frankly, I donâ€™t think thatâ€™s very
likely. Leapfrogging a few levels of abstraction hasnâ€™t worked well in
the past (CASE and UML/MDA) and I donâ€™t think it will work well now.</p>
<p>I find it much more likely that we will build higher level abstractions
directly on top of existing abstractions. Again, this is similar to the
way C++ built on C which in turn built on ASM. Sure, that could keep
modeling â€œlocked away with the techiesâ€ for a while, but weâ€™re already
beginning to see the light at the end of that tunnel. <a href="http://msdn.microsoft.com/windowsvista/building/workflow/default.aspx">Windows Workflow
Foundation</a>
is a significant leap in abstraction while also being something than
non-techies can use. Reports about about Sharepoint â€œ12â€³ embedding the
WF engine and FrontPage â€œ12â€³ providing a Workflow Designer for building
SharePoint workflows. While I imagine (and I havenâ€™t used any of the new
Office â€œ12â€³ suite so this is pure conjecture) these WF tools are
targeting the â€œpower userâ€, they certainly arenâ€™t only for developers.</p>
<p>Believe me, I would love to be wrong about this. I would much rather
work down from or business user intent than up from the technical
foundation. I just donâ€™t think itâ€™s feasible. The process Gareth
describes breaks the â€œModel Transformation must be Deterministicâ€ tenet
of <a href="http://devhawk.net/2005/10/05/code-is-model/">Code is Model</a>,
though the word â€œmustâ€ may be to strong to allow for language evolution.</p>
