<p>Now that I can <a href="http://devhawk.net/2008/05/06/stream-processing-xml-in-ironpython/">stream process
XML</a>,
the next logical step is to deserialize it into some type of object
graph. As I said in my last post, there are at least three different
DOM-esque options on the .NET platform as well as two in the Python
library (<a href="http://docs.python.org/lib/module-xml.dom.html">xml.dom</a> and
<a href="http://docs.python.org/lib/module-xml.dom.minidom.html">xml.minidom</a>)</p>
<p>However, anyone whoâ€™s ever programmed against the
<a href="http://www.w3.org/DOM/">DOM</a> knows just what a major PITA it is.</p>
<p>Instead, you could deserialize the XML into a custom object tree, based
on the nodes in the XML stream. In .NET, there are at least two
libraries for doing this: the old-school
<a href="http://msdn.microsoft.com/library/system.xml.serialization.xmlserializer">XmlSerializer</a>
as well as the new-fangled
<a href="http://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer">DataContractSerializer</a>.
In these libraries, the PITA comes in defining the static types with all
the various custom attribute adornments you need to tell the
deserializer how to do itâ€™s job. Actually, if youâ€™re defining your code
first, all those adornments arenâ€™t that big a deal. However, if youâ€™re
starting from the XML, especially XML with lots of different namespaces
â€“ like say <a href="http://feeds.feedburner.com/Devhawk">my RSS feed</a> â€“ defining
a static type for this gets old fast.</p>
<p>Of course, if youâ€™re not using a statically typed languageâ€¦
ðŸ˜‰</p>
<p>One of the cool aspects of dynamic languages is the ability to easily
generate new types on the fly. In Python, you can create a new type by
calling the type function. Hereâ€™s an example of creating a new type for
a XML node:</p>
<div class="lang-python editor-colors">def create_type(node, parent):  
  return type(node.name, (parent,), {'xmlns':node.namespace})

</div>
<p>Since Iâ€™m working with XML, I wanted to make sure I handled namespaces.
Thus, I add the namespace to the class definition (the third parameter
in the type function above). This lets me walk up to any arbitrary
object created from an XML element and check itâ€™s namespace.</p>
<p>I used this dynamic type creation functionality in my
<a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/xml2py.py">xml2py</a>
module, which I added to my <a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff">IronPython SkyDrive
folder</a>.
It leverages
<a href="http://cid-0d9bc809858885a4.skydrive.live.com/self.aspx/DevHawk%20Content/IronPython%20Stuff/ipypulldom.py">ipypulldom</a>,
so make sure you get both. The heart of the module is the xml2py
function, which recursively iterates thru the node stream and builds the
tree. Attributes and child elements become named attributes on the
object, so I can write code that looks like this:</p>
<div class="lang-python editor-colors">import xml2py  
rss = xml2py.parse('http://feeds.feedburner.com/Devhawk')  
for item in rss.channel.item:  
  print item.title

</div>
<p>You see? No screwing around with childNodes or getAttribute here.</p>
<p>The basic processing loop of xml2py creates a new instance of a new type
when it encounters a start element tag. It then collects all the
attributes and children of that element, and adds them as attributes on
the element object, using the name of the type as name of the attribute.
If there are multiple children with the same type name, xml2py converts
that attribute to a list of values. For example, in an RSS feed, there
will be likely be many rss.channel.item elements. In xml2py, the item
attribute of the channel object will be a list of item objects.</p>
<p>Since attributes and child elements are getting slotted together, I
added a _nodetype attribute on each so I can later tell (if I care) if
the value was originally an attribute or element. I havenâ€™t written
py2xml yet, but that might be important then.</p>
<p>I do one optimization for simple string elements like
<code>&lt;foo&gt;bar&lt;/foo&gt;</code>. In this case, I create a type that inherits from
string (hence the need for the parent parameter in the create_type
function above) and contains the string text. It still has the xmlns and
_nodetype attributes, so I could write item.title.xmlns (which is empty
since RSS is in the default namespace) or item.title._nodetype (which
would be XmlNodeType.Element)</p>
<p>Itâ€™s not much code â€“ about 100 lines of code split evenly between the
xml2py function and the _type_factory object. Given that you usually
see the same element in an XML stream over an over, I didnâ€™t want to
create multiple types for the same element. So _type_factory caches
types in a dictionary so I can reuse them. One of the cool things is
that itâ€™s a callable type (i.e. it implements __call__ so I can use
the instance like a function. I started by defining a xtype function
that didnâ€™t cache anything, but then later switched xtype to be a
_type_factory instance, but none of my code that called xtype had to
change!</p>
<p>One other quick note. If you put xml2py.py and ipypylldom.py in a
folder, you can experiment with them by launching <code>ipy -i xml2py</code>. This
runs xml2py.py as a script, but dumps you into the interactive console
when youâ€™re thru. It will run the little snippet of code above which
runs xml2py on my <a href="http://feeds.feedburner.com/Devhawk">FeedBurner
feed</a>, but then you can play around
with the rss object and see what it contains. Be sure to check out the
xmlns attribute for each object in the rss.channel.link list.</p>
