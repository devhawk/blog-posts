<p>A few months ago, Ted Neward wrote a <a href="http://msdn.microsoft.com/library/en-us/dndotnet/html/linqcomparisons.asp">great
article</a>
about the history of the Object Relational Impedance Mismatch problem
and how <a href="http://msdn.microsoft.com/netframework/future/linq">LINQ</a> is
addressing it in a new way. Basically, LINQ is introducing new language
abstractions and complementary libraries to enable queries as a first
class concept within the language. However, I don’t believe that O/R
Impedance Mismatch is the whole problem. More specifically, it’s a
follow-on problem to what I would call the Dual Schema problem.</p>
<p>In a nutshell, the Dual Schema problem is that you have to design and
implement two separate versions of your persistent entities. There’s the
in memory version, typically written in an OO language like C# or Java.
Then there’s the on disk version, typically written in SQL. Regardless
of the difficulties translating between the two versions (i.e. the
aforementioned impedance mismatch), you have to first deal with the
complexity of keeping the two versions in sync. While LINQ does a great
job eliminating much of the friction translating between on disk and in
memory formats, it could go much farther by eliminating the need for
translation in the first place.</p>
<p>A variety of solutions to the Dual Schema problem have evolved,
primarily outside the hallowed halls of enterprise vendors (i.e. MS and
others like us). One such solution is <a href="http://www.rubyonrails.com/">Ruby on
Rails</a>. In a Rails environment, I simply
declare the existence of a given persistent entity:</p>
<div class="lang-ruby editor-colors">class Person < ActiveRecord::Base
end

</div>
<p>The ActiveRecord base class (a standard part of Rails) will dynamically
create methods and attributes on the Person object at runtime, based on
the schema of the People table in the database. (Rails is smart enough
to understand English plurals, hence the automatic connection of Person
and People.) So technically there are still two schemas, but the
in-memory version is automatically derived of the on-disk version.</p>
<p>(Note, DLinq provides a conceptually similar tool – SqlMetal – that can
generate the static types from a given database schema. However, as
static types they have to be defined at compile time. So while SqlMetal
reduces the effort to keep schemas in sync, it doesn’t eliminate it the
way Rails does.)</p>
<p>By slaving the object schema to the database schema, Rails essentially
solves the Dual Schema problem. The problem with the Rails approach is
that defining a database schema requires a significant amount of skill
and effort. Defining classes is typically trivial in comparison.The fact
Rails allows you to implement a persistent entity with almost no code
doesn’t help you much if you have to write and maintain a ton of SQL
code to define your database schema.</p>
<p>I believe the Rails model is actually backwards. It would be much better
for the developer if they could define their persistent entity in code
and slave the database schema to the object model instead of the other
way around.</p>
<p>Of course, this approach isn’t exactly news. In his article, Ted writes
of the rise and fall of OO database management systems, which were
supposed to solve the Dual Schema and Impedance Mismatch problems. I’m
certainly not suggesting a return to the heyday of OODBMS. However, one
of the reasons Ted points out OODBMS failed was because big companies
were already wedded to RDBMS. But those big companies are the short
head. As you move down the <a href="http://bnoopy.typepad.com/bnoopy/2005/03/the_long_tail_o.html">long tail of
software</a>,
relational database as the primary storage paradigm makes less and less
sense. For the vast majority of applications, relational databases are
overkill.</p>
<p>Ted’s other point about OODBMS is that loose coupling between the data
store and the in memory representation is a feature, not a flaw. He’s
totally right. But can’t we advance the state of the art in database
typing to the level of modern day OO languages? How about eliminating
anachronisms like fixed length strings? What if we derive the database
schema from the object model – Rails in reverse if you will – but is
still loosely coupled enough to allow for schema evolution?</p>
<p>An example of this code-centric model for data storage is
<a href="http://www.garret.ru/%7Eknizhnik/consus.html">Consus</a>. It’s written by
Konstantin Knizhnik, who has written a bunch of <a href="http://www.garret.ru/%7Eknizhnik/databases.html">open source,
object-oriented and object-relational
databases</a> across a wide
variety of languages and execution environments, including CLR. Consus
is actually written in Java, but he provides version compiled for .NET
using <a href="http://msdn.microsoft.com/vjsharp/">Visual J#</a>. Consus lets you
to define your data either as tables or objects. So you can do this:</p>
<div class="lang-java editor-colors"><div style="color:Black;background-color:White;"><pre>
Statement st = db.createStatement();
st.executeUpdate(<span style="color:#A31515;">&quot;create table Person (name string, address string, salary bigint)&quot;</span>);
st.executeUpdate(<span style="color:#A31515;">&quot;insert into Person values (&#39;John Smith&#39;, &#39;1 Guildhall St.&#39;, 75000)&quot;</span>);
ResultSet rs = st.executeQuery(
    <span style="color:#A31515;">&quot;select name, address, salary from Person where salary &gt; 100000&quot;</span>);

</pre></div>
</div>
<p>Or you can do this:</p>
<div class="lang-java editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">class</span> Person {
    String name;
    String address;
    <span style="color:Blue;">long</span> salary;
    Person(String aName, <span style="color:Blue;">long</span> aSalary, String aAddress) {
        name = aName;
        salary = aSalary;
        address = aAddress;
    }
};

Person p = <span style="color:Blue;">new</span> Person(<span style="color:#A31515;">&quot;John Smith&quot;</span>, 75000, <span style="color:#A31515;">&quot;1 Guildhall St.&quot;</span>);
ConsusStatement st = db.createStatement();
stmt.insert(p);
ConsusResultSet cursor = (ConsusResultSet)st.executeQuery(
    <span style="color:#A31515;">&quot;select from Person where salary &gt; 100000&quot;</span>);

</pre></div>
</div>
<p>Consus also handles OO concepts like derivation and containment. Of
course, the embedded queries are ugly, but you could imagine DLinq style
support for Consus. In fact, one of the primary issues with Consus is
that it supports both object and tuple style queries. When you
explicitly request tables (i.e. “select name, address salary from
Person”), you’ve got a tuple style query. When you don’t (i.e. “select
from Person”) you’ve got an object style query. Of course, the issues
with tuple style queries are well documented in Ted’s article and is
exactly the problem that LINQ is designed to solve.</p>
<p>(Konstantin, if you’re reading this, <a href="mailto:harry.pierson@microsoft.com">drop me a
line</a> and I’ll look into getting you
hooked up with the LINQ folks if you’re interested in adding LINQ
support to Consus.NET.)</p>
<p>The tradeoff between the Rails approach and the Consus approach is one
of performance. I have a ton of respect for Konstantin and the work he’s
done on Consus and other OO and OR databases available from his site.
However, I sure the combined developer forces at major database vendors
like Microsoft (and other DB companies) means SQL Server (and the like)
will out perform Consus by a significant margin, especially on large
scale databases. So if execution performance is your primary criteria,
the Ruby on Rails approach is better (leaving aside discussion of the
Ruby runtime itself). However, in the long run execution performance is
much less important than developer productivity. So I believe that  for
all the current interest in Rails, I think a Consus-style model will
become dominant.</p>
