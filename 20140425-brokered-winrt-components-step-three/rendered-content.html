<p>So far, we‚Äôve created two projects, written all of about two lines of
code and we have both our <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-one">brokered
component</a> and
its
<a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">proxy/stub</a>
ready to go. Now it‚Äôs time to build the Windows Runtime app that uses
the component. So far, things have been pretty easy ‚Äì the only really
tricky and/or manual step so far has been registering the proxy/stub,
and that‚Äôs only tricky if you don‚Äôt want to run VS as admin.
Unfortunately, tying this all together in the app requires a few more
manual steps.</p>
<p>But before we get to the manual steps, let‚Äôs create the WinRT client
app. Again, we‚Äôre going to create a new project but this time we‚Äôre
going to select ‚ÄúBlank App (Windows)‚Äù from the Visual C# -&gt; Store
Apps -&gt; Windows App node of the Add New Project dialog. Note, I‚Äôm not
using ‚ÄúBlank App (Universal)‚Äù or ‚ÄúBlank App (Windows Phone)‚Äù because the
brokered WinRT component feature is not support on Windows Phone. Call
the client app project whatever you like, I‚Äôm calling mine
‚ÄúHelloWorldBRT.Client‚Äù.</p>
<p>Before we start writing code, we need to reference the brokered
component. We can‚Äôt reference the brokered component directly or it will
load in the sandboxed app process. Instead, the app need to reference a
reference assembly version of the .winmd that gets generated
automatically by the proxy/stub project. Remember in the <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-two">last
step</a> when
I said Kieran Mockford is an MSBuild wizard? The proxy/stub template
project includes a custom target that automatically publishes the
reference assembly winmd file used by the client app. When he showed me
that, I was stunned ‚Äì as I said, the man is a wizard. This means all
<em>you</em> need to do¬†is right click on the References node of the WinRT
Client app project and select Add Reference. In the Reference Manager
dialog, add a reference to the proxy/stub project you created in step
two.</p>
<p>Now I can add the following code to the top of my App.OnLaunched
function. Since this is a simple Hello World walkthru, I‚Äôm not going to
bother to build any UI. I‚Äôm just going to inspect variables in the
debugger. Believe me, the less UI I write, the better for everyone
involved. Note, I‚Äôve also added the P/Invoke signatures for
GetCurrentProcess/ThreadID and to the client app like I did in the
brokered component in <a href="http://devhawk.net/2014/04/25/brokered-winrt-components-step-one">step
one</a>.
This way, I can get the process and thread IDs for both the app and
broker process and compare them.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> pid = GetCurrentProcessId();
<span style="color:Blue;">var</span> tid = GetCurrentThreadId();

<span style="color:Blue;">var</span> c = <span style="color:Blue;">new</span> HelloWorldBRT.Class();
<span style="color:Blue;">var</span> bpid = c.CurrentProcessId;
<span style="color:Blue;">var</span> btid = c.CurrentThreadId;

</pre></div>
</div>
<p>At this point the app will compile, but if I run it the app will throw a
TypeLoadException when it tries to create an instance of
HelloWorldBRT.Class. The type can‚Äôt be loaded because the we‚Äôre using
the reference assembly .winmd published by the proxy/stub project ‚Äì it
has no implementation details, so it can‚Äôt load.¬†In order to be able to
load the type, we need to declare the HelloWorldBRT.Class as a brokered
component in the app‚Äôs pacakge.appxmanifest file. For non-brokered
components, Visual Studio does this for you automatically. For brokered
components we have to do it manually unfortunately. Every activatable
class (i.e. class you can construct via ‚Äúnew‚Äù) needs to be registered in
the appx manifest this way.</p>
<p>To register HelloWorldBRT.Class, right click the Package.appxmanifest
file in the client project, select ‚ÄúOpen With‚Äù from the context menu and
then select ‚ÄúXML (Text) editor‚Äù from the Open With dialog. Then you need
to insert <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211443.aspx">inProcessServer
extension</a>
that includes an <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211413.aspx">ActivatableClass
element</a>
for each class you can activate (aka has a public constructor). Each
ActivatableClass element contains an ActivatableClassAttribute element
that contains a pointer to the folder where the brokered component is
installed. Here‚Äôs what I added to Package.appxmainfest of my
HelloWorldBRT.Client app.</p>
<div class="lang-xml editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">&lt;</span><span style="color:#A31515;">Extensions</span><span style="color:Blue;">&gt;</span>
  <span style="color:Blue;">&lt;</span><span style="color:#A31515;">Extension</span> <span style="color:Red;">Category</span><span style="color:Blue;">=</span><span style="color:Black;">&quot;</span><span style="color:Blue;">windows.activatableClass.inProcessServer</span><span style="color:Black;">&quot;</span><span style="color:Blue;">&gt;</span>
    <span style="color:Blue;">&lt;</span><span style="color:#A31515;">InProcessServer</span><span style="color:Blue;">&gt;</span>
      <span style="color:Blue;">&lt;</span><span style="color:#A31515;">Path</span><span style="color:Blue;">&gt;</span>clrhost.dll<span style="color:Blue;">&lt;/</span><span style="color:#A31515;">Path</span><span style="color:Blue;">&gt;</span>
      <span style="color:Blue;">&lt;</span><span style="color:#A31515;">ActivatableClass</span> <span style="color:Red;">ActivatableClassId</span><span style="color:Blue;">=</span><span style="color:Black;">&quot;</span><span style="color:Blue;">HelloWorldBRT.Class</span><span style="color:Black;">&quot;</span>
                        <span style="color:Red;">ThreadingModel</span><span style="color:Blue;">=</span><span style="color:Black;">&quot;</span><span style="color:Blue;">both</span><span style="color:Black;">&quot;</span><span style="color:Blue;">&gt;</span>
        <span style="color:Blue;">&lt;</span><span style="color:#A31515;">ActivatableClassAttribute</span>
             <span style="color:Red;">Name</span><span style="color:Blue;">=</span><span style="color:Black;">&quot;</span><span style="color:Blue;">DesktopApplicationPath</span><span style="color:Black;">&quot;</span>
             <span style="color:Red;">Type</span><span style="color:Blue;">=</span><span style="color:Black;">&quot;</span><span style="color:Blue;">string</span><span style="color:Black;">&quot;</span>
             <span style="color:Red;">Value</span><span style="color:Blue;">=</span><span style="color:Black;">&quot;</span><span style="color:Blue;">D:\dev\HelloWorldBRT\Debug\HelloWorldBRT.PS</span><span style="color:Black;">&quot;</span><span style="color:Blue;">/&gt;</span>
      <span style="color:Blue;">&lt;/</span><span style="color:#A31515;">ActivatableClass</span><span style="color:Blue;">&gt;</span>
    <span style="color:Blue;">&lt;/</span><span style="color:#A31515;">InProcessServer</span><span style="color:Blue;">&gt;</span>
  <span style="color:Blue;">&lt;/</span><span style="color:#A31515;">Extension</span><span style="color:Blue;">&gt;</span>
<span style="color:Blue;">&lt;/</span><span style="color:#A31515;">Extensions</span><span style="color:Blue;">&gt;</span>

</pre></div>
</div>
<p>The key thing here is the addition of the DesktopApplicationPath
ActivatableClassAttribute. This tells the WinRT activation logic that
HelloWorldBRT.Class is a brokered component and where the managed .winmd
file with the implementation details is located on the device. Note, you
can use multiple brokered components in your side loaded app, but they
all have the same DesktopApplicationPath.</p>
<p>Speaking of DesktopApplicationPath, the¬†path I‚Äôm using here is path the
final location of the proxy/stub components generated by the compiler.
Frankly, this isn‚Äôt an good choice to use in a production deployment.
But for the purposes of this walk thru, it‚Äôll be fine.</p>
<p><a href="http://image.devhawk.net/blog-content/20140425-brokered-winrt-components-step-three/ClientWatchWindow.png"><img src="http://image.devhawk.net/blog-content/20140425-brokered-winrt-components-step-three/ClientWatchWindow-300x94.png" alt="ClientWatchWindow" /></a></p>
<p>Now when we run the app, we can load a HelloWorldBRT.Class instance and
access the properties. re definitely seeing a different app process IDs
when comparing the result of calling GetCurrentProcessId directly in
App.OnLoaded vs. the result of calling GetCurrentProcessId in the
brokered component. Of course, each run of the app will have different
ID values, but this proves that we are loading our brokered component
into a different process from where our app code is running.</p>
<p>Now you‚Äôre ready to go build your own brokered components! Here‚Äôs hoping
you‚Äôll find more interesting uses for them than comparing the process
IDs of the app and broker processes in the debugger!
üòÑ</p>
