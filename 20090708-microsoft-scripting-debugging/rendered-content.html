<p>If you’ve compiled IronPython from source recently, you may have noticed
a new DLL:
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#908451">Microsoft.Scripting.Debugging</a>.
This DLL contains a lightweight, non-blocking debugger for DLR based
languages that is going to enable both new scenarios as well as better
compatibility with CPython. Needless to say, we’re very excited about
it.</p>
<p>When I was actively working on my <a href="http://devhawk.net/CategoryView,category,Debugger.aspx">ipydbg
series</a>, I got
several emails asking about using it in an embedded scripting scenario.
Unfortunately, the ipydbg approach doesn’t work very well in the
embedded scripting scenario. ipydbg uses
<a href="http://msdn.microsoft.com/en-us/library/ms230588.aspx">ICorDebug</a> and
friends, which completely blocks the application being debugged. This
means, your debugger <em>has</em> to run in a separate process. So either you
run your debugger in your host app process and your scripts in a
separate process or you run your debugger in a separate process
debugging both the scripts and the host app. Neither option is very
appealing.</p>
<p>Now with the DLR Debugger, you can run all three components in the same
process. I think of the DLR debugger as a “cooperative” debugger in much
the same way that Windows 3.x supported <a href="http://en.wikipedia.org/wiki/Cooperative_multitasking#Cooperative_multitasking.2Ftime-sharing">cooperative
multitasking</a>.
It’s also known as trace or traceback debugging. Code being debugged
yields to the debugger at set points during its execution. The debugger
then does whatever it wants, including showing UI and/or letting the
developer inspect or modify program state. When the debugger returns,
execution of the original code continues until the next set point
wherein the process repeats itself.</p>
<p>The primary point of entry for the DLR Debugger is the <a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#908446">DebugContext
class</a>.
Notable there is the TransformLambda method, which takes a normal DLR
LambdaExpression and transforms it into a cooperatively debugged
LambdaExpression. LambdaExpressions can contain DebugInfoExpressions –
typically we insert them at the start of every Python code line as well
as one at the end of the function. When we run IronPython in debug mode
(i.e. –D), those get turned into sequence points <a href="http://devhawk.net/2009/03/02/writing-an-ironpython-debugger-setting-a-breakpoint/">as we
saw</a>
back when I was working on ipydbg. When using the DLR Debugger, those
DebugInfoExpressions are transformed into calls out to
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#908429">IDebugCallback</a>.OnDebugEvent.
The DLR Debugger implements the IDebugCallback interface on the
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#908413">TracePipeline</a>
class which also implements
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#908414">ITracePipeline</a>.
In OnDebugEvent, TracePipeline calls out to an
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#908415">ITraceCallback</a>
instance you provide. The extra layer of indirection means you can
change your traceback handler without having to regenerate the
debuggable version of your functions.</p>
<p>Of course, we hide all this DLR Debugger goo from you in IronPython.
Python already has a mechanism for doing traceback debugging –
<a href="http://docs.python.org/library/sys.html#sys.settrace">sys.settrace</a>.
Our ITraceCallback,
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#922366">PythonTracebackListener</a>,
wrapps the DLR Debugger API to expose the sys.settrace API. That makes
this feature a twofer – new capability for IronPython + better
compatibility with CPython. Instead of needing a custom tool (i.e.
ipydbg) you can now use <a href="http://docs.python.org/library/pdb.html">PDB</a>
from the standard Python library (modulo bugs in our implementation). I
haven’t been working on ipydbg recently since you’ll be able to use PDB
soon enough.</p>
<p>For those hosting IronPython, we also have a couple of static extension
methods in our hosting API (look for the SetTrace functions in
<a href="http://ironpython.codeplex.com/SourceControl/changeset/view/56115#490056">IronPythonHostingPython.cs</a>).
These are simply wrappers around sys.settrace, so it has the same API
regardless if you access it from inside IronPython or from the hosting
API. But if you’re hosting IronPython in a C# application, those
extension methods are very convenient to use.</p>
<p>This debugger will be in our regular releases of IronPython as of 2.6
beta 2 which is
<a href="http://ironpython.codeplex.com/Wiki/View.aspx?title=2.6%20Release%20Plan">scheduled</a>
to drop at the end of this month. For those who just can’t wait, it’s
available as source code starting with yesterday’s
changeset. Please let us know what you think!</p>
