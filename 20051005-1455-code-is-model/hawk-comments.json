[
  {
    "id": 2850,
    "author-name": "Steven Kelly",
    "author-email": "stevek@metacase.com",
    "author-url": "http://www.metacase.com/blogs/stevek/blogView",
    "date": "2005-10-06T04:53:44-07:00",
    "content": "[Hmm, trying to submit a comment returned me to the same page with my comment text, let's try again...]\n\nGreat piece of writing, Harry! Here are some additions (also added in my blog, link above):\n\nModels Aren't Always Graphical:\nThe only alternative to graphical models that you mention is text. I'd like to add matrices and tables. A matrix is normally like in IBM's Business Systems Planning, with objects on the axes and relationships marked in the cell at the intersection of their object. A table is basically an ordered list of objects and their properties: graphical models are otherwise poor at representing an ordered list. It's probably also useful to distinguish \"standard\" bubble-and-line graphical models from things like Sequence Diagrams, Constraint Diagrams, Spider Diagrams and even UI layouts, where the exact position of elements, and their position relative to each other, has semantic content.\n\nTo return to text: Unfortunately, text doesn't integrate well with other models, primarily because it has no notion of object identity. If I write a piece of code to go with a model, I often want to use the name of one of the model's objects in the code, but there is currently no good way to do this. Copying and pasting loses the link, i.e. if I update the name in the model, it will (at least in a half-way decent modeling tool) update everywhere else in the model where that name is visible, but the text will still contain the old value. \n\nClearly, we need Smart Text, but exactly what that is and how it would work is an interesting research topic. Current text-based tools at best try to parse the text and cobble the links back together after changes, but that's time consuming, error prone, and basically bolting the stable door well after the horse has left. \n\nI guess Intentional Programming is aiming to be something like Smart Text. My impression so far though is that the Intentional Programming crowd aren't particularly amenable to graphical representations - \"nah, we don't want those, we can do it all in text\". Hopefully I'm wrong or that is going to change: model-driven development and Smart Text would complement each other perfectly.",
    "parent-id": 639,
    "RowKey": "20051006-045344"
  },
  {
    "id": 2851,
    "author-name": "David Ing",
    "author-email": "david.ing@gmail.com",
    "author-url": "http://from9till2.com",
    "date": "2005-10-06T06:59:18-07:00",
    "content": "Good points Harry. I'm not a great fan of tenets thoughâ€¦ ;-)\n\nI whole-heartily agree that an important lesson not to forget from the 'CASE-years' is that (a) we can't lose fidelity between the execution side (code) and the design representations in any modeling approach and (b) no oceans will require boiling. It is interesting though that saying exactly what is 'code' is actually getting increasingly harder to do. \n\nTo carry on your thread, it seems to me we are heading for more and more declarative style systems definitions either at the system framework level (Workflow State persistence, XAML presentation, Policy assertions) or at the DSL's for specific configuration points of a custom framework. The languages of C# and the like will always play the majority part, but it's the libraries/run-times and the like will really need the 'abstraction points' more. Perhaps it's the interface definitions (schema?) and the behaviors around those that need the most thought in terms of their expression in the model?\n\nAnother thought is that what we lack is the common conventions for visualization of these 'non-imperative' styles. To be a useful abstraction it would seem to be important to be able to relate and summarize these things concisely. Text is useful (and can be very precise) but polymetric visualizations (the sort of stuff that Edward Tufte has been on about for years) seems to be a harvestful area for models. In the last 20 years we've spent a lot of time working out that a class shouldn't look like a cloud but a rectangle, for example. We did that so we could scale model bits to used from *AsASketch to *AsABluePrint. As computer system designers we obviously dont have a lot of faith in computer system tools as a reliable enabler?\n\nIf we could let go of the UML mindset of a paper-printable-centric model representation that treats the run-time as a generic block then we could be making good progress for MDD. It's a note of irony of course that the MDA/MOF may be the exact opposite of what it will take to get to a next step of handling increased complexity. Maybe we should be letting go of those representations to move forward?\n\nWe do seem to be hitting a wall with the level of complexity we have at the moment and that a 'Unified' approach ain't gonna cut it. IMO.\n\nPS Good 'model' refresher paper here for those interested: \n\nhttp://www.bptrends.com/publicationfiles/01-04%20COL%20Dom%20Spec%20Modeling%20Frankel-Cook.pdf \n\n- David\n",
    "parent-id": 639,
    "RowKey": "20051006-065918"
  },
  {
    "id": 2852,
    "author-name": "Alan Cameron Wills",
    "author-email": "awills@microsoft.com",
    "author-url": "http://blogs.msdn.com/alan_cameron_wills/",
    "date": "2005-10-06T09:41:21-07:00",
    "content": "Good stuff.\n\n\"Models are Precise\" - well:\n\n(a) There is a use for imprecise models. When I'm sketching an architecture on the corner of a whiteboard, I don't need a precise semantics: I need a notation familiar enough that I can convey and discuss my ideas. What's familiar might depend on the business context and the level of implementation detail I'm talking at - flight paths, tube map, org charts, or maybe sequence charts.\n\n(b) Where we do use models for precise purposes - generating code or configurations or whatever - it is useful if the precise notation is related to, and can easily degenerate into, the familiar imprecise form. So that I can quickly sketch an impression of what I want, and later fix up the detail to make it work.\n\nModels are Abstract - no, this wasn't one of your headers, but I think it nearly was! Abstract means leaving stuff out; the power of it is that it lets me squeeze big ideas into my small brain. There's less information in an abstraction.  For me, this is the essential thing that makes it a \"model\": it leaves out information.\n\nThere are several distinct ways a model can be abstract - i.e. leave out information:\n\n 1. Leave out unvarying assumptions. \n   1a   C is an abstraction of ASM because it's assumed your code follows some conventions -- for example, keeping stuff on the stack while calling a subroutine. By restricting ourselves to those assumptions, we can read the code more easily; the information is put back by the compiler.  Of course, a great benefit is that we can 'put back' different variants of the left-out stuff, to work atop different platforms.\n\n   1b   A DSL that drives a framework - for example to configure a mobile phone or a watch - is abstract because it doesn't include the stuff that's the same every time: the basic structure of the phones.  In the DSL, we omit the information about those assumptions, and the generators and execution framework put it information back.\n\n 2. Separation of concerns.\n    A model that's about the sequence of pages in a GUI can leave out stuff about the appearance of the pages. The appearance can be dealt with in a separate language elsewhere. Here, the separate models leave out the information dealt with elsewhere, and the left-out information is put back when the different aspects or viewpoints are composed (by whatever mechanism).\n\n(I suppose that really (1) is a particular case of (2) -- the place where you choose what platform you want to implement on is a separate language, and the choice of compiler is the composition mechanism.)\n\n 3. Indeterminacy.\n    The model is abstract because some of the information hasn't been determined or decided yet; or is maybe different every time. So for example:\n   - an HTML page specifies a sequence of words, but it rarely defines exactly how they're arranged on a screen -- that depends on the width of the window etc.\n   - programs in C# specify a sequence of behavior, but don't specify the exact timings of events; by contrast, MIDI defines the exact timings of the musical notes.\n   - a test script defines a result (like \"out*out==in\", or \"X less than 12\") without saying how you might achieve it, nor even exactly what the result must be -- just some conditions it must fulfill.  \n   - a specification - whether it's formal or informal, a slide show or a test script, or a set of example instances, or just a list of bullet points - is a model. If written well (!) it allows you to discuss the system or solution, without including all the fine detail.\n\nTo me, the indeterminate kind of abstraction is a very important kind of model in software engineering. It allows you to talk sensibly about things without having decided everything yet.  This is an essential, because you can't decide everything all at once.  \n\nProgramming languages aren't terribly good at this - they tend only to make sense once all the decisions have been made.  While we're half-way through a design, I want something that helps me think and talk about half-formed stuff. When working more towards the code, I want things like sequence diagrams etc; when more at the business end, I want languages appropriate to the kind of business domain; and the more I work in a particular domain, the more I want languages attuned to that domain. But again: if it's only good at expressing finished ideas, it's a kind of programming language; for me, a real *modeling* language is one that helps me while I'm developing the ideas.\n\n",
    "parent-id": 639,
    "RowKey": "20051006-094121"
  },
  {
    "id": 2853,
    "author-name": "David Ing",
    "author-email": "david.ing@gmail.com",
    "author-url": "http://from9till2.com",
    "date": "2005-10-06T12:24:19-07:00",
    "content": "Hello Alan - I almost agree.\n\nI think imprecise *Sketch Models are 'ok', and are in many ways, they are where we are now, i.e. UML2. I just wanted to add a thought though.\n\nBut [and at this point I think it's fair to claim a coup d'etat on Harry's blog, just by sheer weight of text] I also think Sketching ability inhibits us slightly from keeping the models nice and tight to the execution-side. One of my greatest fears (goodness, that sounds over-dramatic) is in that progress in Modeling will be held back by going through a number of new rounds of gathering consensus around over a common display notation. If we can't degenerate for pen&board the Model notation then so be it - the steam train rolls on, but if we can, then great; just don't want to sacrifice anything for it. \n\nI think that the benefits of a sketched/shared notation are actually only a small part of the battle in making sure that two people are sharing the same context when designing something. It's often all 'about the run-time' and how well you both share knowledge of it. The sketched rectangles help like they helped pattern languages, you can still talk at cross purposes for as long as you can keep reality at bay. RE:What most people think a Singleton or even MVC patterns do.\n\nAlso, as soon as the model becomes an purely optional part of the development cycle is where it runs the risk of being irrelevant and seen as a withering design artifact for 'that guy in an office down the hall'. \n\nPut another way, I'd trade some common Sketch notation ability any day of the week, as long as it meant I could always get to an execution 'vehicle' and could model early in terms of validating my ideas with the framework's help, i.e. rather than the whiteboard's. I want to 'run' my model as a part of an iterative design process?\nWith the frameworks getting so complex now then the gap between being able to try your ideas from some sort of limited notation into actually running them is getting smaller. We seem to be growing 'rails' all the time, let's make use of that. \n\nAnyhoo, I would be tempted to rename 'Models must be Precise' with something like 'Models must be in Context' or 'Models make Assumptions' or even 'Models Miss Things Out We Already Know Because Our Brains Are Too Small'. I like the last one best.\n\nI did like your comments on abstraction very much, but for me personally I sway towards a modeling language that helps me validate my ideas early rather than share them early.\n\n- David\n",
    "parent-id": 639,
    "RowKey": "20051006-122419"
  },
  {
    "id": 2854,
    "author-name": "Arnon Rotem-Gal-Oz",
    "author-email": "arnon@rgoarchitects.com",
    "author-url": "http://www.rgoarchitects.com",
    "date": "2005-10-06T14:15:46-07:00",
    "content": "[also appears in my blog]\nHi Harry,\n\nWhile I tend to agree that there is a place for precise formal models that can be transformed easily to lower levels. \nI would also like to argue that \n\tâ—‹ I think that imprecise models are also very useful, since at different points in time during the development you cannot fully specify all the finest details (even if for the \"current\" level of abstraction) esp. since most projects these days are iterative.\n\tâ—‹ Which brings me to the next point - for imprecise models - I don't necessarily think that there's a need to keep (all of) them updated during the development life-cycle. The high-level designs can be replaces by detailed designs and they in turn can be replaces with the code itself - good code explains itself beautifully :) . \n\tâ—‹ You should carefully weight the ROI for creating such a precise model. For example I happened to work on a large (hundreds of man-year) project where the initial thought was to use a tool (Vitech's Core (http://www.vtcorp.com/overview.html) ) to for requirements analysis. The benefit was that (if done right) the model created can be \"run\" using their built-in simulator. After spending more than half a year (of a rather large team) we finally decided to drop this precise model for a much less precise model of use-cases which allow for a varying level of abstraction. It should be noted though, that (cross-subsystems) use cases are later refined into a DSL  which is actively used for generating cross-subsystem interfaces and simulate  missing system during  integrations. \n\tâ—‹ Another point from the former example is on the timing of requiring the precision. Modeling tools should allow several levels of precision, since in earlier stages you (usually) cannot determine all the bits and bytes that will allow for a \"deterministic transformation\" \n\t \n\t\nJust my 2 cents \n",
    "parent-id": 639,
    "RowKey": "20051006-141546"
  },
  {
    "id": 2855,
    "author-name": "Magnus Christerson",
    "author-email": "magnus@intentsoft.com",
    "author-url": "",
    "date": "2005-10-09T08:51:51-07:00",
    "content": "Great post, Harry!\n\nWe often use the term \"higher level of abstraction\" as the one and only right answer to manage complexity. A better description would be to use the \"appropriate level of abstraction\" for the task at hand and I blogged on it here http://blog.intentionalsoftware.com/intentional_software/2005/09/appropriate_lev.html\n\nIn that blog we also discussed the need for multiple levels of abstractions that are editable. So the issue of bi-directional transformations between models comes up. Mentally, we think of it as a refinement between the appropriate level. The trick is to maintain model level consistency as editing progresses. In the real messy world, where code is stored in simple text files, that can be edited at will, this is a tricky and expensive problem. Integrating the code in a smarter way might make it a lot easier.\n\nAs for Steven Kelly's earlier blog comment about Intentional only doing SmartText based stuff: Your hopes are correct, we think a combination of text and graphics is the most powerful, and also the most natuaral to use.\n\n/Magnus",
    "parent-id": 639,
    "RowKey": "20051009-085151"
  },
  {
    "id": 2856,
    "author-name": "Jimmy Nilsson",
    "author-email": "Jimmy.Nilsson@jnsk.se",
    "author-url": "http://www.jnsk.se/weblog/",
    "date": "2005-10-10T10:35:35-07:00",
    "content": "Hi Harry,\n\nI posted the following as a comment:\nhttp://www.jnsk.se/weblog/posts/codeismodel.htm\n\nBest Regards,\nJimmy\nwww.jnsk.se/weblog/\n###",
    "parent-id": 639,
    "RowKey": "20051010-103535"
  },
  {
    "id": 2857,
    "author-name": "John",
    "author-email": "",
    "author-url": "http://blogs.msdn.com/jevdemon",
    "date": "2005-10-11T12:18:56-07:00",
    "content": "I have to admit I was ready to debunk this until you got into the (somewhat philosophical) discussion of code being an abstraction layer between the CPU and the developer - nice touch!  That said, I think we can agree that there are different types of models for different types of purposes.  Developers will easily buy into Code is Model but business analysts (and to a lesser extent, architects) will not.  The concept of domain-specfic models helps address this issue.   The one (minor) quibble is the section at the end dealing with views.  Just as we can have different types of models we can also have differnet types views of a single model.  We might have a code view versus a graphical view or an individual participant's view of a larger business process (e.g. a raw material supplier's view of their role and responsibilities in a larger manufacturer's supply chain).  \nNice post!",
    "parent-id": 639,
    "RowKey": "20051011-121856"
  },
  {
    "id": 2858,
    "author-name": "orcmid",
    "author-email": "dennis.hamilton@acm.org",
    "author-url": "http://nfocentrale.net/orcmid/blog/",
    "date": "2006-02-21T13:44:51-08:00",
    "content": "I've been waiting to come up with something profound to toss in here, and I will give that up to point out one particular thing.  First, I agree about (machine) code.  You can tell that from \"What Computers Know\" (http://nfocentrale.net/orcmid/blog/2006/02/what-computers-know.asp).\n\nBut I'm not sure that we are raising the level of abstraction exactly (though raising something, for sure) as we move up through layers of programming languages, maybe not even domain-specific languages.  \n\nWhy do I say that?\n\nWell, because the model is not married to the behavior that is elicited from the computer.  We are doing something about the expressibility of certain things, but we need to understand that a good part of that expressibility having to do with what the program is for is an illusion that only we know and understand.  It has no impact on what the computer does.\n\nMy simple illustration has to do with obfuscation of code.  Run your source-code-as-model through a really-great obfuscator.  Same behavior by the computer; clearly a fully-equivalent program is produced.  But where's the model now?\n\nIn some sense, the transformation from source to executable preserves something and it also delivers something.  The delivery is (at best) very loosely-related to our intention for the software.  It seems to me that the programs we write preserve our model while being indifferent to it.  That this works at all is a consequence of our care and only our care.\n\nThat says to me that the articulation of the model will likely always have to be elsewhere.  Source code doesn't really carry it except as a kind of computer-ignored narrative and cues (choice of identifiers) that are for us and not the machine.  Furthermore, our model is generally different than one that deals at the level of abstraction which has the computer's behavior as its \"extensional\" meaning.\n\n[I don't want to rule out the value of model-driven schemes at this point, although I think it is important to understand where the design rules come from and how that is not anything the computer \"knows\" on its own.]\n\nHmm, maybe this is baked enough to start writing about ... .\n\n",
    "parent-id": 639,
    "RowKey": "20060221-134451"
  }
]