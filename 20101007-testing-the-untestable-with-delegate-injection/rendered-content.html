<p>My ASP.NET skills may be a bit rusty, but that’s not stopping me from
working on a side project in ASP.NET MVC. While it has made significant
strides in the 4.0 release, code like this demonstrates that ASP.NET
still has a long way to go to improve testability.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> AccountController : Controller
{
    ITwitterService _twitter;

    <span style="color:Green;">//constructor dependency injection</span>
    <span style="color:Blue;">public</span> AccountController(ITwitterService twitterService)
    {
        _twitter = twitterService;
    }

    <span style="color:Blue;">public</span> ActionResult SignInWithTwitter()
    {
        <span style="color:Green;">//check for GetRedirectUrl and sets cookie</span>
        Response.SetCookie(<span style="color:Blue;">new</span> HttpCookie(<span style="color:#A31515;">&quot;RedirectUrl&quot;</span>,
            FormsAuthentication.GetRedirectUrl(<span style="color:Blue;">string</span>.Empty, <span style="color:Blue;">false</span>)));

        <span style="color:Green;">//build callback URL</span>
        <span style="color:Blue;">var</span> callback_url_builder = <span style="color:Blue;">new</span> UriBuilder()
        {
            Host = Request.ServerVariables[<span style="color:#A31515;">&quot;SERVER_NAME&quot;</span>],
            Port = <span style="color:Blue;">int</span>.Parse(Request.ServerVariables[<span style="color:#A31515;">&quot;SERVER_PORT&quot;</span>]),
            Path = Url.Action(<span style="color:#A31515;">&quot;SignInWithTwitterCallback&quot;</span>),
        };

        <span style="color:Green;">//Helper funciton to invoke Twitter’s oauth/request_token REST endpoint</span>
        <span style="color:Blue;">var</span> url = _twitter.GetRequestToken(callback_url_builder.ToString());

        <span style="color:Green;">//redirect to the URL returned from _twitter.GetRequestToken</span>
        <span style="color:Blue;">return</span> Redirect(url);
    }

</pre></div>
</div>
<p>This code has several dependencies that are hard or impossible to test:
FormsAuthentication, Request, Response and Url. Testing this code is a
real pain in the ass. When I originally wrote this code, I bit the
bullet and wrote said the PITA test code. But I couldn’t help thinking
there must be a better way.</p>
<p>Clearly, in order to be able to test this code, I need to introduce
points of abstraction that can be filled with mock implementations
during unit test runs. I already have one such abstraction point – the
_twitter field of AccountController is an ITwitterService instance that
gets injected on construction. I have a “real” implementation that gets
injected in production and a mock implementation that I manually inject
in my tests.</p>
<p>In order to test the code above, I’ll need to wrap the calls into the
untestable objects in some sort of injectable dependency that can be
mocked out for tests.</p>
<p>C# being an OO language, typically we think of Dependency Injection in
terms interfaces and classes. However, wrapping the untestables in
interfaces and then implementing those interfaces is a lot of additional
code. Instead of one injected dependency, the code above would need five
injected dependencies. Furthermore, since objects are both the unit of
dependency injection as well as the typical way the URL namespace is
segmented, I also have to consider the dependencies of any other action
methods on AccountController. That gets ugly fast.</p>
<p>Instead of thinking in terms of objects and interfaces, I wondered what
DI might look like if we thought about dependencies in terms of
delegates and anonymous lambdas? You know, <a href="http://devhawk.net/2007/12/04/functional-understanding/">functional
programming</a>? 
It might look something like this:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
Func&lt;<span style="color:Blue;">string</span>&gt; @GetRedirectUrl;
Action&lt;HttpCookie&gt; @SetCookie;
Func&lt;NameValueCollection&gt; @ServerVariables;
Func&lt;<span style="color:Blue;">string</span>, <span style="color:Blue;">string</span>&gt; @ActionUrl;

<span style="color:Blue;">public</span> ActionResult SignInWithTwitter()
{
    <span style="color:Green;">//check for GetRedirectUrl and sets cookie</span>
    @SetCookie(<span style="color:Blue;">new</span> HttpCookie(<span style="color:#A31515;">&quot;RedirectUrl&quot;</span>, @GetRedirectUrl()));

    <span style="color:Green;">//build callback URL</span>
    <span style="color:Blue;">var</span> callback_url_builder = <span style="color:Blue;">new</span> UriBuilder
    {
        Host = @ServerVariables()[<span style="color:#A31515;">&quot;SERVER_NAME&quot;</span>],
        Port = <span style="color:Blue;">int</span>.Parse(@ServerVariables()[<span style="color:#A31515;">&quot;SERVER_PORT&quot;</span>]),
        Path = @ActionUrl(<span style="color:#A31515;">&quot;SignInWithTwitterCallback&quot;</span>),
    };

    <span style="color:Green;">//Call twitter.GetRequestToken</span>
    <span style="color:Blue;">var</span> url = _twitter.GetRequestToken(callback_url_builder.ToString());

    <span style="color:Green;">//redirect to the URL returned from Twitter.GetRequestToken</span>
    <span style="color:Blue;">return</span> Redirect(url);
}

</pre></div>
</div>
<p>(Note, I’m using the @ symbol as a prefix for injected delegates, in
order to make it easier to pick them out of the code. Looks kinda odd,
but it is valid C#.)</p>
<p>This is better in that it’s actually testable without requiring a metric
crapload of test code to mock the ASP.NET intrinsics. However, this
approach don’t have enough information to inject dependencies based on
type alone. For example, the @GetRedirectUrl is a Func&lt;string&gt; (i.e. a
function that takes no parameters and returns a string). However,
FormsAuth FormsCookieName and DefaultUrl properties would also be
represented as Func&lt;string&gt; delegates as well.</p>
<p>Most DI containers have support resolving dependencies by name and type,
but that makes declaring dependencies much tougher and more fragile in
my opinion. If you’re going to <del>limit yourself to static typing</del> write
compiled code, you might as well let the compiler do as much heavy
lifting as possible, right?</p>
<p>Also, wrapping each untestable method call in a delegate has made the
explosion of dependencies problem even worse. SignInWithTwitter declares
four new dependencies, the callback action (not shown) adds seven new
delegate dependencies and the sign out action adds one, making a total
of thirteen dependencies! (including the original ITwitterService).
However, none of these twelve delegate dependencies are shared across
action methods. So they aren’t really controller dependencies so much as
action dependencies. So what if I went ahead and declared them as action
dependencies directly?</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> Func&lt;ActionResult&gt; SignInWithTwitter(
    Func&lt;<span style="color:Blue;">string</span>&gt; @GetRedirectUrl,
    Action&lt;HttpCookie&gt; @SetCookie,
    Func&lt;NameValueCollection&gt; @ServerVariables,
    Func&lt;<span style="color:Blue;">string</span>, <span style="color:Blue;">string</span>&gt; @ActionUrl)
{
    <span style="color:Blue;">return</span> () =&gt;
    {
        <span style="color:Green;">//check for GetRedirectUrl and sets cookie</span>
        SetCookie(<span style="color:Blue;">new</span> HttpCookie(<span style="color:#A31515;">&quot;RedirectUrl&quot;</span>, GetRedirectUrl()));

        <span style="color:Green;">//build callback URL</span>
        <span style="color:Blue;">var</span> callback_url_builder = <span style="color:Blue;">new</span> UriBuilder
        {
            Host = ServerVariables()[<span style="color:#A31515;">&quot;SERVER_NAME&quot;</span>],
            Port = <span style="color:Blue;">int</span>.Parse(ServerVariables()[<span style="color:#A31515;">&quot;SERVER_PORT&quot;</span>]),
            Path = ActionUrl(<span style="color:#A31515;">&quot;LogOnCallback&quot;</span>),
        };

        <span style="color:Green;">//Call twitter.GetRequestToken</span>
        <span style="color:Blue;">var</span> url = _twitter.GetRequestToken(
            callback_url_builder.ToString());

        <span style="color:Green;">//redirect to the URL returned from Twitter.GetRequestToken</span>
        <span style="color:Blue;">return</span> Redirect(url);
    };
}

</pre></div>
</div>
<p>SignInWithTwitter is now a function that takes four delegates and
returns a delegate – we’re really down the functional programming rabbit
hole now!</p>
<p>The benefit of this approach is that I can make tradeoffs as I see fit
between controller and action dependencies. ITwitterService is still
injected via the AccountController constructor since it is used by two
of the three Account actions. Dependencies only used by a single action
can be scoped to that specific action so that only tests for a given
action method have to mock them out. And testing this is a breeze
compared to <a href="http://www.hanselman.com/blog/ASPNETMVCSessionAtMix08TDDAndMvcMockHelpers.aspx">having to mock out intrinsic ASP.NET
objects</a>.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[Fact]
<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> returns_redirect_result_with_getrequesttoken_url()
{
    <span style="color:Green;">//inject controller dependencies</span>
    <span style="color:Blue;">var</span> twitter = <span style="color:Blue;">new</span> Mock&lt;Models.ITwitterService&gt;(MockBehavior.Strict);
    twitter.Setup(t =&gt; t.GetRequestToken(It.IsAny&lt;<span style="color:Blue;">string</span>&gt;()))
        .Returns(<span style="color:#A31515;">&quot;http://fake.twittertest.local&quot;</span>);
    <span style="color:Blue;">var</span> controller = <span style="color:Blue;">new</span> AccountController(twitter.Object);

    <span style="color:Green;">//inject action dependencies</span>
    Func&lt;<span style="color:Blue;">string</span>&gt; @getRedirectUrl = () =&gt; <span style="color:#A31515;">&quot;/fake/redirect/url&quot;</span>;
    Action&lt;HttpCookie&gt; @setCookie = c =&gt; { };
    Func&lt;NameValueCollection&gt; @serverVariables =
        () =&gt; <span style="color:Blue;">new</span> NameValueCollection()
        {
            {<span style="color:#A31515;">&quot;SERVER_NAME&quot;</span>, <span style="color:#A31515;">&quot;testapp.local&quot;</span>},
            {<span style="color:#A31515;">&quot;SERVER_PORT&quot;</span>, <span style="color:#A31515;">&quot;8888&quot;</span>}
        };
    Func&lt;<span style="color:Blue;">string</span>, <span style="color:Blue;">string</span>&gt; @actionUrl = url =&gt; <span style="color:#A31515;">&quot;/fake/url/action/result&quot;</span>;
    <span style="color:Blue;">var</span> action = controller.SignInWithTwitter(@getRedirectUrl,
        @setCookie, @serverVariables, @actionUrl);

    <span style="color:Green;">//Invoke action</span>
    <span style="color:Blue;">var</span> result = action();

    <span style="color:Green;">//Validate</span>
    <span style="color:Blue;">var</span> redirectResult = Assert.IsType&lt;RedirectResult&gt;(result);
    Assert.Equal(<span style="color:#A31515;">&quot;http://fake.twittertest.local&quot;</span>, redirectResult.Url);
}

</pre></div>
</div>
<p>I could make this code even smaller by moving the action dependencies
out to be test fixture class fields. Assuming you write multiple tests
for each action method, this allows you to reuse the mock action
delegates across multiple methods. If I want to do negative testing, I
can easily define test-specific delegates that throw exceptions or
return unexpected values.</p>
<p>Of course, the down side to this approach is that MVC has <em>no</em> idea
what to do with an action method that returns Func&lt;ActionResult&gt;. I
could envision support for this pattern in MVC someday, though we’d need
a robust solution to the type+name dependency issue I described above.
For now, I will simply wrap the delegate injection version (aka the
testable version) of the action in a non-testable but MVC compatible
version that injects the right delegate dependencies.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> ActionResult SignInWithTwitter()
{
    <span style="color:Blue;">return</span> SignInWithTwitter(
        () =&gt; FormsAuthentication.GetRedirectUrl(<span style="color:Blue;">string</span>.Empty, <span style="color:Blue;">false</span>),
        Response.SetCookie,
        () =&gt; Request.ServerVariables,
        Url.Action)();
}

</pre></div>
</div>
<p>Since I’m using the untestable intrinsics, I can’t write any tests for
this method. However, it’s nearly declarative because the anonymous
delegates I’m injecting are closing over the untestable intrinsics.
Personally, I’m willing to make the tradeoff of having an declarative
yet untestable wrapper action method in order to get the delegate
injected easy-to-test version of SignInWithTwitter that has the real
implementation.</p>
