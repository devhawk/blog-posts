<p>In my <a href="/blog/2015/8/31/go-ahead-call-it-a-comeback">post relaunching DevHawk</a>, I mentioned that
the site is written entirely in C# except for about 30 lines of JavaScript. Like
many modern web content systems, Hawk uses <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.
I write blog posts in Markdown and then my publishing &quot;tool&quot; (frankly little more than
duct tape and bailing wire at this point) coverts the Markdown to HTML and
uploads it to Azure.</p>
<p>However, as I went thru and converted all my old content to Markdown, I
discovered that I needed some features that aren't supported by either the <a href="http://daringfireball.net/projects/markdown/">original
implementation</a> or the new
<a href="http://commonmark.org/">CommonMark</a> project. Luckily, I discovered the
<a href="https://github.com/markdown-it/markdown-it">markdown-it</a> project which implements
the CommonMark spec but also supports <a href="https://github.com/markdown-it/markdown-it#syntax-extensions">syntax extensions</a>.
Markdown-it already had extensions for all of the extra features I needed - things like
<a href="https://github.com/markdown-it/markdown-it#syntax-highlighting">syntax highlighting</a>,
<a href="https://github.com/markdown-it/markdown-it-footnote">footnotes</a> and
<a href="https://github.com/markdown-it/markdown-it-container">custom containers</a>.</p>
<p>The only problem with using markdown-it in Hawk is that it's written in JavaScript.
JavaScript <del>is a fine language</del> has lots of great libraries, but I
find it a chore to write significant amounts of code in JavaScript - especially async code.
I did try and rewrite my blog post upload tool in JavaScript.
It was much more difficult than the equivalent C# code.
Maybe once <a href="https://github.com/lukehoban/es6features#promises">promises</a>
become more widely used and <a href="https://github.com/tc39/ecmascript-asyncawait">async/await</a>
is available, JavaScript will feel like it has a reasonable developer experience to me.
Until then, C# remains my weapon of choice.</p>
<p>I wasn't willing to use JavaScript for the entire publishing tool, but I still needed
to use markdown-it <a id="fnref:1" href="#fn:1" class="footnote-ref"><sup>1</sup></a>. So I started looking for a way to integrate the small amount of
JavaScript code that renders Markdown into HTML in with the rest of my C# code base.
I was expecting to have to setup some kind of local web service with Node.js to host
the markdown-it code in and call out to it from C# with HttpClient.</p>
<p>But then I discovered <a href="http://tjanczuk.github.io/edge/">Edge.js</a>. Holy frak, Edge.js blew my mind.</p>
<p>Edge.js provides nearly seamless interop between .NET and Node.js.
I was able to drop the 30 lines of JavaScript code into my C# app and call it directly.
It took all of about 15 minutes to prototype and it's less than 5 lines of C# code.</p>
<p>Seriously, I think <a href="http://tomasz.janczuk.org/">Tomasz Janczuk</a> must be some kind of a wizard.</p>
<p>To demonstrate how simple Edge.js is to use, let me show you how I integrated markdown-it
into my publishing tool. Here is a somewhat simplified version of the JavaScript code
I use to render markdown in my tool using markdown-it, including syntax highlighting
and some other extensions.</p>
<div class="lang-js editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// highlight.js integration lifted unchanged from </span>
<span style="color:Green;">// https://github.com/markdown-it/markdown-it#syntax-highlighting</span>
<span style="color:Blue;">var</span> hljs  = require(<span style="color:#A31515;">&#39;highlight.js&#39;</span>);
<span style="color:Blue;">var</span> md = require(<span style="color:#A31515;">&#39;markdown-it&#39;</span>)({
  highlight: <span style="color:Blue;">function</span> (str, lang) {
    <span style="color:Blue;">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {
      <span style="color:Blue;">try</span> { 
        <span style="color:Blue;">return</span> hljs.highlight(lang, str).value;
      } <span style="color:Blue;">catch</span> (__) {}
    }

    <span style="color:Blue;">try</span> {
      <span style="color:Blue;">return</span> hljs.highlightAuto(str).value;
    } <span style="color:Blue;">catch</span> (__) {}

    <span style="color:Blue;">return</span> <span style="color:#A31515;">&#39;&#39;</span>; 
  }
});

<span style="color:Green;">// I use a few more extensions in my publishing tool, but you get the idea</span>
md.use(require(<span style="color:#A31515;">&#39;markdown-it-footnote&#39;</span>));
md.use(require(<span style="color:#A31515;">&#39;markdown-it-sup&#39;</span>));

<span style="color:Blue;">var</span> html = <span style="color:Blue;">return</span> md.render(markdown);

</pre></div>
</div>
<p>As you can see, most of the code is just setting up markdown-it and its extensions.
Actually rendering the markdown is just a single line of code.</p>
<p>In order to call this code from C#, we need to wrap the call to <code>md.render</code> with a
JavaScript function that follows the <a href="http://docs.nodejitsu.com/articles/getting-started/control-flow/what-are-callbacks">Node.js callback style</a>.
We pass this wrapper function back to Edge.js by returning it from the JavaScript code.</p>
<div class="lang-js editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Ain&#39;t first order functions grand? </span>
<span style="color:Blue;">return</span> <span style="color:Blue;">function</span> (markdown, callback) {
    <span style="color:Blue;">var</span> html = md.render(markdown);
    callback(<span style="color:Blue;">null</span>, html);
}

</pre></div>
</div>
<p>Note, I have to use the callback style in this case even though my code is syncronous.
I suspect I'm the outlier here. There's a lot more async Node.js code
out in the wild than syncronous.</p>
<p>To make this code available to C#, all you have to do is pass the JavaScript code into the
Edge.js <code>Func</code> function. Edge.js includes a embedded copy of Node.js as a DLL.
The <code>Func</code> function executes the JavaScript and wraps the returned Node.js callback
function in a .NET async delegate. The .NET delegate takes an <code>object</code> input
parameter and returns a <code>Task&lt;object&gt;</code>. The delegate input parameter is passed in
as the first parameter to the JavaScript function. The second parameter passed to the
callback function becomes the return value from the delegate (wrapped in a Task of course).
I haven't tested, but I assume Edge.js will convert the callback function's first
parameter to a C# exception if you pass a value other than null.</p>
<p>It sounds complex, but it's a trivial amount of code:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// markdown-it setup code omitted for brevity</span>
Func&lt;<span style="color:Blue;">object</span>, Task&lt;<span style="color:Blue;">object</span>&gt;&gt; _markdownItFunc = EdgeJs.Edge.Func(<span style="color:#A31515;">@&quot;
var md = require(&#39;markdown-it&#39;)() 

return function (markdown, callback) {
    var html = md.render(markdown);
    callback(null, html);
}&quot;</span>);
  
async Task&lt;<span style="color:Blue;">string</span>&gt; MarkdownItAsync(<span style="color:Blue;">string</span> markdown)
{
    <span style="color:Blue;">return</span> (<span style="color:Blue;">string</span>)await _markdownItFunc(markdown);
}

</pre></div>
</div>
<p>To make it easier to use from the rest of my C# code, I wrapped the Edge.js delegate
with a statically typed C# function. This handles type checking and casting as well as
provides intellisense for the rest of my app.</p>
<p>The only remotely negative thing I can say about Edge.js is that it
<a href="https://github.com/tjanczuk/edge/issues/279">doesn't support</a>
<a href="http://dotnet.github.io/core/">.NET Core</a> yet. I had to build my markdown rendering
tool as a &quot;traditional&quot; C# console app instead of a
<a href="http://jameschambers.com/2015/08/writing-custom-commands-for-dnx-with-asp-net-5-0/">DNX Custom Command</a>
like the rest of Hawk's command line utilities.
However, <a href="https://github.com/lstratman">Luke Stratman</a>
is <a href="https://github.com/medicomp/edge">working on</a> .NET Core support for Edge.js. So maybe I'll be able to migrate my
markdown rendering tool to DNX sooner rather than later.</p>
<p>Rarely have I ever discovered such an elegant solution to a problem I was having. Edge.js
simply rocks. As I <a href="https://twitter.com/DevHawk/status/637359972091752448">said on Twitter</a>,
I owe Tomasz a beer or five. Drop me a line Tomasz and let me know when you want to collect.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn:1">
<p>I also investigated what it would take to update an existing .NET Markdown implementation
like <a href="https://github.com/Knagis/CommonMark.NET">CommonMark.NET</a> or
<a href="http://tpetricek.github.io/FSharp.Formatting/">F# Formatting</a> to support custom syntax extensions.
That would have been dramatically more code than simply biting the bullet and rewriting the post upload
tool in JavaScript.<a href="#fnref:1" class="footnote-back-ref">&#8617;</a></p>
</li>
</ol>
</div>
